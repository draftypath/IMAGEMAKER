<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Image Maker Studio</title>
<link rel="icon" type="image/png" href="favicon.ico">
<!-- === FONT LOADING OPTIMIZATION: Load critical and fallback fonts first === -->
<link href="https://fonts.googleapis.com/css2?family=VT323&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
/* --- CRITICAL CSS: Inlined for fastest first paint --- */
:root{--bg:#f2efe8;--ink:#2b2b2b;--mid:#c2c2c2;--light:#faf9f5;--light-rgb:250,249,245;--shadow:#7a7a7a;--danger-color:#cc4444;--action-color:#4477cc;--success-color:#55cc55;--bg-rgb:242,239,232;--action-color-rgb:68,119,204;transition:--bg .3s, --ink .3s, --mid .3s, --light .3s, --shadow .3s, --action-color .3s, --danger-color .3s, --success-color .3s}
html{box-sizing:border-box}*,:before,:after{box-sizing:inherit}
body{font-family:'VT323',monospace;background:var(--bg);color:var(--ink);display:flex;flex-direction:column;align-items:center;padding:10px;margin:0;height:100vh;overflow:hidden;transition:background-color .3s,color .3s}
#loading-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:var(--bg);color:var(--ink);display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity .5s ease-in-out}
#loading-overlay h1{font-family:'VT323',monospace;font-size:2.5rem;text-shadow:1px 1px 0 var(--shadow)}
#loading-overlay h1::after{content:'.';display:inline-block;width:3ch;text-align:left;animation:ellipsis 1.4s infinite}
@keyframes ellipsis{0%{content:'.'}33%{content:'..'}66%{content:'...'}}

/* === INTEGRATED DROPDOWN STYLES START === */
.window{position:relative;background:var(--light);border:2px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s;border-radius:3px}
.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:2px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}
.titlebar-controls{display:flex;align-items:center;gap:8px}
.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:2px solid var(--ink)}
.controls-fake .btn-square:first-child{background-color:var(--success-color)}
.controls-fake .btn-square:last-child{background-color:var(--danger-color)}

/* Dropdown Button Styling */
#erase-tool-btn,#shortcuts-btn,#text-btn,#toggle-view-btn,#visuals-btn,#ai-tools-btn{font-family:inherit;font-size:1.1rem;background:var(--light);border:2px solid var(--ink);padding:0 8px;cursor:pointer;color:var(--ink);border-radius:3px;box-shadow:2px 2px 0 var(--shadow);transition:transform .15s ease-out,box-shadow .15s ease-out}
#erase-tool-btn:hover,#shortcuts-btn:hover,#text-btn:hover,#toggle-view-btn:hover,#visuals-btn:hover,#ai-tools-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}
#erase-tool-btn:active,#shortcuts-btn:active,#text-btn:active,#toggle-view-btn:active,#visuals-btn:active,#ai-tools-btn:active{transform:translate(2px,2px);box-shadow:none}
#toggle-view-btn{padding:0 4px;font-size:18px}
#erase-tool-dropdown,#shortcuts-dropdown,#text-dropdown,#visuals-dropdown,#ai-tools-dropdown{position:absolute;top:28px;background:rgba(var(--light-rgb),.65);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);border:2px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:.5rem 1rem;z-index:100;width:250px;border-radius:4px;opacity:0;transform:translateY(-10px);transition:opacity .2s ease-out,transform .2s ease-out;pointer-events:none;display:none;max-height:calc(100vh - 88px);overflow-y:auto}
#visuals-dropdown{right:382px;width:280px}
#erase-tool-dropdown{right:288px;width:auto}
#ai-tools-dropdown{right:198px}
#text-dropdown{right:102px;width:280px}
#shortcuts-dropdown{right:8px}
#erase-tool-dropdown.visible,#shortcuts-dropdown.visible,#text-dropdown.visible,#visuals-dropdown.visible,#ai-tools-dropdown.visible{opacity:1;transform:translateY(0);pointer-events:auto;display:block}
#erase-tool-dropdown h5,#shortcuts-dropdown h5,#text-dropdown h5,#visuals-dropdown h5,#ai-tools-dropdown h5{margin:0 0 .5rem;font-size:1.25rem;text-align:center}
#erase-tool-dropdown h6,#text-dropdown h6,#visuals-dropdown h6{font-size:1.15rem;font-weight:700;text-align:left;margin-top:.5rem;margin-bottom:.5rem;border-bottom:2px solid var(--mid);padding-bottom:2px}
.compact-slider-row{display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem}
.compact-slider-row label{flex-shrink:0;margin:0}
.compact-slider-row input[type=range]{width:100%}
.compact-color-row{display:flex;align-items:flex-start;gap:.75rem}
.compact-color-row .slider-container{flex:1}
.compact-color-row input[type=color]{width:100%;height:25px;padding:0;border:1px solid var(--ink)}
.compact-color-row label{margin-bottom:2px}
#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}
#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}
#shortcuts-dropdown li kbd{font-family:inherit;border:2px solid var(--ink);padding:0 4px;background:var(--bg);transition:background-color .3s,border-color .3s,color .3s}
main#studio-container{display:grid;grid-template-columns:320px 1fr;grid-template-rows:minmax(0,1fr);gap:1.5rem;padding:1.5rem;flex-grow:1;min-height:0}
#controls-panel{display:flex;flex-direction:column;gap:1rem;overflow-y:auto;min-height:0}
#canvas-panel{display:flex;align-items:center;justify-content:center;border:2px solid var(--ink);background-color:var(--mid);position:relative;min-height:0;transition:background-color .5s ease-in-out;overflow:hidden}
#controls-panel fieldset{border:2px solid var(--ink);padding:.8rem;margin:0}
.hidden{display:none!important}
.disabled{opacity:.5;pointer-events:none}
.slider-container{margin-bottom:.5rem}
.mg-btn{font-family:inherit;font-size:18px;background:color-mix(in srgb,var(--light) 95%,var(--ink) 5%);border:2px solid var(--ink);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0 var(--shadow);width:100%;white-space:nowrap;border-radius:3px}
.mg-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}
.mg-btn:active{transform:translate(2px,2px);box-shadow:none}
.mg-btn.disabled,.mg-btn:disabled{opacity:.5;pointer-events:none;box-shadow:none;transform:none}
.mg-btn.active{background-color:var(--action-color);color:var(--light);box-shadow:none;transform:translate(2px,2px)}
.eraser-mode-selector{display:flex;gap:.5rem}
#text-layer-manager{display:flex;gap:.5rem;align-items:center;padding-bottom:.5rem;margin-bottom:.5rem;border-bottom:2px solid var(--mid)}
.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}
.effects-controls{padding-left:1.5rem;border-left:2px solid var(--mid);margin-left:.5rem}
footer{height:28px;padding:0 8px;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:2px solid var(--ink)}
.footer-links,.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}
footer a{color:var(--ink);text-decoration:none;transition:opacity .2s,color .3s;opacity:.7}
footer a:hover{opacity:1}
footer a i{margin-right:.5em}
.mg-overlay-base{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .3s,visibility 0s .3s;background:rgba(10,10,10,.25)}
.mg-overlay-base.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .3s,visibility 0s 0s}
#canvas-placeholder{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center}
.placeholder-text{color:var(--shadow)}
#eraser-hardness-presets{justify-content:space-around;margin-top:.5rem}
#eraser-hardness-presets .mg-btn{width:32px;height:32px;border-radius:50%;padding:0;flex-shrink:0;border-width:2px;box-shadow:1px 1px 0 var(--shadow);transform:translateY(0)}
#eraser-hardness-presets .mg-btn:hover{transform:translate(1px,1px);box-shadow:none}
#eraser-hardness-presets .mg-btn.active{background-color:var(--action-color);transform:translateY(1px);box-shadow:none}
#assets-folder-fieldset{position:relative}
#assets-folder-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem}
#assets-folder-actions p{font-size:1.1rem;margin:0}
#mg-view-all-local-assets-btn{position:absolute;top:-14px;right:12px;width:auto;padding:2px 8px;font-size:16px;margin:0}
.visuals-main-tab-btn{font-family:inherit;font-size:16px;background:color-mix(in srgb,var(--light) 95%,var(--ink) 5%);border:2px solid var(--ink);padding:4px 8px;cursor:pointer;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0 var(--shadow);flex-grow:1;text-align:center;border-radius:3px}
.visuals-main-tab-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}
.visuals-main-tab-btn.active{background-color:var(--action-color);color:var(--light);transform:translate(2px,2px);box-shadow:none}
body[data-theme-name="classic light"] .mg-btn.active{color:var(--bg)}
#project-library-popup{width:90%;max-width:800px;height:80vh;padding:0;display:flex;flex-direction:column}
#project-library-popup .titlebar{flex-shrink:0}
#project-library-grids-container{flex-grow:1;overflow-y:auto}
.project-library-grid{padding:1rem;display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:1rem;align-content:flex-start}
.project-library-grid h5{grid-column:1/-1;text-align:left;font-size:1.25rem;margin:.5rem 0 0;border-bottom:2px solid var(--mid);padding-bottom:4px}
.library-grid-item{width:100%;aspect-ratio:1/1;border:2px solid var(--ink);background:color-mix(in srgb,var(--light) 90%,var(--ink) 10%);position:relative;box-shadow:3px 3px 0 var(--ink);transition:transform .15s ease-out,box-shadow .15s ease-out;border-radius:3px}
.library-grid-item .delete-btn{position:absolute;top:-8px;right:-8px;background:var(--danger-color);color:var(--light);border:2px solid var(--ink);width:24px;height:24px;font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;line-height:1;z-index:2;opacity:0;transition:all .15s ease-out;border-radius:2px;font-family:monospace}
.library-grid-item .favorite-btn{position:absolute;top:-8px;left:-8px;background:var(--mid);color:var(--ink);border:2px solid var(--ink);width:24px;height:24px;font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;line-height:1;z-index:2;opacity:0;transition:all .15s ease-out;border-radius:2px;box-shadow:1px 1px 0 var(--ink)}
.library-grid-item .delete-btn:hover,.library-grid-item .favorite-btn:hover{transform:translateY(-1px);box-shadow:2px 2px 0 var(--ink)}
.library-grid-item .delete-btn:active,.library-grid-item .favorite-btn:active{transform:scale(.95) translateY(1px);box-shadow:none}
.library-grid-item .favorite-btn.is-favorite{background-color:var(--action-color);transform:translateY(1px);box-shadow:none}
.library-grid-item .favorite-btn::before{font-family:"Font Awesome 6 Free";font-weight:400;content:"\f005";transition:font-weight .2s,color .2s}
.library-grid-item .favorite-btn.is-favorite::before{color:var(--light)}
.library-grid-item .favorite-btn:hover::before,.library-grid-item .favorite-btn.is-favorite::before{font-weight:900}
.library-grid-item:hover .delete-btn,.library-grid-item:hover .favorite-btn{opacity:1}
.library-grid-item>div{cursor:pointer;width:100%;height:100%}
.library-grid-item:hover{transform:translate(-2px,-2px) scale(1.03);box-shadow:5px 5px 0 var(--ink);border-color:var(--action-color)}
.library-grid-item img,.library-grid-item video{width:100%;height:100%;object-fit:cover;pointer-events:none}
.overlay-close-btn{width:16px;height:16px;background:var(--danger-color);border:2px solid var(--ink);color:var(--ink);font-family:'VT323',monospace;font-size:14px;line-height:1;display:flex;align-items:center;justify-content:center;padding:0;cursor:pointer;z-index:10;transition:filter .2s}
.overlay-close-btn:hover{filter:brightness(1.2)}
#project-library-popup .overlay-close-btn{margin-left:auto}
#mg-asset-picker-wrapper .overlay-close-btn{position:absolute;top:10px;right:12px}
#mg-asset-picker-wrapper.window{background:rgba(var(--light-rgb),.85);-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);padding:2rem;max-width:450px;width:90vw;text-align:center;color:var(--ink);height:auto;max-height:90vh}
body[data-theme-is-dark=true] #mg-asset-picker-wrapper,body[data-theme-is-dark=true] #mg-asset-picker-wrapper .overlay-close-btn{color:var(--ink)}
#mg-asset-picker-wrapper h4{font-size:1.8rem;font-weight:400;margin:0 0 .5rem}
#mg-asset-picker-wrapper>p{font-size:1rem;margin:0 0 1.5rem}
#mg-asset-drop-zone{border:4px dashed var(--mid);border-radius:10px;padding:2rem;color:var(--mid);cursor:pointer;transition:all .2s ease-in-out;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1}
#mg-asset-drop-zone h3{font-size:1.5rem;margin:0 0 .5rem;pointer-events:none}
#mg-asset-drop-zone p{font-size:1rem;margin:0;pointer-events:none}
#mg-asset-drop-zone.drag-over,#mg-asset-drop-zone:hover{border-color:var(--ink);color:var(--ink);background-color:rgba(var(--action-color-rgb),.1);border-style:solid}
</style>
</head>
<body>
<script>const themes={'classic light':{name:'classic light',isDark:!1,colors:['#f2efe8','#2b2b2b','#d98c5f'],css:{'--bg':'#f2efe8','--ink':'#2b2b2b','--mid':'#c2c2c2','--light':'#faf9f5','--shadow':'#7a7a7a','--action-color':'#2b2b2b','--danger-color':'#cc4444','--success-color':'#55cc55'}},dark:{name:'dark',isDark:!0,colors:['#1a1d2d','#e0e5f0','#e8a85a'],css:{'--bg':'#1a1d2d','--ink':'#e0e5f0','--mid':'#3d4a6e','--light':'#252a40','--shadow':'#0d0f16','--action-color':'#e0e5f0','--danger-color':'#a83e3e','--success-color':'#4a9d4a'}},'イーピーイッピ':{name:'イーピーイッピ',isDark:!0,colors:['#5c3d46','#dcd0c0','#a26769'],css:{'--bg':'#2a1d21','--ink':'#dcd0c0','--mid':'#5c3d46','--light':'#402d32','--shadow':'#1a1114','--action-color':'#a26769','--danger-color':'#a26769','--success-color':'#69a267'}},zarah:{name:'zarah',isDark:!1,colors:['#7b9c98','#eaf1f3','#495555'],css:{'--bg':'#7b9c98','--ink':'#eaf1f3','--mid':'#495755','--light':'#6c8985','--shadow':'#3e4a48','--action-color':'#eaf1f3'}},lavender:{name:'lavender',isDark:!1,colors:['#b3b3d9','#282846','#656599'],css:{'--bg':'#b3b3d9','--ink':'#282846','--mid':'#656599','--light':'#c4c4e2','--shadow':'#47476b','--action-color':'#8c58a6'}},café:{name:'café',isDark:!1,colors:['#ceb18d','#4e433f','#d4d2d1'],css:{'--bg':'#ceb18d','--ink':'#4e433f','--mid':'#d4d2d1','--light':'#f7f2ea','--shadow':'#8a7a6a','--action-color':'#8a6ea2'}},mizu:{name:'mizu',isDark:!1,colors:['#b8dceb','#091f2c','#89a5bb'],css:{'--bg':'#b8dceb','--ink':'#091f2c','--mid':'#89a5bb','--light':'#cfe5ee','--shadow':'#627382','--action-color':'#005a8e'}},'キティ':{name:'キティ',isDark:!1,colors:['#fdf6e3','#657b83','#93a1a1'],css:{'--bg':'#fdf6e3','--ink':'#657b83','--mid':'#93a1a1','--light':'#eee8d5','--shadow':'#586e75','--action-color':'#268bd2'}},aura:{name:'aura',isDark:!0,colors:['#29423D','#EAE8E1','#C9A59C'],css:{'--bg':'#1A2A27','--ink':'#EAE8E1','--mid':'#3E5D56','--light':'#29423D','--shadow':'#111C19','--action-color':'#C9A59C','--danger-color':'#b05454','--success-color':'#5a9e7a'}}};!function(){try{const e=localStorage.getItem('selectedTheme')||'classic light',t=themes[e];if(t){const o=document.createElement('style'),s=Object.entries(t.css).map(([e,t])=>`${e}: ${t};`).join('');o.textContent=`:root { ${s} }`,document.head.appendChild(o),document.body.dataset.themeName=e}}catch(e){console.warn("Theme pre-loader failed.",e)}}();</script>
<div class=window>
<div id=loading-overlay><h1>Initializing Image-Maker-Studio.exe</h1></div>
<div class=titlebar><span>Image-Maker-Studio.exe</span><div class=titlebar-controls>
<button id=toggle-view-btn title="Toggle Canvas View (Z)">⬚</button>
<button id=visuals-btn>Edit Visuals</button>
<div id=visuals-dropdown>
<h5>Visuals Editor</h5>
<div id=visuals-tabs class=eraser-mode-selector style=margin-bottom:.8rem><button id=visuals-tab-asset class=mg-btn type=button>Asset</button><button id=visuals-tab-background class="mg-btn active" type=button>Background</button></div>
<div id=asset-tab-panel class=hidden><div id=asset-visuals-controls class=disabled>
<h6>Filters</h6>
<div class=slider-container><label for=asset-opacity>Opacity</label><input type=range id=asset-opacity min=0 max=1 step=.01 value=1></div>
<div class=slider-container><label for=asset-brightness>Brightness</label><input type=range id=asset-brightness min=0 max=2 step=.01 value=1></div>
<div class=slider-container><label for=asset-saturation>Saturation</label><input type=range id=asset-saturation min=0 max=2 step=.01 value=1></div>
<h6>Drop Shadow</h6>
<div class=effects-checkbox style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem"><div><input type=checkbox id=shadow-enable><label for=shadow-enable>Enable</label></div><input type=color id=shadow-color value=#000000 style="width:100px;height:25px;border:1px solid var(--ink);padding:0"></div>
<div id=shadow-controls class="effects-controls disabled">
<div class=slider-container><label for=shadow-blur>Blur</label><input type=range id=shadow-blur min=0 max=50 value=10></div>
<div class=slider-container><label for=shadow-offset-x>Offset X</label><input type=range id=shadow-offset-x min=-50 max=50 value=10></div>
<div class=slider-container><label for=shadow-offset-y>Offset Y</label><input type=range id=shadow-offset-y min=-50 max=50 value=10></div>
</div>
<h6>Edge</h6>
<div class=effects-checkbox style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem"><div><input type=checkbox id=asset-edge-enable><label for=asset-edge-enable>Enable</label></div><input type=color id=asset-edge-color value=#FFFFFF style="width:100px;height:25px;border:1px solid var(--ink);padding:0"></div>
<div id=asset-edge-controls class="effects-controls disabled"><div class=slider-container><label for=asset-edge-width>Width</label><input type=range id=asset-edge-width min=0 max=20 value=4></div></div>
</div></div>
<div id=background-tab-panel><div id=background-visuals-controls>
<h6>Background Filters</h6>
<div class=slider-container><label for=bg-brightness>Brightness</label><input type=range id=bg-brightness min=0 max=2 step=.01 value=1></div>
<div class=slider-container><label for=bg-saturation>Saturation</label><input type=range id=bg-saturation min=0 max=2 step=.01 value=1></div>
</div></div></div>
<button id=erase-tool-btn>Erase</button>
<div id=erase-tool-dropdown>
<h5>Eraser Tool</h5>
<div class=eraser-mode-selector><button class=mg-btn id=erase-btn>Erase</button><button class=mg-btn id=unerase-btn>Unerase</button></div>
<div id=eraser-controls-wrapper class=disabled>
<div class=slider-container><label for=eraser-size-dropdown>Size</label><input type=range id=eraser-size-dropdown min=5 max=250 value=128></div>
<div class=slider-container><label for=eraser-strength-dropdown>Strength</label><input type=range id=eraser-strength-dropdown min=0 max=1 step=.01 value=1></div>
</div></div>
<button id=ai-tools-btn>BG Remover.exe</button><div id=ai-tools-dropdown><h5>Background Remover</h5></div><button id=text-btn>Text</button><div id=text-dropdown><h5>Text Editor</h5><div id=text-layer-manager><div id=text-layer-palette></div><button id=add-new-text-layer-btn class="palette-slot empty" title="Add new text layer">+</button></div><div id=text-visuals-controls class=disabled><div class=slider-container><label for=text-content>Text Content</label><textarea id=text-content rows=3 style="width:100%;font-family:inherit;font-size:1rem;padding:4px;border:1px solid var(--ink);background:var(--bg);line-height:1.1">New Text</textarea></div>
<div class=slider-container><label>Font</label><div id=custom-font-select><div id=font-select-trigger tabindex=0><span>VT323</span> <i class="fas fa-chevron-down"></i></div><div id=font-select-dropdown class=hidden><ul id=font-select-list></ul></div></div></div>
<div class=slider-container><label for=text-size>Size</label><input type=range id=text-size min=20 max=800 step=1 value=410></div>
<div class=compact-color-row>
<div class=slider-container><label for=text-color>Color</label><input type=color id=text-color value=#FFFFFF></div>
<div class=slider-container><label for=text-edge-color>Edge Color</label><input type=color id=text-edge-color value=#000000></div>
</div>
<div class=slider-container><label for=text-edge-width>Edge Density</label><input type=range id=text-edge-width min=0 max=20 step=.1 value=0></div>
<h6>Drop Shadow</h6>
<div class=effects-checkbox style="display:flex;justify-content:space-between;align-items:center"><div><input type=checkbox id=text-shadow-enable><label for=text-shadow-enable>Enable</label></div><div class=slider-container style="margin-bottom:0;width:60%"><label for=text-shadow-color style=margin-top:0>Color</label><input type=color id=text-shadow-color value=#000000 style="width:100%;border:none;padding:0"></div></div>
<div id=text-shadow-controls class="effects-controls disabled">
<div class=slider-container><label for=text-shadow-blur>Blur</label><input type=range id=text-shadow-blur min=0 max=50 value=10></div>
<div class=slider-container><label for=text-shadow-offset-x>Offset X</label><input type=range id=text-shadow-offset-x min=-50 max=50 value=10></div>
<div class=slider-container><label for=text-shadow-offset-y>Offset Y</label><input type=range id=text-shadow-offset-y min=-50 max=50 value=10></div>
</div>
<div id=text-zorder-controls style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem"><button id=text-move-back class=mg-btn type=button style="width:auto;padding:2px 8px">Move back</button><button id=text-move-forward class=mg-btn type=button style="width:auto;padding:2px 8px">Move forward</button></div></div></div>
<button id=shortcuts-btn>Shortcuts</button><div class=controls-fake><div class=btn-square></div><div class=btn-square></div></div>
<div id=shortcuts-dropdown><h5>Keyboard Shortcuts</h5><ul><li><span>Undo Last Action</span><kbd>Cmd/Ctrl + Z</kbd></li><li><span>Redo Last Action</span><kbd>Cmd/Ctrl + Y</kbd></li><li><span>Toggle Canvas View</span><kbd>Z</kbd></li><li><span>Enlarge Asset</span><kbd>D</kbd></li><li><span>Shrink Asset</span><kbd>F</kbd></li><li><span>Flip Asset Horizontally</span><kbd>S</kbd></li><li><span>Move Layer Forward</span><kbd>Q</kbd></li><li><span>Move Layer Backward</span><kbd>W</kbd></li><li><span>Delete Asset</span><kbd>Delete</kbd></li><li><span>Save Project</span><kbd>Cmd/Ctrl + S</kbd></li></ul></div>
</div></div><main id=studio-container><div id=controls-panel>
<fieldset id=assets-folder-fieldset><legend>Project Library</legend><button id=mg-view-all-local-assets-btn class=mg-btn>View All</button><div id=assets-folder-actions><p>Your recent assets</p></div><div id=mg-local-asset-palette></div><p style="font-size:1.1rem;margin-top:.6rem;margin-bottom:.5rem">Your recent backgrounds</p><div id=mg-local-background-palette></div></fieldset>
<fieldset id=layers-fieldset><legend>Layers</legend><p id=layer-instructions class=placeholder-text>Add a background to begin.</p><div id=mg-asset-palette></div></fieldset>
<fieldset><legend>Canvas Actions</legend><div class=action-buttons style="margin-bottom:.5rem;display:flex;gap:.5rem"><button class="mg-btn" id=mg-save-project-btn disabled>Save Project</button><button class="mg-btn" id=mg-clear-canvas-btn disabled>Clear Canvas</button></div><button class="mg-btn generate" id=mg-download-image-btn disabled>Download Image</button></fieldset></div><div id=canvas-panel>
<canvas id=mg-movie-canvas></canvas><canvas id=mg-controls-overlay-canvas></canvas><canvas id=mg-pasteboard-overlay-canvas></canvas><canvas id=mg-eraser-zoom></canvas>
<div id=mg-eraser-hud><div class="row eraser-mode-selector" style="margin-bottom:6px;width:100%"><button class="mg-btn" id=mg-hud-erase-btn type=button title=Erase>Erase</button><button class="mg-btn" id=mg-hud-unerase-btn type=button title=Unerase>Unerase</button></div><div class=row><label for=mg-eraser-size-mini style=font-size:14px>Size</label><input id=mg-eraser-size-mini type=range min=5 max=250 value=128></div><div class=row style="margin-top:4px"><label for=mg-eraser-strength-mini style=font-size:14px>Strength</label><input id=mg-eraser-strength-mini type=range min=0 max=1 step=.01 value=1></div></div>
<div id=canvas-placeholder><img src=welcome.png alt="Click or drag and drop to start creating"><h3>Click, Paste, or Drag & Drop File</h3><p>to add a background image & begin creating</p></div></div></main>
<footer><div class=footer-links><a href=#><i class="fas fa-envelope"></i>feedback</a><a href=#><i class="fab fa-twitter"></i>updates</a><a href=#><i class="fas fa-file-alt"></i>license</a><a href=#><i class="fas fa-shield-alt"></i>report</a><a href=#><i class="fas fa-lock"></i>privacy</a></div><div class=footer-right><a href=# id=theme-select-link><i class="fas fa-palette"></i><span id=current-theme-name></span></a><a href=# id=version-link><i class="fas fa-code-branch"></i>v4.18.1</a></div></footer>
<input type=file id=initial-background-input accept=image/* style=display:none></div>
<div id=mg-asset-library-overlay class=mg-overlay-base><div id=mg-asset-picker-wrapper class=window><button id=mg-asset-library-close class=overlay-close-btn>X</button><h4>Add a New Layer</h4><p>Add your own image to the current scene.</p><div id=mg-asset-drop-zone><h3>Click, Paste, or Drag & Drop File</h3><p>Supported formats: PNG, JPG, JPEG</p></div><div id=mg-asset-picker-actions><input type=file id=mg-asset-picker-file accept="image/png, image/jpeg" style=display:none></div></div></div>
<div id=project-library-popup-overlay class=mg-overlay-base><div id=project-library-popup class=window><div class=titlebar><span>Project Library</span><button id=project-library-popup-close class=overlay-close-btn>X</button></div><div class=library-tabs style="padding:.5rem 1rem;display:flex;gap:.5rem;border-bottom:2px solid var(--ink)"><button id=library-tab-projects class=visuals-main-tab-btn>Projects</button><button id=library-tab-assets class="visuals-main-tab-btn active">Assets</button><button id=library-tab-backgrounds class=visuals-main-tab-btn>Backgrounds</button><button id=library-tab-favorites class=visuals-main-tab-btn>Favorites</button></div><div id=project-library-grids-container style="flex-grow:1;overflow-y:auto"><div id=project-library-grid-projects class="project-library-grid hidden"></div><div id=project-library-grid-assets class=project-library-grid></div><div id=project-library-grid-backgrounds class="project-library-grid hidden"></div><div id=project-library-grid-favorites class="project-library-grid hidden"></div></div></div></div>
<div id=mg-confirmation-overlay class=mg-overlay-base><div id=mg-confirmation-dialog class=window><p id=mg-confirmation-text>Are you sure?</p><div class=action-buttons><button id="mg-confirm-yes-btn" class="mg-btn active" type=button>Yes</button><button id="mg-confirm-no-btn" class=mg-btn type=button>No</button></div></div></div>
<div id=mg-asset-action-overlay class=mg-overlay-base style="display:none"><div id=mg-asset-action-dialog class=window><p>How would you like to use this asset?</p><div class=action-buttons><button id=mg-asset-action-background-btn class=mg-btn>Set as Background</button><button id=mg-asset-action-layer-btn class=mg-btn>Add as Layer</button></div></div></div>
<div id=version-popup-overlay style="display:none"><div id=version-popup-content><span id=close-popup>X</span><h4>v4.18.1</h4><h6>12 Sep 2025</h6><p>A performance and user experience patch focused on improving initial load times and refining UI elements based on user feedback.</p><h5>Features</h5><ul><li><strong>performance:</strong> Implemented "critical CSS" to ensure the loading screen appears almost instantly. Non-essential styles are now loaded asynchronously.</li><li><strong>performance:</strong> Decorative fonts are now loaded on-demand when the user opens the Text Editor for the first time, saving multiple network requests on initial load.</li></ul><h5>Improvements</h5><ul><li><strong>performance:</strong> Removed the background removal tool to significantly reduce the initial JavaScript bundle size.</li><li><strong>performance:</strong> Replaced the welcome video with a static, compressed PNG to speed up the placeholder view.</li><li><strong>ux:</strong> The border style selector popup is now a perfectly sized, non-scrollable grid with centered previews and improved spacing.</li><li><strong>ux:</strong> Previews in the border style selector now use the theme's main ink color (e.g., black) instead of green for better visual consistency.</li><li><strong>ui:</strong> Added small 'x' markers to the corners of the "Classic Barb" border preview to better reflect its on-canvas appearance.</li></ul><h5>Fixes</h5><ul><li><strong>style:</strong> Corrected the "Classic Wiggle" rotator handle on the canvas, which was incorrectly showing a black fill; it now correctly shows only the green stroke.</li></ul><hr style=margin:2rem 0><h4>v4.18.0</h4><h6>11 Sep 2025</h6><p>A major update focused on UI/UX enhancements and bug fixes, particularly for the editing tools.</p><h5>Features</h5><ul><li><strong>ui:</strong> re-architected the 'Edit Visuals' dropdown into a tabbed interface ("Asset" and "Background") to improve organization and ensure it fits on smaller screens</li><li><strong>eraser:</strong> added a floating side HUD that appears when the eraser tool is active, providing quick access to primary controls without reopening the main dropdown</li><li><strong>ux:</strong> implemented a smooth "scrubbing" effect for sliders, which fades out non-essential UI elements during adjustment for better focus</li></ul><h5>Improvements</h5><ul><li><strong>style:</strong> reduced border and box-shadow thickness sitewide for a lighter, more refined aesthetic</li><li><strong>eraser:</strong> redesigned the side HUD with clear "Erase" and "Unerase" buttons that dynamically match the application's selected theme</li><li><strong>eraser:</strong> added a "Strength" slider to the side HUD for quick access to both primary brush settings</li><li><strong>eraser:</strong> refined the activation flow to keep the main dropdown open for initial adjustments; the side HUD now appears only after the user moves to the canvas</li><li><strong>ui:</strong> added smooth fade-in and fade-out transitions to the eraser's side HUD and magnifying zoom window for a more polished feel</li><li><strong>ux:</strong> the "Asset" tab in the Visuals Editor is now always clickable and provides a helpful toast message if no asset is currently selected</li><li><strong>ux:</strong> improved instructional text for the eraser, changing "Armed" to "Activated" and clarifying how to deactivate the tool</li><li><strong>text:</strong> renamed "Stroke Width" to "Density" in the Text Editor</li><li><strong>performance:</strong> capped the eraser's undo history to a maximum of 10 steps per layer to prevent excessive memory usage</li></ul><h5>Fixes</h5><ul><li><strong>download:</strong> implemented a missing `toast` function that was causing a critical error and preventing the "Download Image" button from working</li><li><strong>eraser:</strong> the floating side HUD no longer incorrectly disappears when a user interacts with its sliders</li><li><strong>eraser:</strong> the Size and Strength sliders are now perfectly synced in real-time between the main dropdown and the side HUD</li><li><strong>eraser:</strong> the side HUD now correctly disappears the moment an erase action begins (mouse-down) and reappears immediately upon release (mouse-up)</li><li><strong>ui:</strong> disabled the "scrubbing" fade-out effect for all "Strength" sliders, as hiding the UI was not necessary for that specific adjustment</li></ul></div></div>
<div id=theme-popup-overlay style="display:none"><div id=theme-popup-content><ul id=theme-list></ul></div></div>
<div id=mg-toast></div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
<script>
    const ImageMakerStudio = {
        config: {
            secondaryFontsLoaded: false,
            loadedFonts: new Set(['VT323']),
            themes: {},
            PASTEBOARD_MARGIN: 1500,
            FADE_IN_DURATION: 300,
            UI_MIN_PX: 120,
            UI_MAX_PX: 220,
            TARGET_RADIUS_PX: 34,
            MIN_MARGIN_PREVIEW: 12,
            MIN_ZOOM_FEEL: 1.08,
            BRUSH_MIN: 5,
            BRUSH_MAX: 250,
            HISTORY_LIMIT: 15,
            DEBOUNCE_DELAY: 500,
            availableFonts: [
                { name: 'VT323', value: "'VT323', monospace" }, { name: 'Yomogi', value: "'Yomogi', cursive" },
                { name: 'Young Serif', value: "'Young Serif', serif" }, { name: 'Special Elite', value: "'Special Elite', cursive" },
                { name: 'Rubik Mono One', value: "'Rubik Mono One', sans-serif" }, { name: 'Rubik Beastly', value: "'Rubik Beastly', cursive" },
                { name: 'Press Start 2P', value: "'Press Start 2P', cursive", style: "font-size: 0.6rem;" }, { name: 'Patua One', value: "'Patua One', cursive" },
                { name: 'Nosifer', value: "'Nosifer', cursive" }, { name: 'Monoton', value: "'Monoton', cursive" },
                { name: 'Modak', value: "'Modak', cursive" }, { name: 'Metal Mania', value: "'Metal Mania', cursive" },
                { name: 'Major Mono Display', value: "'Major Mono Display', monospace", style: "font-size: 0.8rem;" }, { name: 'Luckiest Guy', value: "'Luckiest Guy', cursive" },
                { name: 'Londrina Outline', value: "'Londrina Outline', cursive" }, { name: 'Joti One', value: "'Joti One', cursive" },
                { name: 'Gorditas', value: "'Gorditas', cursive" }, { name: 'Graduate', value: "'Graduate', cursive" },
                { name: 'Gloria Hallelujah', value: "'Gloria Hallelujah', cursive" }, { name: 'Frijole', value: "'Frijole', cursive" },
                { name: 'Erica One', value: "'Erica One', cursive" }, { name: 'Eater', value: "'Eater', cursive" },
                { name: 'Dokdo', value: "'Dokdo', cursive" }, { name: 'Cute Font', value: "'Cute Font', cursive" },
                { name: 'Creepster', value: "'Creepster', cursive" }, { name: 'Codystar', value: "'Codystar', cursive" },
                { name: 'Barrio', value: "'Barrio', cursive" }, { name: 'Bahiana', value: "'Bahiana', cursive" },
                { name: 'Astloch', value: "'Astloch', cursive" }, { name: 'Are You Serious', value: "'Are You Serious', cursive" }
            ],
            fontValueToNameMap: new Map(),
            BG_MODELS: { fast: './u2netp.onnx' },
        },
        
        state: {
            originalTheme: 'classic light',
            themeChosen: false,
            canvasState: { currentProjectId: null, backgroundElement: null, backgroundType: 'none', backgroundHash: null, bgBrightness: 1, bgSaturation: 1, layers: [] },
            assetCache: {},
            activeLayerId: null,
            movieInteraction: { active: false },
            animationFrameId: null,
            isAnimatingRender: false,
            masterWidth: 0,
            masterHeight: 0,
            isCanvasViewZoomedOut: false,
            eraserMode: 'none',
            isEraserArmed: false,
            eraseBrushPos: { x: 0, y: 0 },
            originalFontOnHover: null,
            toastTimeout: null,
            toastAnimationInterval: null,
            confirmCallback: null,
            lastEraseCanvasPoint: null,
            bgSessionCache: new Map(),
            history: [],
            historyIndex: -1,
        },

        dom: {},

        loadSpecificFonts(fontNames) {
            if (!Array.isArray(fontNames) || fontNames.length === 0) return Promise.resolve();
            const fontsToLoad = fontNames.filter(f => !this.config.loadedFonts.has(f));
            if (fontsToLoad.length === 0) return Promise.resolve();
            const batchSize = 10;
            const promises = [];
            for (let i = 0; i < fontsToLoad.length; i += batchSize) {
                const batch = fontsToLoad.slice(i, i + batchSize);
                const baseUrl = 'https://fonts.googleapis.com/css2?';
                const familyParams = batch.map(font => `family=${font.replace(/ /g, '+')}`).join('&');
                const url = `${baseUrl}${familyParams}&display=swap`;
                const promise = new Promise((resolve, reject) => {
                    const link = document.createElement('link');
                    link.href = url;
                    link.rel = 'stylesheet';
                    link.onload = () => { batch.forEach(f => this.config.loadedFonts.add(f)); resolve(); };
                    link.onerror = () => { console.error('Failed to load a batch of fonts:', batch); reject(new Error(`Could not load font batch: ${batch.join(', ')}`)); };
                    document.head.appendChild(link);
                });
                promises.push(promise);
            }
            return Promise.all(promises);
        },

        loadSecondaryFonts() {
            if (this.config.secondaryFontsLoaded) return;
            const allFontNames = this.config.availableFonts.map(f => f.name);
            this.loadSpecificFonts(allFontNames).then(() => { this.config.secondaryFontsLoaded = true; });
        },

        injectNonCriticalStyles() {
            const nonCriticalCSS = `textarea#text-content, #font-select-trigger span {color:var(--ink)}.window{position:relative;background:var(--light);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s;border-radius:3px}.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:1px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}.titlebar-controls{display:flex;align-items:center;gap:8px}.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:1px solid var(--ink)}.controls-fake .btn-square:first-child{background-color:var(--success-color)}.controls-fake .btn-square:last-child{background-color:var(--danger-color)}#shortcuts-btn,#visuals-btn,#text-btn,#toggle-view-btn,#erase-tool-btn,#ai-tools-btn{font-family:inherit;font-size:1.1rem;background:var(--light);border:1px solid;border-color:var(--mid) var(--ink) var(--ink) var(--mid);padding:0 8px;cursor:pointer;transition:all .2s;color:var(--ink);border-radius:3px;transform:translateY(-1px)}#shortcuts-btn:hover,#visuals-btn:hover,#text-btn:hover,#toggle-view-btn:hover,#erase-tool-btn:hover,#ai-tools-btn:hover{transform:translateY(-2px);filter:brightness(1.1)}#shortcuts-btn:active,#visuals-btn:active,#text-btn:active,#toggle-view-btn:active,#erase-tool-btn:active,#ai-tools-btn:active,#erase-tool-btn.active{transform:translateY(0);border-color:var(--ink) var(--mid) var(--mid) var(--ink)}#toggle-view-btn{padding:0 4px;font-size:18px}#shortcuts-dropdown{right:8px}#shortcuts-dropdown.visible{display:block}#shortcuts-dropdown h5{margin:0 0 .5rem 0;font-size:1.25rem;text-align:center}#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}#shortcuts-dropdown li kbd{font-family:inherit;border:1px solid var(--ink);padding:0 4px;background:var(--bg)}#visuals-dropdown,#text-dropdown,#shortcuts-dropdown,#erase-tool-dropdown,#ai-tools-dropdown{display:none;position:absolute;top:28px;background:rgba(var(--light-rgb),.3);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:.5rem 1rem;z-index:100;width:250px;transition:background .2s,backdrop-filter .2s,box-shadow .2s,border-color .2s;border-radius:4px}#visuals-dropdown{right:382px}#erase-tool-dropdown{right:288px}#ai-tools-dropdown{right:198px}#text-dropdown{right:74px}#visuals-dropdown.visible,#text-dropdown.visible,#erase-tool-dropdown.visible,#ai-tools-dropdown.visible{display:block}#visuals-dropdown h5,#visuals-dropdown h6,#visuals-dropdown .slider-container,#text-dropdown h5,#text-dropdown h6,#text-dropdown .slider-container,#erase-tool-dropdown h5,#erase-tool-dropdown h6,#erase-tool-dropdown .eraser-mode-controls,#erase-tool-dropdown>.mg-btn,#ai-tools-dropdown h5{transition:opacity .2s}#visuals-dropdown h5,#text-dropdown h5,#erase-tool-dropdown h5,#ai-tools-dropdown h5{margin:0 0 .5rem 0;font-size:1.25rem;text-align:center}#visuals-dropdown h6,#text-dropdown h6,#erase-tool-dropdown h6{font-size:1.15rem;font-weight:700;text-align:left;margin-top:.5rem;margin-bottom:.5rem;border-bottom:1px solid var(--mid);padding-bottom:2px}#visuals-dropdown label,#text-dropdown label,#erase-tool-dropdown label{display:block;margin-top:.5rem;font-size:1rem}#visuals-dropdown.is-scrubbing,#text-dropdown.is-scrubbing,#erase-tool-dropdown.is-scrubbing{background:transparent;backdrop-filter:none;-webkit-backdrop-filter:none;box-shadow:none;border-color:transparent}
            /* FIX: This rule now hides all non-slider UI in the visuals dropdown during scrubbing */
            #visuals-dropdown.is-scrubbing>h5,#visuals-dropdown.is-scrubbing #visuals-tabs,#visuals-dropdown.is-scrubbing h6,#visuals-dropdown.is-scrubbing .effects-checkbox,#visuals-dropdown.is-scrubbing input[type=color],#visuals-dropdown.is-scrubbing .slider-container:not(.is-active-slider){opacity:0;pointer-events:none}
            #text-dropdown.is-scrubbing>h5,#text-dropdown.is-scrubbing #text-layer-manager,#text-dropdown.is-scrubbing h6,#text-dropdown.is-scrubbing .effects-checkbox,#text-dropdown.is-scrubbing #text-move-forward,#text-dropdown.is-scrubbing #text-move-back,#text-dropdown.is-scrubbing .slider-container:not(.is-active-slider){opacity:0;pointer-events:none}
            #erase-tool-dropdown.is-scrubbing>h5,#erase-tool-dropdown.is-scrubbing .eraser-mode-selector,#erase-tool-dropdown.is-scrubbing #eraser-controls-wrapper>.slider-container:not(.is-active-slider){opacity:0;pointer-events:none}#visuals-dropdown.is-scrubbing .slider-container.is-active-slider,#text-dropdown.is-scrubbing .slider-container.is-active-slider,#erase-tool-dropdown.is-scrubbing .slider-container.is-active-slider{opacity:1;pointer-events:auto;transition:opacity .1s}#visuals-dropdown input[type=range],#text-dropdown input[type=range],#erase-tool-dropdown input[type=range],#mg-eraser-hud input[type=range]{width:100%;-webkit-appearance:none;appearance:none;height:2px;background:var(--ink);outline:0}#visuals-dropdown input[type=range]::-webkit-slider-thumb,#text-dropdown input[type=range]::-webkit-slider-thumb,#erase-tool-dropdown input[type=range]::-webkit-slider-thumb,#mg-eraser-hud input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer}#visuals-dropdown input[type=range]::-moz-range-thumb,#text-dropdown input[type=range]::-moz-range-thumb,#erase-tool-dropdown input[type=range]::-moz-range-thumb,#mg-eraser-hud input[type=range]::-moz-range-thumb{width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer;border:none}#asset-visuals-controls.disabled,#text-visuals-controls.disabled,#eraser-controls-wrapper.disabled{opacity:.5;pointer-events:none}.mg-btn{font-family:inherit;font-size:18px;background:var(--light);border:1px solid;border-color:var(--mid) var(--ink) var(--ink) var(--mid);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:all .2s;transform:translateY(-2px);border-radius:3px}.mg-btn:hover{filter:brightness(1.1);transform:translateY(-3px)}.mg-btn:disabled,.mg-btn.disabled{opacity:.5;pointer-events:none;transform:none;border-color:var(--mid)}.mg-btn:active,.mg-btn.active{transform:translateY(0);border-color:var(--ink) var(--mid) var(--mid) var(--ink);background-color:var(--action-color);color:var(--light)}body[data-theme-is-dark=true] .mg-btn.active{color:var(--bg)}.mg-btn.success{background-color:var(--success-color)}.mg-btn.generate{background-color:var(--ink);color:var(--light)}.mg-btn.generate:active{background-color:var(--ink);color:var(--light)}.hidden{display:none!important}#studio-container{display:grid;grid-template-columns:320px 1fr;grid-template-rows:minmax(0,1fr);gap:1.5rem;padding:1.5rem;flex-grow:1;min-height:0}#controls-panel{display:flex;flex-direction:column;gap:1rem;overflow-y:auto;min-height:0}#canvas-panel{display:flex;align-items:center;justify-content:center;border:1px solid var(--ink);background-color:var(--mid);position:relative;min-height:0;transition:background-color .5s ease-in-out;overflow:hidden}#controls-panel fieldset{background:var(--light);border:1px solid var(--ink);padding:.8rem;margin:0;text-align:left;transition:background-color .3s,border-color .3s,color .3s,opacity .3s;border-radius:3px}#controls-panel legend{font-size:1.2rem;font-weight:400;padding:0 .5rem;margin-left:.5rem;background:var(--light)}.placeholder-text{color:var(--mid);font-size:1.1rem;text-align:center;padding:1rem;width:100%}body[data-theme-is-dark=true] #layer-instructions{color:var(--ink)}#mg-asset-palette,#mg-local-asset-palette,#mg-local-background-palette{display:flex;gap:.5rem;flex-wrap:wrap;min-height:70px;align-content:flex-start}.palette-slot,.layer-thumb{width:60px;height:60px;border:1px solid var(--ink);background:color-mix(in srgb, var(--light) 90%, var(--ink) 10%);cursor:pointer;position:relative;border-radius:3px;box-shadow:3px 3px 0 var(--ink);transform:translate(0,0);transition:transform .15s ease-out,box-shadow .15s ease-out}.palette-slot.empty{display:flex;align-items:center;justify-content:center;font-size:3rem;line-height:1;color:var(--mid)}.layer-thumb:hover,.palette-slot.empty:hover{transform:translate(-2px,-2px);box-shadow:5px 5px 0 var(--ink)}.layer-thumb.active{transform:translate(1px,1px);box-shadow:none;border:2px solid var(--action-color)}.layer-thumb{cursor:grab}.layer-thumb img{width:100%;height:100%;object-fit:cover;pointer-events:none}.layer-controls{position:absolute;top:-5px;right:-5px;display:flex;gap:2px}.layer-btn{background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:700;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center}#mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{position:absolute}#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{pointer-events:none}#mg-movie-canvas{pointer-events:auto}#mg-asset-picker-actions{display:none}#mg-local-asset-grid,#mg-local-asset-grid-assets,#mg-local-asset-grid-backgrounds{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:1rem;overflow-y:auto;padding:1rem;flex-grow:1}.mg-template{position:relative;aspect-ratio:1/1;border:1px solid var(--mid);background-color:var(--bg);box-shadow:3px 3px 0 var(--ink);transition:transform .15s ease-out,box-shadow .15s ease-out;border-radius:3px}.mg-template:hover{transform:translate(-2px,-2px) scale(1.03);box-shadow:5px 5px 0 var(--ink)}.mg-template img{display:block;width:100%;height:100%;object-fit:cover;cursor:pointer}.mg-template .layer-btn.delete{position:absolute;top:4px;right:4px;z-index:5;width:22px;height:22px;font-size:1rem;display:flex;align-items:center;justify-content:center;border-radius:2px}.mg-btn.tab{color:var(--ink);opacity:.7;background:transparent;box-shadow:1px 1px 0 var(--shadow);transform:translateY(0);transition:transform .1s ease,box-shadow .1s ease,background-color .2s,opacity .2s}.mg-btn.tab:hover{opacity:1;transform:translateY(-1px);box-shadow:1px 1px 0 var(--shadow)}.mg-btn.tab.active{background-color:var(--mid);opacity:1;transform:translateY(1px);box-shadow:0 0 0 var(--shadow)}#mg-toast{visibility:hidden;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--light);border:1px solid var(--ink);padding:.5rem 1rem;color:var(--ink);font-size:1rem;z-index:2000;box-shadow:2px 2px 0 var(--shadow)}#canvas-placeholder{position:absolute;width:calc(100% - 20px);height:calc(100% - 20px);border:2px dashed var(--mid);border-radius:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:pointer;color:var(--mid);transition:all .2s;padding:2rem;overflow:hidden;position:relative}#canvas-placeholder h3,#canvas-placeholder p{position:relative;z-index:2}#canvas-placeholder img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:1;opacity:.6}#canvas-placeholder h3{font-size:2.2rem;margin:0 0 .5rem}#canvas-placeholder p{font-size:1.3rem}#canvas-placeholder:hover,#canvas-panel.drag-over #canvas-placeholder{border-color:var(--ink);color:var(--ink);background-color:rgba(255,255,255,.5)}#canvas-panel.drag-over{background-color:var(--shadow)}#layer-instructions{padding:0 0 .5rem 0;margin:0;font-size:1.1rem}#mg-confirmation-overlay,#mg-asset-action-overlay{z-index:5000}#mg-confirmation-dialog,#mg-asset-action-dialog{padding:1.5rem;text-align:center;width:90%;max-width:400px;height:auto}#mg-confirmation-dialog p,#mg-asset-action-dialog p{font-size:1.2rem;margin:0 0 1.5rem}#mg-confirmation-dialog .action-buttons,#mg-asset-action-dialog .action-buttons{display:flex;justify-content:center;gap:.5rem}#text-content,#text-font{transition:background-color .3s,border-color .3s,color .3s}#text-layer-manager{display:flex;gap:.5rem;align-items:center;padding-bottom:.5rem;margin-bottom:.5rem;border-bottom:1px solid var(--mid)}#text-layer-palette{display:flex;gap:.5rem;flex-wrap:wrap;flex-grow:1;min-height:44px}#add-new-text-layer-btn{width:40px;height:40px;flex-shrink:0;font-size:2rem;line-height:1;padding:0}.text-thumb{width:60px;height:40px;display:flex;align-items:center;justify-content:center;overflow:hidden;background-color:var(--ink);color:var(--light);font-size:.8rem;padding:2px;text-align:center}.text-thumb span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;pointer-events:none}.palette-slot.empty:disabled{opacity:.4;cursor:default;pointer-events:none;background-color:var(--light)}.palette-slot.empty:disabled:hover{background-color:var(--light);color:var(--mid)}#shortcuts-btn:disabled,#visuals-btn:disabled,#text-btn:disabled,#erase-tool-btn:disabled,#ai-tools-btn:disabled{opacity:.5;pointer-events:none;cursor:default}.layer-thumb.dragging{opacity:.4;transform:rotate(-3deg) scale(1.05);box-shadow:0 8px 20px rgba(0,0,0,.3);cursor:grabbing}.layer-thumb.drag-over{border:3px dashed var(--action-color);transform:scale(1.02);background-color:rgba(var(--action-color-rgb),.1)}#mg-pasteboard-overlay-canvas{position:absolute;pointer-events:none;display:none}#canvas-panel.is-zoomed-out{background-color:var(--shadow)}#mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{transition:transform .3s ease-in-out,box-shadow .3s ease-in-out}#canvas-panel.is-zoomed-out #mg-movie-canvas,#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas,#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{transform:scale(.8);box-shadow:0 0 15px rgba(0,0,0,.5)}#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas{display:none}#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{display:block}#toggle-view-btn:disabled,#toggle-view-btn:disabled:hover{opacity:.5;pointer-events:none;cursor:default}.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}.effects-checkbox input{margin-right:.5rem}.effects-controls{padding-left:1.5rem;border-left:1px solid var(--mid);margin-left:.5rem}.effects-controls.disabled{opacity:.5;pointer-events:none}#erase-tool-btn.active{background-color:var(--action-color);color:var(--light)}#mg-movie-canvas.erase-cursor{cursor:none}#erase-tool-dropdown .mg-btn{margin-top:.5rem}.eraser-mode-selector{display:flex;gap:.5rem;margin-bottom:.5rem}.eraser-mode-selector .mg-btn{width:50%;margin:0;padding:4px 8px;font-size:16px}.eraser-mode-selector .mg-btn:active,.eraser-mode-selector .mg-btn.active{background-color:var(--action-color);color:var(--light);transform:none;box-shadow:inset 1px 1px 0 rgba(0,0,0,.2)}#mg-eraser-hud .mg-btn.active{background-color:var(--action-color);color:var(--light);transform:translateY(1px);box-shadow:none}body[data-theme-is-dark=true] .mg-eraser-hud .mg-btn.active{color:var(--bg)}#assets-folder-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem}#assets-folder-actions p{font-size:1.1rem;margin:0}#assets-folder-fieldset.disabled legend{color:var(--shadow)}#mg-eraser-zoom,#mg-eraser-hud{position:absolute;z-index:5;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .2s,visibility 0s .2s}#mg-eraser-zoom.visible,#mg-eraser-hud.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .2s,visibility 0s 0s}#mg-eraser-zoom{right:12px;bottom:12px;width:160px;height:160px;border:1px solid var(--ink);background:var(--light);box-shadow:2px 2px 0 var(--shadow)}#mg-eraser-hud{right:12px;bottom:184px;background:var(--light);border:1px solid var(--ink);padding:6px 8px;box-shadow:2px 2px 0 var(--shadow);z-index:6;transition:background .2s,border-color .2s,box-shadow .2s,opacity .2s,visibility 0s .2s}#mg-eraser-hud .row{display:flex;align-items:center;gap:.5rem;transition:opacity .2s}#mg-eraser-hud button{font-family:inherit;font-size:14px;background:transparent;color:var(--ink);border:1px solid var(--ink);padding:2px 8px;cursor:pointer;box-shadow:1px 1px 0 var(--shadow)}#mg-eraser-hud.is-scrubbing{background:transparent;border-color:transparent;box-shadow:none}#mg-eraser-hud.is-scrubbing .row:not(.is-active-slider){opacity:0;pointer-events:none}#mg-eraser-hud.is-scrubbing .row.is-active-slider{opacity:1;pointer-events:auto}footer{padding:.5rem 1.5rem;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;flex-wrap:wrap;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:none}.footer-links,.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}footer a{color:var(--ink);text-decoration:none;transition:opacity .2s;opacity:.7}footer a:hover{opacity:1}footer a i{margin-right:.5em}@media (max-width:980px){footer{justify-content:center}}#theme-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:7000}#theme-popup-content{background:var(--bg);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:1rem;width:90%;max-width:400px;max-height:80vh;display:flex;flex-direction:column;transition:background-color .3s}#theme-list{list-style:none;margin:0;padding:0;overflow-y:auto}#theme-list li{padding:.75rem 1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .2s;border-radius:4px}#theme-list li.active{background-color:var(--action-color);color:var(--light)}body[data-theme-is-dark=true] #theme-list li.active{color:var(--bg)}#theme-list li.active span{flex-grow:1}#theme-list li.active::before{content:'✓';margin-right:.5rem}#theme-list li:not(.active):hover{background-color:var(--mid)}.theme-colors{display:flex;gap:.5rem}.theme-color-dot{width:16px;height:16px;border-radius:50%;border:1px solid var(--ink)}#version-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.7);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:6000}#version-popup-content{background-color:var(--bg);padding:2rem;border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:80%;height:80%;max-width:800px;position:relative;color:var(--ink);overflow-y:auto}#version-popup-content h4{font-size:2rem;margin-bottom:.5rem}#version-popup-content h6{font-size:1rem;margin-top:0;opacity:.7;margin-bottom:1.5rem}#version-popup-content h5{font-size:1.5rem;margin-top:1.5rem;border-bottom:1px solid var(--mid);padding-bottom:.25rem}#version-popup-content ul{list-style:none;padding-left:0}#version-popup-content li{margin-bottom:.75rem;line-height:1.4}#close-popup{position:absolute;top:1rem;right:1.5rem;font-size:2rem;color:var(--ink);cursor:pointer;font-family:'VT323',monospace;line-height:1;transition:opacity .2s}#close-popup:hover{opacity:.6}#custom-font-select{position:relative}#font-select-trigger{background:var(--bg);border:1px solid var(--ink);padding:4px 8px;font-size:1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .3s,border-color .3s}#font-select-trigger:focus,#custom-font-select.open #font-select-trigger{border-color:var(--action-color)}#font-select-trigger span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}#font-select-trigger i{transition:transform .2s ease-in-out;font-size:.8em}#custom-font-select.open #font-select-trigger i{transform:rotate(180deg)}#font-select-dropdown{position:absolute;top:calc(100% + 2px);left:0;right:0;background:var(--light);border:1px solid var(--ink);z-index:101;max-height:250px;overflow-y:auto;box-shadow:2px 2px 0 var(--shadow)}#font-select-list{list-style:none;margin:0;padding:0}#font-select-list li{padding:6px 10px;cursor:pointer;transition:background-color .2s;white-space:nowrap;font-size:.9rem}#font-select-list li:hover,#font-select-list li.hover-preview{background-color:var(--mid)}#font-select-list li.selected{background-color:var(--action-color);color:var(--light)}body[data-theme-is-dark=true] #font-select-list li.selected{color:var(--bg)}`;
            const style = document.createElement('style');
            style.textContent = nonCriticalCSS;
            document.head.appendChild(style);
        },

              applyTheme(themeName, isPreview = false) {
            const theme = themes[themeName];
            if (!theme) return;
            const root = document.documentElement;
            if (isPreview) { root.style.transition = 'none'; }
            for (const [key, value] of Object.entries(theme.css)) {
                root.style.setProperty(key, value);
                if (key === '--light') root.style.setProperty('--light-rgb', this.hexToRgb(value));
                if (key === '--bg') root.style.setProperty('--bg-rgb', this.hexToRgb(value));
                if (key === '--action-color') root.style.setProperty('--action-color-rgb', this.hexToRgb(value));
            }
            document.body.dataset.themeIsDark = theme.isDark;
            document.body.dataset.themeName = themeName;
            if (isPreview) { void root.offsetWidth; root.style.transition = ''; }
        },

        hexToRgb(hex) {
            let r=0,g=0,b=0;
            if(hex.length==4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16)}
            else if(hex.length==7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16)}
            return `${r},${g},${b}`;
        },

        saveAndApplyTheme(themeName) {
            this.state.themeChosen = true;
            this.applyTheme(themeName);
            localStorage.setItem('selectedTheme', themeName);
            this.state.originalTheme = themeName;
            this.dom.currentThemeNameSpan.textContent = themeName;
            const currentActive = this.dom.themeList.querySelector('.active');
            if (currentActive) currentActive.classList.remove('active');
            const newActive = this.dom.themeList.querySelector(`[data-theme-name="${themeName}"]`);
            if (newActive) newActive.classList.add('active');
            this.dom.themePopupOverlay.style.display = 'none';
        },

               populateThemeList() {
            this.dom.themeList.innerHTML = '';
            const currentTheme = localStorage.getItem('selectedTheme') || 'classic light';
            for (const themeName in themes) {
                const theme = themes[themeName];
                const li = document.createElement('li');
                li.dataset.themeName = themeName;
                if(themeName === currentTheme) li.classList.add('active');
                let content = `<span>${theme.name}</span>`;
                let colorDots = '<div class="theme-colors">';
                theme.colors.forEach(color => { colorDots += `<div class="theme-color-dot" style="background-color: ${color};"></div>`; });
                colorDots += '</div>';
                li.innerHTML = content + colorDots;
                li.addEventListener('click', () => this.saveAndApplyTheme(themeName));
                li.addEventListener('mouseenter', () => this.applyTheme(themeName, true));
                this.dom.themeList.appendChild(li);
            }
        },
        
        showLoadingScreen(message = 'Loading...') {
            this.dom.loadingMessage.textContent = message;
            this.dom.loadingOverlay.style.display = 'flex';
            void this.dom.loadingOverlay.offsetWidth; 
            this.dom.loadingOverlay.style.opacity = '1';
        },

        hideLoadingScreen() {
            this.dom.loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                this.dom.loadingOverlay.style.display = 'none';
            }, 500);
        },

        toast(message, duration = 3000) {
            if (!this.dom.toastEl) return;
            clearTimeout(this.state.toastTimeout);
            clearInterval(this.state.toastAnimationInterval);
            this.dom.toastEl.textContent = message;
            this.dom.toastEl.style.visibility = 'visible';
            if (duration !== null) {
                this.state.toastTimeout = setTimeout(() => {
                    this.dom.toastEl.style.visibility = 'hidden';
                    clearInterval(this.state.toastAnimationInterval);
                }, duration);
            }
        },

        hideToast() {
            if (!this.dom.toastEl) return;
            clearTimeout(this.state.toastTimeout);
            clearInterval(this.state.toastAnimationInterval);
            this.dom.toastEl.style.visibility = 'hidden';
        },

        async sha256Hex(blob) {
            const buf = await blob.arrayBuffer();
            const digest = await crypto.subtle.digest('SHA-256', buf);
            const bytes = new Uint8Array(digest);
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        },

        idbOpen(dbName = 'ims-db') {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(dbName, 5);
                req.onupgradeneeded = (e) => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('assets')) {
                        const assetsStore = db.createObjectStore('assets', { keyPath: 'id', autoIncrement: true });
                        assetsStore.createIndex('createdAt', 'createdAt');
                        assetsStore.createIndex('hash', 'hash', { unique: false });
                        assetsStore.createIndex('kind', 'kind', { unique: false });
                    }
                     if (!db.objectStoreNames.contains('projects')) {
                        const projectsStore = db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
                        projectsStore.createIndex('createdAt', 'createdAt');
                    }
                    if (e.oldVersion < 5) {
                        const assetsStore = req.transaction.objectStore('assets');
                        if (!assetsStore.indexNames.contains('isFavorite')) {
                            assetsStore.createIndex('isFavorite', 'isFavorite');
                        }
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        },

        async idbGet(id, storeName) {
            const db = await this.idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        },

        async idbPut(record, storeName) {
            const db = await this.idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                const req = tx.objectStore(storeName).put(record);
                req.onsuccess = () => { if (record.id == null) record.id = req.result; };
                tx.oncomplete = () => resolve(record);
                tx.onerror = () => reject(tx.error);
            });
        },

        async idbGetAll(storeName) {
            const db = await this.idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        },

        async idbDelete(id, storeName) {
            const db = await this.idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                tx.objectStore(storeName).delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        },
        
        async idbFindByHash(hash) {
            const db = await this.idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('assets', 'readonly');
                const os = tx.objectStore('assets');
                const idx = os.index('hash');
                const req = idx.getAll(hash);
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
            });
        },

        async dedupeExistingAssetsByHashKeepNewest() {
            const all = await this.idbGetAll('assets');
            for (const rec of all) {
                if (!rec.hash && rec.full) {
                    try {
                        if (!(rec.full instanceof Blob)) { throw new Error("Asset data is not a valid Blob."); }
                        rec.hash = await this.sha256Hex(rec.full);
                        await this.idbPut(rec, 'assets');
                    } catch (error) {
                        console.error(`A corrupted or invalid asset record (ID: ${rec.id}) was detected and will be deleted.`, { record: rec, error: error });
                        if (rec.id) { await this.idbDelete(rec.id, 'assets'); }
                    }
                }
            }
            const byHash = new Map();
            const cleanAssets = await this.idbGetAll('assets'); 
            for (const rec of cleanAssets) {
                if (!rec.hash) continue;
                const best = byHash.get(rec.hash);
                if (!best || rec.createdAt > best.createdAt) { byHash.set(rec.hash, rec); }
            }
            for (const rec of cleanAssets) {
                if (rec.hash && byHash.has(rec.hash) && byHash.get(rec.hash).id !== rec.id) {
                    await this.idbDelete(rec.id, 'assets');
                }
            }
            await this.renderLocalAssetPalette_IDB();
            await this.renderLocalBackgroundPalette_IDB();
        },

        async toBlobFromDataURL(dataURL) { const res = await fetch(dataURL); return await res.blob(); },

        async createThumbBlob(imgBlob, max = 256, type = 'image/webp', quality = 0.8) {
            try {
                const bmp = await createImageBitmap(imgBlob);
                const scale = Math.min(max / bmp.width, max / bmp.height, 1);
                const w = Math.round(bmp.width * scale);
                const h = Math.round(bmp.height * scale);
                const c = new OffscreenCanvas(w, h);
                c.getContext('2d').drawImage(bmp, 0, 0, w, h);
                return await c.convertToBlob({ type, quality });
            } catch (e) {
                console.error("Could not create thumbnail from blob, possibly a non-image type.", e);
                return await (await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAmMBb3eGmC0AAAAASUVORK5CYII=')).blob();
            }
        },
        
        async saveAssetToLibrary({ dataURL, mime = 'image/png', kind = 'asset' }) {
            const fullBlob = await this.toBlobFromDataURL(dataURL);
            const hash = await this.sha256Hex(fullBlob);
            const existingAssets = await this.idbFindByHash(hash);
            const existingAssetOfSameKind = existingAssets.find(a => a.kind === kind);
            const thumbBlob = await this.createThumbBlob(fullBlob);
            const record = {
                full: fullBlob, thumb: thumbBlob, mime,
                createdAt: Date.now(), hash, kind,
                isFavorite: existingAssetOfSameKind ? existingAssetOfSameKind.isFavorite : false
            };
            if (existingAssetOfSameKind) { record.id = existingAssetOfSameKind.id; }
            await this.idbPut(record, 'assets');
            await this.enforceQuota(80 * 1024 * 1024);
            await this.renderLocalAssetPalette_IDB();
            await this.renderLocalBackgroundPalette_IDB();
            if (this.dom.projectLibraryPopupOverlay.classList.contains('visible')) {
                await this.populateProjectLibraryPopup();
            }
            return hash;
        },
        
        async enforceQuota(limitBytes) {
            const assets = await this.idbGetAll('assets');
            let totalBytes = assets.reduce((sum, r) => sum + (r.full?.size || 0) + (r.thumb?.size || 0), 0);
            if (totalBytes <= limitBytes) return;

            const nonFavorites = assets.filter(a => !a.isFavorite);
            nonFavorites.sort((a, b) => a.createdAt - b.createdAt);
            
            for (const rec of nonFavorites) {
                if (totalBytes <= limitBytes) break;
                await this.idbDelete(rec.id, 'assets');
                totalBytes -= (rec.full?.size || 0) + (rec.thumb?.size || 0);
                this.toast('Oldest non-favorite asset removed to free space.', 3000);
            }
        },
        
        async deleteAssetFromLibrary(assetId) {
            try {
                const idNum = typeof assetId === 'string' ? Number(assetId) : assetId;
                if (!Number.isFinite(idNum)) throw new Error(`Invalid asset id: ${assetId}`);
                await this.idbDelete(idNum, 'assets');
                this.toast('Asset removed from folder.', 1500);
                await this.renderLocalAssetPalette_IDB();
                await this.renderLocalBackgroundPalette_IDB();
                if (this.dom.projectLibraryPopupOverlay.classList.contains('visible')) { await this.populateProjectLibraryPopup(); }
            } catch (error) {
                console.error("Failed to delete asset:", error);
                this.toast("Error: Could not delete asset.", 4000);
            }
        },

        async renderLocalAssetPalette_IDB() {
            const all = await this.idbGetAll('assets');
            const assetsOnly = all.map(r => ({ ...r, kind: r.kind || 'asset' })).filter(r => r.kind === 'asset').sort((a, b) => b.createdAt - a.createdAt);
            this.dom.localAssetPalette.innerHTML = '';
            const toShow = assetsOnly.slice(0, 4);
            for (const asset of toShow) {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.title = "Add asset as a new layer";
                const thumbUrl = URL.createObjectURL(asset.thumb);
                const img = new Image();
                img.src = thumbUrl;
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                thumb.appendChild(img);
                thumb.addEventListener('click', () => {
                    if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
                    this.addImageLayer(URL.createObjectURL(asset.full), asset.hash);
                });
                this.dom.localAssetPalette.appendChild(thumb);
            }
            if (assetsOnly.length === 0) { this.dom.localAssetPalette.innerHTML = `<p class="placeholder-text" style="padding:0;line-height:1.2;">Your recent assets will appear here.</p>`; }
        },

        async renderLocalBackgroundPalette_IDB() {
            const all = await this.idbGetAll('assets');
            const backgroundsOnly = all.filter(r => (r.kind || 'asset') === 'background').sort((a, b) => b.createdAt - a.createdAt);
            this.dom.localBackgroundPalette.innerHTML = '';
            const toShow = backgroundsOnly.slice(0, 3);
            for (const bg of toShow) {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.title = "Set as background";
                const thumbUrl = URL.createObjectURL(bg.thumb);
                const img = new Image();
                img.src = thumbUrl;
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                thumb.appendChild(img);
                thumb.addEventListener('click', () => {
                    const fullUrl = URL.createObjectURL(bg.full);
                    const fullImage = new Image();
                    fullImage.onload = () => { this.setBackground(fullImage, bg.hash); URL.revokeObjectURL(fullUrl); };
                    fullImage.onerror = () => { this.toast('Error loading this background.'); URL.revokeObjectURL(fullUrl); }
                    fullImage.src = fullUrl;
                });
                this.dom.localBackgroundPalette.appendChild(thumb);
            }
            const addBgBtn = document.createElement('button');
            addBgBtn.className = 'palette-slot empty';
            addBgBtn.innerHTML = '+';
            addBgBtn.title = "Add or change background";
            addBgBtn.addEventListener('click', () => this.dom.initialBackgroundInput.click());
            this.dom.localBackgroundPalette.appendChild(addBgBtn);
        },

        setLocalFolderTab(tab) {
            const isProjects = tab === 'projects', isAssets = tab === 'assets', isBackgrounds = tab === 'backgrounds', isFavorites = tab === 'favorites';
            this.dom.libraryTabProjectsBtn.classList.toggle('active', isProjects);
            this.dom.libraryTabAssetsBtn.classList.toggle('active', isAssets);
            this.dom.libraryTabBackgroundsBtn.classList.toggle('active', isBackgrounds);
            this.dom.libraryTabFavoritesBtn.classList.toggle('active', isFavorites);
            this.dom.projectLibraryGridProjects.classList.toggle('hidden', !isProjects);
            this.dom.projectLibraryGridAssets.classList.toggle('hidden', !isAssets);
            this.dom.projectLibraryGridBackgrounds.classList.toggle('hidden', !isBackgrounds);
            this.dom.projectLibraryGridFavorites.classList.toggle('hidden', !isFavorites);
        },

        switchAndSaveLibraryTab(tabId) {
            this.setLocalFolderTab(tabId);
            localStorage.setItem('ims-last-library-tab', tabId);
        },
        
        async deleteProjectFromLibrary(projectId) {
            await this.idbDelete(projectId, 'projects');
            this.toast('Project deleted from library.', 2000);
            await this.populateProjectLibraryPopup();
        },
        
        async loadProjectFromLibrary(projectId) {
            this.showLoadingScreen('Loading Project');
            const minDisplayTime = new Promise(resolve => setTimeout(resolve, 2400));
            const loadingPromise = (async () => {
                const projectRecord = await this.idbGet(projectId, 'projects');
                if (!projectRecord) throw new Error("Project not found.");
                projectRecord.projectState.currentProjectId = projectId;
                await this.restoreProjectState(projectRecord.projectState);
            })();
            try {
                await Promise.all([minDisplayTime, loadingPromise]);
                this.dom.projectLibraryPopupOverlay.classList.remove('visible');
                this.toast("Project loaded.", 2000);
            } catch (e) {
                console.error("Failed to load project from library:", e);
                this.toast(`Error: Could not load project. ${e.message}`, 4000);
            } finally {
                this.hideLoadingScreen();
            }
        },

        async populateProjectLibraryPopup() {
            const allAssets = await this.idbGetAll('assets');
            const createAssetGridItem = async (rec, onClick, context = 'recents') => {
                const item = document.createElement('div');
                item.className = 'library-grid-item';
                item.dataset.assetId = String(rec.id);
                const content = document.createElement('div');
                const thumbUrl = URL.createObjectURL(rec.thumb);
                content.innerHTML = `<img src="${thumbUrl}" alt="${rec.kind}">`;
                content.addEventListener('click', () => { onClick(rec); this.dom.projectLibraryPopupOverlay.classList.remove('visible'); });
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                const favoriteBtn = document.createElement('button');
                favoriteBtn.className = 'favorite-btn';
                favoriteBtn.classList.toggle('is-favorite', !!rec.isFavorite);
                favoriteBtn.title = rec.isFavorite ? 'Remove from favorites' : 'Add to favorites';
                if (context === 'favorites') {
                    deleteBtn.style.display = 'none';
                    favoriteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openConfirmationModal('Remove this from your favorites?', async () => {
                           const assetToUpdate = await this.idbGet(rec.id, 'assets');
                           assetToUpdate.isFavorite = false;
                           await this.idbPut(assetToUpdate, 'assets');
                           this.toast('Removed from favorites.', 2000);
                           await this.populateProjectLibraryPopup();
                           this.closeConfirmationModal();
                        });
                    });
                } else {
                    deleteBtn.title = `Permanently delete from storage`;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openConfirmationModal('Permanently delete this item?', async () => {
                            await this.deleteAssetFromLibrary(rec.id);
                            this.closeConfirmationModal();
                        });
                    });
                    favoriteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const assetToUpdate = await this.idbGet(rec.id, 'assets');
                        assetToUpdate.isFavorite = !assetToUpdate.isFavorite;
                        await this.idbPut(assetToUpdate, 'assets');
                        await this.populateProjectLibraryPopup();
                        this.toast(assetToUpdate.isFavorite ? `${assetToUpdate.kind.charAt(0).toUpperCase() + assetToUpdate.kind.slice(1)} added to favorites!` : 'Removed from favorites.', 2000);
                    });
                }
                item.appendChild(content);
                item.appendChild(deleteBtn);
                item.appendChild(favoriteBtn);
                return item;
            };

            const assets = allAssets.filter(r => (r.kind || 'asset') === 'asset').sort((a,b) => b.createdAt - a.createdAt);
            const bgs = allAssets.filter(r => r.kind === 'background').sort((a,b) => b.createdAt - a.createdAt);
            const favoriteAssets = allAssets.filter(r => r.isFavorite && (r.kind || 'asset') === 'asset').sort((a,b) => b.createdAt - a.createdAt);
            const favoriteBgs = allAssets.filter(r => r.isFavorite && r.kind === 'background').sort((a,b) => b.createdAt - a.createdAt);

            this.dom.projectLibraryGridAssets.innerHTML = '<h5>Recent Assets</h5>';
            if (assets.length === 0) { this.dom.projectLibraryGridAssets.insertAdjacentHTML('beforeend', `<p class="placeholder-text">No recent assets.</p>`); } 
            else { for (const rec of assets) this.dom.projectLibraryGridAssets.appendChild(await createAssetGridItem(rec, r => {
                    if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
                    this.addImageLayer(URL.createObjectURL(r.full), r.hash);
                }));
            }

            this.dom.projectLibraryGridBackgrounds.innerHTML = '<h5>Recent Backgrounds</h5>';
            if (bgs.length === 0) { this.dom.projectLibraryGridBackgrounds.insertAdjacentHTML('beforeend', `<p class="placeholder-text">No recent backgrounds.</p>`); } 
            else { for(const rec of bgs) this.dom.projectLibraryGridBackgrounds.appendChild(await createAssetGridItem(rec, r => {
                    const fullUrl = URL.createObjectURL(r.full);
                    const imgEl = new Image();
                    imgEl.onload = () => { this.setBackground(imgEl, r.hash); URL.revokeObjectURL(fullUrl); };
                    imgEl.onerror = () => { URL.revokeObjectURL(fullUrl); this.toast('Could not load background image.', 3000); };
                    imgEl.src = fullUrl;
                }));
            }

            this.dom.projectLibraryGridFavorites.innerHTML = '';
             if (favoriteAssets.length > 0) {
                 this.dom.projectLibraryGridFavorites.insertAdjacentHTML('beforeend', '<h5>Favorite Assets</h5>');
                 for(const rec of favoriteAssets) this.dom.projectLibraryGridFavorites.appendChild(await createAssetGridItem(rec, r => {
                    if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
                    this.addImageLayer(URL.createObjectURL(r.full), r.hash);
                }, 'favorites'));
            }
            if (favoriteBgs.length > 0) {
                 this.dom.projectLibraryGridFavorites.insertAdjacentHTML('beforeend', '<h5>Favorite Backgrounds</h5>');
                 for(const rec of favoriteBgs) this.dom.projectLibraryGridFavorites.appendChild(await createAssetGridItem(rec, r => {
                    const fullUrl = URL.createObjectURL(r.full);
                    const imgEl = new Image();
                    imgEl.onload = () => { this.setBackground(imgEl, r.hash); URL.revokeObjectURL(fullUrl); };
                    imgEl.onerror = () => { URL.revokeObjectURL(fullUrl); this.toast('Could not load background image.', 3000); };
                    imgEl.src = fullUrl;
                }, 'favorites'));
            }
            if (favoriteAssets.length === 0 && favoriteBgs.length === 0) {
                this.dom.projectLibraryGridFavorites.innerHTML = `<p class="placeholder-text">Star an asset or background to save it here.</p>`;
            }

            const allProjects = await this.idbGetAll('projects');
            this.dom.projectLibraryGridProjects.innerHTML = '<h5>Saved Projects</h5>';
            if (allProjects.length === 0) { this.dom.projectLibraryGridProjects.insertAdjacentHTML('beforeend', `<p class="placeholder-text">No saved projects.</p>`); }
            else {
                allProjects.sort((a, b) => b.createdAt - a.createdAt).forEach(rec => {
                    const item = document.createElement('div');
                    item.className = 'library-grid-item';
                    item.dataset.projectId = String(rec.id);
                    const content = document.createElement('div');
                    const thumbUrl = URL.createObjectURL(rec.thumbnail);
                    content.innerHTML = `<img src="${thumbUrl}" alt="Saved Project">`;
                    content.addEventListener('click', () => this.loadProjectFromLibrary(rec.id));
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = `Delete project`;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.openConfirmationModal('Permanently delete this project?', async () => {
                            await this.deleteProjectFromLibrary(rec.id);
                            this.closeConfirmationModal();
                        });
                    });
                    item.appendChild(content);
                    item.appendChild(deleteBtn);
                    this.dom.projectLibraryGridProjects.appendChild(item);
                });
            }
        },

        async handleBackgroundUpload(file) {
            if (!file || !file.type.startsWith('image/')) { this.toast('Unsupported file type for background. Please use an image.'); return; }
            const reader = new FileReader();
            reader.onload = async (e) => {
                const dataURL = e.target.result;
                const hash = await this.saveAssetToLibrary({ dataURL, kind: 'background' });
                const img = new Image();
                img.onload = () => { this.setBackground(img, hash); };
                img.onerror = () => this.toast('Could not load background image.');
                img.src = dataURL;
            };
            reader.readAsDataURL(file);
        },
        
        async processUploadedFile(file) {
            if (!file || !['image/png', 'image/jpeg'].includes(file.type)) {
                this.toast('Unsupported file type. Please use PNG, JPG, or JPEG.', 3000);
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                const dataURL = e.target.result;
                const hash = await this.saveAssetToLibrary({ dataURL, kind: 'asset' });
                this.addImageLayer(dataURL, hash);
                this.closeAddLayerPopup();
            };
            reader.readAsDataURL(file);
        },
        
        async handleNewAsset(src, hash) {
            if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
            if (!src.startsWith('blob:')) { hash = await this.saveAssetToLibrary({ dataURL: src, kind: 'asset' }); }
            this.addImageLayer(src, hash);
        },
        
        calculateContentBounds(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    if (data[(y * canvas.width + x) * 4 + 3] > 0) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            if (maxX === -1) {
                return { x: 0, y: 0, width: canvas.width, height: canvas.height, isEmpty: true };
            }

            return {
                x: minX,
                y: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1,
                isEmpty: false
            };
        },

        addImageLayer(src, hash) {
            if (!this.state.canvasState.backgroundElement) { this.toast('Please add a background image first.', 2000); return; }
            const createFromImage = (img) => {
                const w = img.naturalWidth || 0, h = img.naturalHeight || 0;
                if (!w || !h) { img.addEventListener('load', () => createFromImage(img), { once: true }); return; }
                const proxyCanvas = document.createElement('canvas');
                proxyCanvas.width = w; proxyCanvas.height = h;
                proxyCanvas.getContext('2d').drawImage(img, 0, 0);

                const contentFrame = this.calculateContentBounds(proxyCanvas);

                const newSize = Math.max(20, Math.min(this.dom.movieCanvas.width, this.dom.movieCanvas.height) * 0.4);
                const newLayer = { 
                    id: (Date.now() + Math.random()).toString(), 
                    src, hash, asset: img, type: 'image', 
                    x: this.dom.movieCanvas.width / 2, y: this.dom.movieCanvas.height / 2, 
                    size: newSize, rot: 0, flipX: false, opacity: 1, 
                    brightness: 1, saturation: 1, 
                    shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 }, 
                    border: { enabled: false, color: '#FFFFFF', width: 4 }, 
                    proxyCanvas, proxyCtx: proxyCanvas.getContext('2d'), 
                    createdAt: Date.now(),
                    contentFrame: contentFrame 
                };
                newLayer.propX = newLayer.x / this.dom.movieCanvas.width;
                newLayer.propY = newLayer.y / this.dom.movieCanvas.height;
                newLayer.propSize = newLayer.size / this.dom.movieCanvas.width;
                this.state.canvasState.layers.unshift(newLayer);
                this.state.activeLayerId = newLayer.id;
                this.renderLayerPalette();
                this.renderTextLayerPalette();
                this.updateEditPanelsUI();
                this.triggerAnimatedRender();
                this.saveState();
            };
            if (this.state.assetCache[src]) { createFromImage(this.state.assetCache[src]); return; }
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => { this.state.assetCache[src] = image; createFromImage(image); };
            image.onerror = () => this.toast(`Could not load asset: ${src}`);
            image.src = src;
        },

        updateControlsState() {
            const hasBackground = !!this.state.canvasState.backgroundElement;
            this.dom.downloadImageBtn.disabled = !hasBackground;
            this.dom.saveProjectBtn.disabled = !hasBackground;
            this.dom.clearCanvasBtn.disabled = !hasBackground;
            this.dom.visualsBtn.disabled = !hasBackground;
            this.dom.textBtn.disabled = !hasBackground;
            this.dom.eraseToolBtn.disabled = !hasBackground;
            this.dom.aiToolsBtn.disabled = !hasBackground;
            this.dom.addNewTextLayerBtn.disabled = !hasBackground;
            this.renderLayerPalette();
            this.renderTextLayerPalette();
        },

        setBackground(element, hash, isRestoring = false) {
            const isFirstBackground = !this.state.canvasState.backgroundElement;
            this.state.canvasState.backgroundElement = element;
            this.state.canvasState.backgroundType = 'image';
            this.state.canvasState.backgroundHash = hash;
            if (!isRestoring) { this.state.canvasState.currentProjectId = null; }
            const w = element.naturalWidth, h = element.naturalHeight;
            const MIN_CANVAS_SIDE = 1280;
            let canvasW = w, canvasH = h;
            if (w < MIN_CANVAS_SIDE || h < MIN_CANVAS_SIDE) {
                const ratio = w / h;
                if (ratio < 1) { canvasW = MIN_CANVAS_SIDE; canvasH = MIN_CANVAS_SIDE / ratio; }
                else { canvasH = MIN_CANVAS_SIDE; canvasW = MIN_CANVAS_SIDE * ratio; }
            }
            this.state.masterWidth = w; this.state.masterHeight = h;
            const newCanvasWidth = Math.round(canvasW), newCanvasHeight = Math.round(canvasH);
            this.dom.movieCanvas.width = this.dom.controlsOverlayCanvas.width = newCanvasWidth;
            this.dom.movieCanvas.height = this.dom.controlsOverlayCanvas.height = newCanvasHeight;
            if (!isFirstBackground && this.state.canvasState.layers.length > 0) {
                this.toast('Adapting layers to new background...', 2000);
                this.state.canvasState.layers.forEach(l => {
                    l.x = l.propX * this.dom.movieCanvas.width;
                    l.y = l.propY * this.dom.movieCanvas.height;
                    if (l.type === 'image') { l.size = l.propSize * this.dom.movieCanvas.width; }
                    else if (l.type === 'text') { l.fontSize = l.propSize * this.dom.movieCanvas.height; }
                });
            }
            this.resizeCanvas();
            this.updateControlsState();
            this.updateEditPanelsUI();
            let startTime = null;
            const animateBackground = (currentTime) => {
                if (!startTime) startTime = currentTime;
                const progress = Math.min((currentTime - startTime) / 500, 1);
                if (!this.dom.canvasPlaceholder.classList.contains('hidden')) { this.dom.canvasPlaceholder.classList.add('hidden'); }
                this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
                this.dom.movieCtx.save();
                this.dom.movieCtx.globalAlpha = progress;
                this.dom.movieCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
                this.dom.movieCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
                this.dom.movieCtx.restore();
                this.drawLayers(this.dom.movieCtx, this.state.canvasState.layers);
                this.drawControlsOverlay();
                if (progress < 1) { requestAnimationFrame(animateBackground); } 
                else { this.drawFrame(); if (!isRestoring) { this.saveState(); } }
            }
            requestAnimationFrame(animateBackground);
            if (isFirstBackground) { this.toast('Background set! Add layers to create your image.', 3000); }
        },
        
        resizeCanvas() {
            const panelWidth = this.dom.canvasPanel.clientWidth, panelHeight = this.dom.canvasPanel.clientHeight;
            if (panelWidth === 0 || panelHeight === 0) return;
            const canvasAspectRatio = this.dom.movieCanvas.width / this.dom.movieCanvas.height;
            let displayWidth, displayHeight;
            if (panelWidth / panelHeight > canvasAspectRatio) { displayHeight = panelHeight; displayWidth = displayHeight * canvasAspectRatio; } 
            else { displayWidth = panelWidth; displayHeight = displayWidth / canvasAspectRatio; }
            const topOffset = (panelHeight - displayHeight) / 2, leftOffset = (panelWidth - displayWidth) / 2;
            [this.dom.movieCanvas, this.dom.controlsOverlayCanvas].forEach(c => {
                c.style.width = `${displayWidth}px`; c.style.height = `${displayHeight}px`;
                c.style.position = 'absolute'; c.style.top = `${topOffset}px`; c.style.left = `${leftOffset}px`;
            });
            this.dom.pasteboardOverlayCanvas.width = this.dom.movieCanvas.width + this.config.PASTEBOARD_MARGIN * 2;
            this.dom.pasteboardOverlayCanvas.height = this.dom.movieCanvas.height + this.config.PASTEBOARD_MARGIN * 2;
            const scaleFactor = displayWidth / this.dom.movieCanvas.width;
            this.dom.pasteboardOverlayCanvas.style.width = `${this.dom.pasteboardOverlayCanvas.width * scaleFactor}px`;
            this.dom.pasteboardOverlayCanvas.style.height = `${this.dom.pasteboardOverlayCanvas.height * scaleFactor}px`;
            const pasteboardTopOffset = topOffset - (this.config.PASTEBOARD_MARGIN * scaleFactor);
            const pasteboardLeftOffset = leftOffset - (this.config.PASTEBOARD_MARGIN * scaleFactor);
            this.dom.pasteboardOverlayCanvas.style.position = 'absolute';
            this.dom.pasteboardOverlayCanvas.style.top = `${pasteboardTopOffset}px`;
            this.dom.pasteboardOverlayCanvas.style.left = `${pasteboardLeftOffset}px`;
        },
        
        openAddLayerPopup() {
            if (!this.state.canvasState.backgroundElement) { this.toast('Please set a background before adding layers.', 2000); return; }
            this.dom.addLayerOverlay.classList.add('visible');
        },

        closeAddLayerPopup() { this.dom.addLayerOverlay.classList.remove('visible'); },

        updateLayerInstructions() {
            this.dom.layerInstructions.classList.remove('placeholder-text');
            if (!this.state.canvasState.backgroundElement) { this.dom.layerInstructions.textContent = "Add a background to begin."; this.dom.layerInstructions.classList.add('placeholder-text'); } 
            else if (this.state.canvasState.layers.filter(l => l.type === 'image').length === 0) { this.dom.layerInstructions.textContent = "Click '+' to add your first visual layer."; } 
            else { this.dom.layerInstructions.textContent = "Click & drag layers to re-order them, or use [Q] & [W]."; }
        },

        renderTextLayerPalette() {
            this.dom.textLayerPalette.innerHTML = '';
            if (!this.state.canvasState.backgroundElement) return;
            const textLayers = this.state.canvasState.layers.filter(l => l.type === 'text');
            textLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb text-thumb';
                thumb.classList.toggle('active', layer.id === this.state.activeLayerId);
                thumb.dataset.layerId = layer.id;
                thumb.title = "Click to select";
                thumb.innerHTML = `<span>${layer.text.split('\n')[0] || "Empty"}</span><div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                thumb.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (e.target.classList.contains('layer-btn')) return;
                     if (this.state.activeLayerId !== layer.id) this.deactivateEraser();
                    this.state.activeLayerId = layer.id;
                    this.renderLayerPalette();
                    this.renderTextLayerPalette();
                    this.updateEditPanelsUI();
                    this.drawFrame();
                });
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); this.deleteMovieLayer(layer.id); };
                this.dom.textLayerPalette.appendChild(thumb);
            });
        },
        
        addDragAndDropHandlers(thumb) {
            thumb.setAttribute('draggable', 'true');
            thumb.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', thumb.dataset.layerId); setTimeout(() => thumb.classList.add('dragging'), 0); });
            thumb.addEventListener('dragend', () => { document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); thumb.classList.remove('dragging'); });
            thumb.addEventListener('dragover', (e) => { e.preventDefault(); if (document.querySelector('.dragging') !== thumb) { thumb.classList.add('drag-over'); } });
            thumb.addEventListener('dragleave', () => thumb.classList.remove('drag-over'));
            thumb.addEventListener('drop', (e) => {
                e.preventDefault();
                thumb.classList.remove('drag-over');
                const draggedId = e.dataTransfer.getData('text/plain');
                const droppedOnId = thumb.dataset.layerId;
                if (draggedId === droppedOnId) return;
                const i1 = this.state.canvasState.layers.findIndex(l => l.id.toString() === draggedId);
                const i2 = this.state.canvasState.layers.findIndex(l => l.id.toString() === droppedOnId);
                if (i1 > -1 && i2 > -1) {
                    const [item] = this.state.canvasState.layers.splice(i1, 1);
                    this.state.canvasState.layers.splice(i2, 0, item);
                    this.renderLayerPalette();
                    if(this.updateTextOrderButtonsState) this.updateTextOrderButtonsState();
                    this.drawFrame();
                    this.saveState();
                }
            });
        },
        
        renderLayerPalette() {
            this.dom.assetPalette.innerHTML = '';
            this.updateLayerInstructions();
            const hasBackground = !!this.state.canvasState.backgroundElement;
            const visualLayers = hasBackground ? this.state.canvasState.layers.filter(l => l.type === 'image') : [];
            visualLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.classList.toggle('active', layer.id === this.state.activeLayerId);
                thumb.dataset.layerId = layer.id;
                let thumbSrc = '';
                try { thumbSrc = layer.proxyCanvas.toDataURL(); } catch (e) { thumbSrc = ''; }
                thumb.innerHTML = `${thumbSrc ? `<img src="${thumbSrc}">` : '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:10px;">(loading)</div>'}<div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                this.addDragAndDropHandlers(thumb);
                thumb.addEventListener('click', (e) => {
                    if (e.target.classList.contains('layer-btn')) return;
                    if (this.state.activeLayerId !== layer.id) this.deactivateEraser();
                    this.state.activeLayerId = layer.id;
                    this.renderLayerPalette();
                    this.renderTextLayerPalette();
                    this.updateEditPanelsUI();
                    this.drawFrame();
                });
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); this.deleteMovieLayer(layer.id); };
                this.dom.assetPalette.appendChild(thumb);
            });
            const emptySlot = document.createElement('button');
            emptySlot.className = 'palette-slot empty';
            emptySlot.innerHTML = '+';
            emptySlot.title = hasBackground ? 'Add a new image asset' : 'Add a background to enable layers';
            emptySlot.disabled = !hasBackground;
            if (hasBackground) { emptySlot.onclick = () => this.openAddLayerPopup(); }
            this.dom.assetPalette.appendChild(emptySlot);
        },
        
        switchVisualsTab(tabToShow) {
            const isAssetTab = tabToShow === 'asset';
            this.dom.visualsTabAssetBtn.classList.toggle('active', isAssetTab);
            this.dom.visualsTabBackgroundBtn.classList.toggle('active', !isAssetTab);
            this.dom.assetTabPanel.classList.toggle('hidden', !isAssetTab);
            this.dom.backgroundTabPanel.classList.toggle('hidden', isAssetTab);
        },
        
        updateAssetVisualsUI() {
            const activeLayer = this.getActiveLayer();
            if (activeLayer && activeLayer.type === 'image') {
                if (this.dom.visualsDropdown.classList.contains('visible') && !this.dom.visualsTabAssetBtn.classList.contains('active')) { this.switchVisualsTab('asset'); }
                this.dom.assetVisualsControls.classList.remove('disabled');
                this.dom.assetOpacitySlider.value = activeLayer.opacity;
                this.dom.assetBrightnessSlider.value = activeLayer.brightness;
                this.dom.assetSaturationSlider.value = activeLayer.saturation;
                document.getElementById('shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('shadow-color').value = activeLayer.shadow.color;
                document.getElementById('shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('shadow-offset-y').value = activeLayer.shadow.offsetY;
                document.getElementById('asset-edge-enable').checked = activeLayer.border.enabled;
                document.getElementById('asset-edge-controls').classList.toggle('disabled', !activeLayer.border.enabled);
                document.getElementById('asset-edge-color').value = activeLayer.border.color;
                document.getElementById('asset-edge-width').value = activeLayer.border.width;
            } else {
                if (this.dom.visualsDropdown.classList.contains('visible') && this.dom.visualsTabAssetBtn.classList.contains('active')) { this.switchVisualsTab('background'); }
                this.dom.assetVisualsControls.classList.add('disabled');
            }
        },
        
        populateCustomFontSelector() {
            this.dom.fontSelectList.innerHTML = '';
            this.config.availableFonts.sort((a, b) => a.name.localeCompare(b.name));
            this.config.availableFonts.forEach(font => {
                const li = document.createElement('li');
                li.textContent = font.name;
                li.dataset.fontValue = font.value;
                li.style.fontFamily = font.value;
                if (font.style) { li.setAttribute('style', `font-family: ${font.value}; ${font.style}`); }
                li.addEventListener('mouseenter', (e) => this.handleFontHoverPreview(e));
                li.addEventListener('click', (e) => this.handleFontSelect(e));
                this.dom.fontSelectList.appendChild(li);
            });
        },

        handleFontHoverPreview(e) {
            const activeLayer = this.getActiveLayer();
            if (!activeLayer || activeLayer.type !== 'text') return;
            if (this.state.originalFontOnHover === null) { this.state.originalFontOnHover = activeLayer.font; }
            activeLayer.font = e.target.dataset.fontValue;
            if (!this.state.movieInteraction.active) this.drawFrame();
        },

        handleFontHoverEnd() {
            const activeLayer = this.getActiveLayer();
            if (this.state.originalFontOnHover && activeLayer && activeLayer.type === 'text') {
                activeLayer.font = this.state.originalFontOnHover;
                this.state.originalFontOnHover = null;
                if (!this.state.movieInteraction.active) this.drawFrame();
            }
        },

        handleFontSelect(e) {
            const activeLayer = this.getActiveLayer();
            const newFontValue = e.target.dataset.fontValue;
            if (activeLayer && activeLayer.type === 'text') { activeLayer.font = newFontValue; }
            this.state.originalFontOnHover = null; 
            this.dom.fontSelectTrigger.querySelector('span').textContent = e.target.textContent;
            this.dom.fontSelectTrigger.querySelector('span').style.fontFamily = newFontValue;
            if (this.dom.fontSelectList.querySelector('.selected')) this.dom.fontSelectList.querySelector('.selected').classList.remove('selected');
            e.target.classList.add('selected');
            this.closeFontDropdown();
            if (!this.state.movieInteraction.active) this.drawFrame();
            this.saveState();
        },

        openFontDropdown() {
            this.dom.customFontSelect.classList.add('open');
            this.dom.fontSelectDropdown.classList.remove('hidden');
            this.state.originalFontOnHover = null;
        },

        closeFontDropdown() {
            if (!this.dom.customFontSelect.classList.contains('open')) return;
            this.handleFontHoverEnd();
            this.dom.customFontSelect.classList.remove('open');
            this.dom.fontSelectDropdown.classList.add('hidden');
        },

        updateTextVisualsUI() {
            const activeLayer = this.getActiveLayer();
            if (activeLayer && activeLayer.type === 'text') {
                this.dom.textVisualsControls.classList.remove('disabled');
                this.dom.textContentInput.value = activeLayer.text;
                this.dom.textSizeSlider.value = activeLayer.fontSize;
                this.dom.textColorInput.value = activeLayer.color;
                this.dom.textEdgeColorInput.value = activeLayer.strokeColor;
                this.dom.textEdgeWidthSlider.value = activeLayer.strokeWidth;
                document.getElementById('text-shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('text-shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('text-shadow-color').value = activeLayer.shadow.color;
                document.getElementById('text-shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('text-shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('text-shadow-offset-y').value = activeLayer.shadow.offsetY;
                const fontName = this.config.availableFonts.find(f => f.value === activeLayer.font)?.name || 'Select Font';
                const fontValue = activeLayer.font;
                this.dom.fontSelectTrigger.querySelector('span').textContent = fontName;
                this.dom.fontSelectTrigger.querySelector('span').style.fontFamily = fontValue;
                if (this.dom.fontSelectList.querySelector('.selected')) this.dom.fontSelectList.querySelector('.selected').classList.remove('selected');
                const liToSelect = this.dom.fontSelectList.querySelector(`[data-font-value="${fontValue}"]`);
                if (liToSelect) liToSelect.classList.add('selected');
            } else {
                this.dom.textVisualsControls.classList.add('disabled');
            }
        },

        updateBackgroundVisualsUI() {
            this.dom.bgBrightnessSlider.value = this.state.canvasState.bgBrightness;
            this.dom.bgSaturationSlider.value = this.state.canvasState.bgSaturation;
        },

        updateEditPanelsUI() {
            this.updateAssetVisualsUI();
            this.updateTextVisualsUI();
            this.updateBackgroundVisualsUI();
            this.updateTextOrderButtonsState();
        },

        addTextLayer() {
            if (!this.state.canvasState.backgroundElement) { this.toast('Add a background first.', 2000); return; }
            const newFontSize = Math.max(20, Math.min(this.dom.movieCanvas.width, this.dom.movieCanvas.height) * 0.15);
            const newTextLayer = { id: (Date.now() + Math.random()).toString(), type: 'text', text: 'New Text', font: "'VT323', monospace", fontSize: newFontSize, color: '#FFFFFF', strokeColor: '#000000', strokeWidth: 0, x: this.dom.movieCanvas.width / 2, y: this.dom.movieCanvas.height / 2, rot: 0, flipX: false, opacity: 1, brightness: 1, saturation: 1, width: 0, height: 0, shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 }, border: { enabled: false, color: '#FFFFFF', width: 4 }, createdAt: Date.now() };
            newTextLayer.propX = newTextLayer.x / this.dom.movieCanvas.width;
            newTextLayer.propY = newTextLayer.y / this.dom.movieCanvas.height;
            newTextLayer.propSize = newTextLayer.fontSize / this.dom.movieCanvas.height;
            this.state.canvasState.layers.unshift(newTextLayer);
            this.state.activeLayerId = newTextLayer.id;
            this.deactivateEraser();
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            this.updateControlsState();
            this.updateEditPanelsUI();
            this.triggerAnimatedRender();
            this.toast('Text layer added!', 2000);
            this.dom.textContentInput.focus();
            this.dom.textContentInput.select();
            this.saveState();
        },

        deleteMovieLayer(layerId) {
            this.state.canvasState.layers = this.state.canvasState.layers.filter(l => l.id !== layerId);
            if (this.state.activeLayerId === layerId) { this.state.activeLayerId = null; this.deactivateEraser(); }
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            this.updateControlsState();
            this.updateEditPanelsUI();
            this.drawFrame();
            this.saveState();
        },
        
        getTextBlockMetrics(ctx, text, font, fontSize) {
            ctx.save();
            ctx.font = `${fontSize}px ${font}`;
            const lines = text.split('\n');
            let maxWidth = 0;
            const metrics = ctx.measureText('Ag'); 
            const singleLineHeight = (metrics.actualBoundingBoxAscent || fontSize * 0.8) + (metrics.actualBoundingBoxDescent || fontSize * 0.2);
            lines.forEach(line => { const lineWidth = ctx.measureText(line).width; if (lineWidth > maxWidth) maxWidth = lineWidth; });
            const totalHeight = lines.length * singleLineHeight;
            ctx.restore();
            return { lines, lineHeight: singleLineHeight, maxWidth, totalHeight };
        },
        
        nudgeLayerZ(layerId, delta) {
            const i = this.state.canvasState.layers.findIndex(l => l.id === layerId);
            if (i === -1) return false;
            const j = i + delta;
            if (j < 0 || j >= this.state.canvasState.layers.length) return false;
            const [item] = this.state.canvasState.layers.splice(i, 1);
            this.state.canvasState.layers.splice(j, 0, item);
            return true;
        },

        drawLayers(ctx, layers, isFinalRender = false) {
             for (let i = layers.length - 1; i >= 0; i--) {
                const l = layers[i];
                ctx.save();
                const age = Date.now() - l.createdAt;
                let animationProgress = 1;
                if (!isFinalRender && age < this.config.FADE_IN_DURATION) { animationProgress = age / this.config.FADE_IN_DURATION; }
                const filters = `brightness(${l.brightness}) saturate(${l.saturation})`;
                const shadow = l.shadow.enabled ? `drop-shadow(${l.shadow.offsetX}px ${l.shadow.offsetY}px ${l.shadow.blur}px ${l.shadow.color})` : '';
                let borderFilters = '';
                if (l.type === 'image' && l.border.enabled && l.border.width > 0) { const w = l.border.width, c = l.border.color; borderFilters = `drop-shadow(${w}px ${w}px 0 ${c}) drop-shadow(-${w}px -${w}px 0 ${c}) drop-shadow(-${w}px ${w}px 0 ${c}) drop-shadow(${w}px -${w}px 0 ${c})`; }
                ctx.filter = `${borderFilters} ${shadow} ${filters}`.trim();
                ctx.globalAlpha = l.opacity * animationProgress;
                ctx.translate(l.x, l.y);
                ctx.rotate(l.rot * Math.PI / 180);
                const scaleFactor = 0.95 + 0.05 * animationProgress;
                if (animationProgress < 1) { ctx.scale(scaleFactor, scaleFactor); }
                if (l.flipX) ctx.scale(-1, 1);
                if (l.type === 'image') {
                    const asset = l.proxyCanvas;
                    const assetWidth = asset.width, assetHeight = asset.height;
                    if (assetWidth > 0) { const dWidth = l.size, dHeight = l.size * (assetHeight / assetWidth); ctx.drawImage(asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight); }
                } else if (l.type === 'text') {
                    ctx.font = `${l.fontSize}px ${l.font}`;
                    ctx.fillStyle = l.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    if (l.strokeWidth > 0) { ctx.strokeStyle = l.strokeColor; ctx.lineWidth = l.strokeWidth; }
                    const metrics = this.getTextBlockMetrics(ctx, l.text, l.font, l.fontSize);
                    if (!isFinalRender) { l.width = metrics.maxWidth; l.height = metrics.totalHeight; }
                    const startY = -metrics.totalHeight / 2 + metrics.lineHeight/2;
                    metrics.lines.forEach((line, index) => {
                        const yPos = startY + (index * metrics.lineHeight);
                        if (l.strokeWidth > 0) ctx.strokeText(line, 0, yPos);
                        ctx.fillText(line, 0, yPos);
                    });
                }
                ctx.restore();
            }
        },

        animationRenderLoop() {
            if (!this.state.isAnimatingRender) return;
            const stillAnimating = this.state.canvasState.layers.some(l => (Date.now() - l.createdAt) < this.config.FADE_IN_DURATION);
            if (stillAnimating) { this.drawFrame(); requestAnimationFrame(() => this.animationRenderLoop()); } 
            else { this.state.isAnimatingRender = false; if (!this.state.movieInteraction.active) { this.drawFrame(); } }
        },

        triggerAnimatedRender() {
            if (this.state.isAnimatingRender || this.state.movieInteraction.active) return;
            this.state.isAnimatingRender = true;
            this.animationRenderLoop();
        },

        drawFrame() {
            if (!this.state.canvasState.backgroundElement) { this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height); return; }
            this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
            this.dom.movieCtx.save();
            this.dom.movieCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
            this.dom.movieCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
            this.dom.movieCtx.restore();
            this.drawLayers(this.dom.movieCtx, this.state.canvasState.layers);
            this.drawControlsOverlay();
        },
        
        startRenderLoop() { 
            if (this.state.animationFrameId) return; 
            const loop = () => { this.drawFrame(); this.state.animationFrameId = requestAnimationFrame(loop); };
            loop(); 
        },
        stopRenderLoop() { cancelAnimationFrame(this.state.animationFrameId); this.state.animationFrameId = null; this.drawFrame(); },

        drawControlsOverlay() {
            const isPasteboard = this.state.isCanvasViewZoomedOut;
            const ctx = isPasteboard ? this.dom.pasteboardCtx : this.dom.controlsCtx;
            const canvas = isPasteboard ? this.dom.pasteboardOverlayCanvas : this.dom.controlsOverlayCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            const activeLayer = this.getActiveLayer();
            const isEraserArmed = this.state.eraserMode !== 'none' && !this.dom.eraseToolDropdown.classList.contains('visible');

            if (activeLayer && !isEraserArmed) {
                ctx.save();
                if (isPasteboard) ctx.translate(this.config.PASTEBOARD_MARGIN, this.config.PASTEBOARD_MARGIN);
                
                const { dWidth, dHeight } = this.getLayerMetrics(activeLayer);
                if (!dWidth || !dHeight) { ctx.restore(); return; }
                
                const scale = this.dom.movieCanvas.getBoundingClientRect().width / this.dom.movieCanvas.width;
                if (scale === 0 || !isFinite(scale)) { ctx.restore(); return; }

                const HANDLE_SCREEN_SIZE = 12, BORDER_SCREEN_WIDTH = 1.5, ROTATION_HANDLE_SCREEN_OFFSET = 26;
                const handleSize = HANDLE_SCREEN_SIZE / scale, lineWidth = BORDER_SCREEN_WIDTH / scale, rotationHandleOffset = ROTATION_HANDLE_SCREEN_OFFSET / scale;
                const ho = handleSize / 2;

                ctx.translate(activeLayer.x, activeLayer.y);
                ctx.rotate(activeLayer.rot * Math.PI / 180);

                let offsetX = 0, offsetY = 0;
                if ((activeLayer.type === 'image' || activeLayer.type === 'rasterized-image') && activeLayer.contentFrame) {
                    const fullWidth = activeLayer.size;
                    const fullHeight = activeLayer.size * (activeLayer.proxyCanvas.height / activeLayer.proxyCanvas.width);
                    const frameScale = fullWidth / activeLayer.proxyCanvas.width;
                    
                    const frameCenterX = (activeLayer.contentFrame.x + activeLayer.contentFrame.width / 2) * frameScale;
                    const frameCenterY = (activeLayer.contentFrame.y + activeLayer.contentFrame.height / 2) * frameScale;
                    
                    offsetX = frameCenterX - (fullWidth / 2);
                    offsetY = frameCenterY - (fullHeight / 2);
                    ctx.translate(offsetX, offsetY);
                }
                
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.strokeStyle = '#00FF00';
                ctx.fillStyle = '#00FF00';
                ctx.lineWidth = lineWidth;
                const halfW = dWidth / 2, halfH = dHeight / 2;
                ctx.strokeRect(-halfW, -halfH, dWidth, dHeight);
                ctx.beginPath(); ctx.arc(-halfW, -halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(halfW, -halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(-halfW, halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(halfW, halfH, ho, 0, 2 * Math.PI); ctx.fill();
                
                const rotHandleY = -halfH - rotationHandleOffset;
                ctx.beginPath(); ctx.moveTo(0, -halfH); ctx.lineTo(0, rotHandleY); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, rotHandleY, ho, 0, 2 * Math.PI); ctx.fill();
                
                ctx.restore();
            }

            if (this.state.eraserMode !== 'none') {
                const canvasPoint = this.getMovieCanvasPoint({clientX: this.state.eraseBrushPos.x + this.dom.movieCanvas.getBoundingClientRect().left, clientY: this.state.eraseBrushPos.y + this.dom.movieCanvas.getBoundingClientRect().top});
                ctx.save();
                if (isPasteboard) ctx.translate(this.config.PASTEBOARD_MARGIN, this.config.PASTEBOARD_MARGIN);
                const brushColor = this.state.eraserMode === 'unerase' ? 'rgba(85, 204, 85, 0.9)' : 'white';
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, this.dom.eraserSizeDropdown.value / 2, 0, 2 * Math.PI);
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, this.dom.eraserSizeDropdown.value / 2, 0, 2 * Math.PI);
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
        },
        
        toggleCanvasZoom() {
            this.state.isCanvasViewZoomedOut = !this.state.isCanvasViewZoomedOut;
            this.dom.canvasPanel.classList.toggle('is-zoomed-out', this.state.isCanvasViewZoomedOut);
            this.dom.toggleViewBtn.textContent = this.state.isCanvasViewZoomedOut ? '⛶' : '⬚';
            this.dom.toggleViewBtn.title = this.state.isCanvasViewZoomedOut ? 'Reset Canvas View (Z)' : 'Zoom Out Canvas (Z)';
            this.dom.movieCanvas.addEventListener('transitionend', () => this.drawFrame(), { once: true });
            requestAnimationFrame(() => { this.resizeCanvas(); });
        },

        downloadImage() {
            if (!this.state.canvasState.backgroundElement) { this.toast("Add a background before downloading.", 3000); return; }
            this.toast("Preparing high-quality image...", null);
            requestAnimationFrame(() => {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.dom.movieCanvas.width;
                    tempCanvas.height = this.dom.movieCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.imageSmoothingQuality = 'high';
                    tempCtx.save();
                    tempCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
                    tempCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.restore();
                    this.drawLayers(tempCtx, this.state.canvasState.layers, true);
                    const link = document.createElement('a');
                    link.download = 'image-maker-creation.png';
                    link.href = tempCanvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    this.toast("Image download started!", 4000);
                } catch (error) {
                    console.error("Download failed:", error);
                    this.toast("Error: Could not generate image. Check console.", 5000);
                }
            }); 
        },

        showEraserZoom(show){ this.dom.eraserZoomCanvas.classList.toggle('visible', show); },
        showEraserHUD(show){ this.dom.eraserHud.classList.toggle('visible', show); },
        
        updateEraserHudState() {
            this.dom.hudEraseBtn.classList.toggle('active', this.state.eraserMode === 'erase');
            this.dom.hudUneraseBtn.classList.toggle('active', this.state.eraserMode === 'unerase');
            this.dom.eraserSizeSlider.value = this.dom.eraserSizeDropdown.value;
            this.dom.eraserStrengthSlider.value = this.dom.eraserStrengthDropdown.value;
        },

        lerp(a,b,t){ return a+(b-a)*Math.min(1,Math.max(0,t)); },
        computeZoomUiSize(brush){ const t=(brush-this.config.BRUSH_MIN)/(this.config.BRUSH_MAX-this.config.BRUSH_MIN); return Math.round(this.lerp(this.config.UI_MIN_PX,this.config.UI_MAX_PX,t)); },

        drawEraserZoomAt(canvasPoint){
          if (!this.state.canvasState.backgroundElement) return;
          const brush = Math.max(5, Number(this.dom.eraserSizeDropdown.value));
          const uiPx = this.computeZoomUiSize(brush);
          if (this.dom.eraserZoomCanvas.width !== uiPx || this.dom.eraserZoomCanvas.height !== uiPx){
            this.dom.eraserZoomCanvas.width = uiPx; this.dom.eraserZoomCanvas.height = uiPx;
            this.dom.eraserZoomCanvas.style.width = uiPx + 'px'; this.dom.eraserZoomCanvas.style.height = uiPx + 'px';
            this.dom.eraserHud.style.bottom = (12 + uiPx + 12) + 'px';
          }
          let targetR = Math.min(this.config.TARGET_RADIUS_PX, uiPx/2 - this.config.MIN_MARGIN_PREVIEW);
          let sw = (brush * uiPx) / (2 * targetR);
          let sh = sw;
          const rect = this.dom.movieCanvas.getBoundingClientRect();
          const mainScale = rect.width / this.dom.movieCanvas.width;
          const factor = uiPx / sw;
          const minFactor = mainScale * this.config.MIN_ZOOM_FEEL;
          if (factor < minFactor){ sw = uiPx / minFactor; sh = sw; }
          sw = Math.min(sw, this.dom.movieCanvas.width);
          sh = Math.min(sh, this.dom.movieCanvas.height);
          let sx = canvasPoint.x - sw / 2;
          let sy = canvasPoint.y - sh / 2;
          sx = Math.max(0, Math.min(this.dom.movieCanvas.width  - sw, sx));
          sy = Math.max(0, Math.min(this.dom.movieCanvas.height - sh, sy));
          this.dom.eraserZoomCtx.clearRect(0,0,uiPx,uiPx);
          this.dom.eraserZoomCtx.imageSmoothingEnabled = true;
          this.dom.eraserZoomCtx.imageSmoothingQuality = 'high';
          this.dom.eraserZoomCtx.drawImage(this.dom.movieCanvas, sx, sy, sw, sh, 0, 0, uiPx, uiPx);
          const scale = uiPx / sw;
          const rZoom = (brush / 2) * scale;
          const cx = (canvasPoint.x - sx) * scale;
          const cy = (canvasPoint.y - sy) * scale;
          this.dom.eraserZoomCtx.save();
          this.dom.eraserZoomCtx.beginPath();
          this.dom.eraserZoomCtx.arc(cx, cy, rZoom, 0, Math.PI*2);
          this.dom.eraserZoomCtx.strokeStyle = (this.state.eraserMode === 'unerase') ? 'rgba(85, 204, 85, 0.9)' : '#ffffff';
          this.dom.eraserZoomCtx.lineWidth = 2;
          this.dom.eraserZoomCtx.stroke();
          this.dom.eraserZoomCtx.setLineDash([5,5]);
          this.dom.eraserZoomCtx.strokeStyle = '#000000';
          this.dom.eraserZoomCtx.lineWidth = 1;
          this.dom.eraserZoomCtx.beginPath();
          this.dom.eraserZoomCtx.arc(cx, cy, rZoom, 0, Math.PI*2);
          this.dom.eraserZoomCtx.stroke();
          this.dom.eraserZoomCtx.restore();
        },

        getMovieCanvasPoint(e) {
            if (this.state.isCanvasViewZoomedOut) {
                const pbRect = this.dom.pasteboardOverlayCanvas.getBoundingClientRect();
                const scale = pbRect.width / this.dom.pasteboardOverlayCanvas.width;
                const xInPb = (e.clientX - pbRect.left) / scale;
                const yInPb = (e.clientY - pbRect.top) / scale;
                return { x: xInPb - this.config.PASTEBOARD_MARGIN, y: yInPb - this.config.PASTEBOARD_MARGIN };
            } else {
                const movieRect = this.dom.movieCanvas.getBoundingClientRect();
                const scaleX = this.dom.movieCanvas.width / movieRect.width;
                const scaleY = this.dom.movieCanvas.height / movieRect.height;
                return { x: (e.clientX - movieRect.left) * scaleX, y: (e.clientY - movieRect.top) * scaleY };
            }
        },
        
        applyBrushToLayer(layer, canvasPoint) {
            if (!layer || layer.type !== 'image' || !layer.proxyCtx) return;
            const dx = canvasPoint.x - layer.x, dy = canvasPoint.y - layer.y;
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            const assetWidth = layer.proxyCanvas.width, assetHeight = layer.proxyCanvas.height;
            const layerRenderWidth = layer.size, layerRenderHeight = layer.size * (assetHeight / assetWidth);
            const proxyX = (localX + layerRenderWidth / 2) * (assetWidth / layerRenderWidth);
            const proxyY = (localY + layerRenderHeight / 2) * (assetHeight / layerRenderHeight);
            const brushSize = this.dom.eraserSizeDropdown.value * (assetWidth / layerRenderWidth);
            const ctx = layer.proxyCtx, lastX = this.state.movieInteraction.lastProxyX, lastY = this.state.movieInteraction.lastProxyY;
            if (this.state.eraserMode === 'erase') {
                ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = brushSize;
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = `rgba(0, 0, 0, ${parseFloat(this.dom.eraserStrengthDropdown.value)})`;
                ctx.beginPath();
                if (lastX !== null && lastY !== null) { ctx.moveTo(lastX, lastY); } 
                else { ctx.moveTo(proxyX - 0.01, proxyY); }
                ctx.lineTo(proxyX, proxyY);
                ctx.stroke();
            } else {
                const strength = parseFloat(this.dom.eraserStrengthDropdown.value), radius = brushSize / 2;
                if (radius <= 0 || strength <= 0) return;
                const processUneraseDab = (x, y) => {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = strength * 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(layer.asset, 0, 0);
                    ctx.restore();
                };
                if (lastX !== null && lastY !== null) {
                    const dist = Math.hypot(proxyX - lastX, proxyY - lastY);
                    const angle = Math.atan2(proxyY - lastY, proxyX - lastX);
                    const step = Math.max(1, radius / 2);
                    for (let i = 0; i < dist; i += step) {
                        const x = lastX + Math.cos(angle) * i;
                        const y = lastY + Math.sin(angle) * i;
                        processUneraseDab(x, y);
                    }
                }
                processUneraseDab(proxyX, proxyY);
            }
            this.state.movieInteraction.lastProxyX = proxyX;
            this.state.movieInteraction.lastProxyY = proxyY;
            this.drawFrame();
            this.state.lastEraseCanvasPoint = canvasPoint;
            if (this.state.movieInteraction.active) { this.drawEraserZoomAt(canvasPoint); }
        },

        // =================================================================
        // ==  DEFINITIVE FIX: getMovieHandleAtPoint =======================
        // =================================================================
        getMovieHandleAtPoint(point, layer) {
            const scale = this.dom.movieCanvas.getBoundingClientRect().width / this.dom.movieCanvas.width;
            if (scale === 0 || !isFinite(scale)) return null;
            const DESIRED_HIT_RADIUS_ON_SCREEN = 16;
            const radius = DESIRED_HIT_RADIUS_ON_SCREEN / scale;
            const { dWidth, dHeight } = this.getLayerMetrics(layer);
            if (!dWidth || !dHeight) return null;

            let offsetX = 0, offsetY = 0;
            if ((layer.type === 'image' || layer.type === 'rasterized-image') && layer.contentFrame) {
                const fullWidth = layer.size;
                const fullHeight = layer.size * (layer.proxyCanvas.height / layer.proxyCanvas.width);
                const frameScale = fullWidth / layer.proxyCanvas.width;
                const frameCenterX = (layer.contentFrame.x + layer.contentFrame.width / 2) * frameScale;
                const frameCenterY = (layer.contentFrame.y + layer.contentFrame.height / 2) * frameScale;
                offsetX = frameCenterX - (fullWidth / 2);
                offsetY = frameCenterY - (fullHeight / 2);
            }
            
            const angle = layer.rot * Math.PI / 180, cos = Math.cos(angle), sin = Math.sin(angle);
            const ROTATION_HANDLE_SCREEN_OFFSET = 26;
            const rotationHandleOffset = ROTATION_HANDLE_SCREEN_OFFSET / scale;
            
            const rotHandleLocalX = 0;
            const rotHandleLocalY = -dHeight / 2 - rotationHandleOffset;
            const rotHandleWorldX = layer.x + ((offsetX + rotHandleLocalX) * cos - (offsetY + rotHandleLocalY) * sin);
            const rotHandleWorldY = layer.y + ((offsetX + rotHandleLocalX) * sin + (offsetY + rotHandleLocalY) * cos);
            if (Math.hypot(point.x - rotHandleWorldX, point.y - rotHandleWorldY) < radius) return 'rotate';
            
            const handles = {
                tl: { x: -dWidth / 2, y: -dHeight / 2 }, tr: { x: dWidth / 2, y: -dHeight / 2 },
                bl: { x: -dWidth / 2, y: dHeight / 2 }, br: { x: dWidth / 2, y: dHeight / 2 }
            };

            for (const name in handles) {
                const h = handles[name];
                const handleWorldX = layer.x + ((offsetX + h.x) * cos - (offsetY + h.y) * sin);
                const handleWorldY = layer.y + ((offsetX + h.x) * sin + (offsetY + h.y) * cos);
                if (Math.hypot(point.x - handleWorldX, point.y - handleWorldY) < radius) return name;
            }
            return null;
        },
        
        handleMovieInteractionStart(e) {
            const dropdowns = [this.dom.visualsDropdown, this.dom.textDropdown, this.dom.shortcutsDropdown, this.dom.eraseToolDropdown, this.dom.aiToolsDropdown, this.dom.customFontSelect];
            for (const dropdown of dropdowns) {
                if (dropdown && dropdown.contains(e.target)) {
                    return;
                }
            }

            const point = this.getMovieCanvasPoint(e);
            const activeLayer = this.getActiveLayer();
            const anyDropdownVisible = dropdowns.some(dd => dd && dd.classList.contains('visible')) || (this.dom.customFontSelect && this.dom.customFontSelect.classList.contains('open'));

            if (this.state.eraserMode !== 'none') {
                e.preventDefault();
                if (!anyDropdownVisible && activeLayer && this.isPointInMovieLayer(point, activeLayer)) {
                    this.state.movieInteraction = { active: true, type: 'erase', layerId: activeLayer.id, lastProxyX: null, lastProxyY: null };
                    this.state.lastEraseCanvasPoint = point;
                    this.showEraserZoom(true);
                    this.showEraserHUD(false);
                    this.drawEraserZoomAt(point);
                    this.applyBrushToLayer(activeLayer, point);
                }
                return;
            }

            e.preventDefault();
            let interactionFound = false;
            const handle = activeLayer ? this.getMovieHandleAtPoint(point, activeLayer) : null;

            if (activeLayer && handle) {
                interactionFound = true;
                this.state.movieInteraction = { active: true, type: handle === 'rotate' ? 'rotate' : 'resize', layerId: activeLayer.id, handle: handle, startX: point.x, startY: point.y, initialState: JSON.parse(JSON.stringify(activeLayer)) };
            } else if (this.isPointInMovieLayer(point, activeLayer)) {
                interactionFound = true;
                this.state.movieInteraction = { active: true, type: 'drag', layerId: activeLayer.id, offsetX: point.x - activeLayer.x, offsetY: point.y - activeLayer.y };
            }

            if (!interactionFound) {
                for (let i = 0; i < this.state.canvasState.layers.length; i++) {
                    const l = this.state.canvasState.layers[i];
                    if (this.isPointInMovieLayer(point, l)) {
                        this.state.activeLayerId = l.id;
                        this.renderLayerPalette(); this.renderTextLayerPalette(); this.updateEditPanelsUI();
                        this.state.movieInteraction = { active: true, type: 'drag', layerId: l.id, offsetX: point.x - l.x, offsetY: point.y - l.y };
                        interactionFound = true;
                        break;
                    }
                }
            }

            if (!interactionFound && this.state.activeLayerId && !anyDropdownVisible) {
                this.state.activeLayerId = null;
                this.updateEditPanelsUI();
                this.renderLayerPalette();
                this.renderTextLayerPalette();
                this.drawFrame();
            }

            if (interactionFound) this.startRenderLoop();
        },
        
        getLayerMetrics(layer) {
            if (!layer) return { dWidth: 0, dHeight: 0 };

            if (layer.type === 'image') {
                if (!layer.contentFrame || !layer.proxyCanvas) return { dWidth: 0, dHeight: 0 };
                const scale = layer.size / layer.proxyCanvas.width;
                const dWidth = layer.contentFrame.width * scale;
                const dHeight = layer.contentFrame.height * scale;
                return { dWidth, dHeight };
            } else if (layer.type === 'text') {
                const metrics = this.getTextBlockMetrics(this.dom.controlsCtx, layer.text, layer.font, layer.fontSize);
                layer.width = metrics.maxWidth;
                layer.height = metrics.totalHeight;
                return { dWidth: metrics.maxWidth, dHeight: metrics.totalHeight };
            }
             if (layer.type === 'image' && layer.asset) {
                const assetWidth  = layer.proxyCanvas?.width  || layer.asset?.naturalWidth  || 0;
                const assetHeight = layer.proxyCanvas?.height || layer.asset?.naturalHeight || 0;
                if (!assetWidth || !assetHeight) return { dWidth: 0, dHeight: 0 };
                return { dWidth: layer.size, dHeight: layer.size * (assetHeight / assetWidth) };
            }
            return { dWidth: 0, dHeight: 0 };
        },

        // =================================================================
        // ==  DEFINITIVE FIX: isPointInMovieLayer =========================
        // =================================================================
        isPointInMovieLayer(point, layer) {
            if (!layer) return false;

            const { dWidth, dHeight } = this.getLayerMetrics(layer);
            if (dWidth === 0) return false;

            const dx = point.x - layer.x;
            const dy = point.y - layer.y;

            let offsetX = 0;
            let offsetY = 0;
            if ((layer.type === 'image' || layer.type === 'rasterized-image') && layer.contentFrame) {
                const fullWidth = layer.size;
                const fullHeight = layer.size * (layer.proxyCanvas.height / layer.proxyCanvas.width);
                const scale = fullWidth / layer.proxyCanvas.width;
                
                const frameCenterX = (layer.contentFrame.x + layer.contentFrame.width / 2) * scale;
                const frameCenterY = (layer.contentFrame.y + layer.contentFrame.height / 2) * scale;
                
                offsetX = frameCenterX - (fullWidth / 2);
                offsetY = frameCenterY - (fullHeight / 2);
            }
            
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);

            return (
                Math.abs(localX - offsetX) < dWidth / 2 &&
                Math.abs(localY - offsetY) < dHeight / 2
            );
        },

        handleMovieInteractionMove(e) {
            const point = this.getMovieCanvasPoint(e);
            this.state.eraseBrushPos = { x: e.clientX - this.dom.movieCanvas.getBoundingClientRect().left, y: e.clientY - this.dom.movieCanvas.getBoundingClientRect().top };
            if (!this.state.movieInteraction.active) {
                this.updateCursor(e);
                if (this.state.eraserMode !== 'none') {
                    this.drawControlsOverlay();
                    if (this.dom.eraseToolDropdown.classList.contains('is-scrubbing')) {
                        this.drawEraserZoomAt(point);
                    }
                }
                return;
            }
            e.preventDefault();
            const l = this.getActiveLayer();
            if (!l) return;
            if (this.state.movieInteraction.type === 'erase') { this.applyBrushToLayer(l, point); this.drawEraserZoomAt(point); return; }
            if (this.state.movieInteraction.type === 'drag') {
                l.x = point.x - this.state.movieInteraction.offsetX;
                l.y = point.y - this.state.movieInteraction.offsetY;
                l.propX = l.x / this.dom.movieCanvas.width;
                l.propY = l.y / this.dom.movieCanvas.height;
            } 
            else if (this.state.movieInteraction.type === 'rotate') {
                const iState = this.state.movieInteraction.initialState;
                const initialAngle = Math.atan2(this.state.movieInteraction.startY - iState.y, this.state.movieInteraction.startX - iState.x) * 180 / Math.PI;
                const currentAngle = Math.atan2(point.y - iState.y, point.x - iState.x) * 180 / Math.PI;
                l.rot = iState.rot + (currentAngle - initialAngle);
            } else if (this.state.movieInteraction.type === 'resize') {
                const iState = this.state.movieInteraction.initialState;
                const initialDist = Math.hypot(this.state.movieInteraction.startX - iState.x, this.state.movieInteraction.startY - iState.y);
                const currentDist = Math.hypot(point.x - iState.x, point.y - iState.y);
                if (initialDist > 1) {
                    const scaleFactor = currentDist / initialDist;
                    if (l.type === 'text') {
                        l.fontSize = Math.max(10, iState.fontSize * scaleFactor);
                        l.propSize = l.fontSize / this.dom.movieCanvas.height;
                        this.dom.textSizeSlider.value = l.fontSize;
                    } 
                    else {
                        l.size = Math.max(20, iState.size * scaleFactor);
                        l.propSize = l.size / this.dom.movieCanvas.width;
                    }
                }
            }
        },

        handleMovieInteractionEnd(e) {
          if (this.state.movieInteraction.active) {
            const wasErasing = this.state.movieInteraction.type === 'erase';
            const wasTransforming = ['drag', 'rotate', 'resize'].includes(this.state.movieInteraction.type);
            this.state.movieInteraction.active = false;
            this.showEraserZoom(false);
            if (wasErasing) { 
                this.renderLayerPalette(); 
                this.showEraserHUD(true);
            }
            this.stopRenderLoop();
            
            if (wasErasing) {
                this.saveStateDebounced();
            } else if (wasTransforming) {
                this.saveState();
            }
          }
        },

        updateCursor(e) {
            if (this.state.eraserMode !== 'none') {
                this.dom.movieCanvas.style.cursor = 'none';
                this.dom.pasteboardOverlayCanvas.style.cursor = 'none';
                return;
            }
            this.dom.movieCanvas.style.cursor = '';
            this.dom.pasteboardOverlayCanvas.style.cursor = '';
            const point = this.getMovieCanvasPoint(e);
            let newCursor = 'default';
            const activeLayer = this.getActiveLayer();
            if (activeLayer) {
                const handle = this.getMovieHandleAtPoint(point, activeLayer);
                if (handle) {
                    newCursor = handle === 'rotate' ? 'grab' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize');
                } else if (this.isPointInMovieLayer(point, activeLayer)) {
                    newCursor = 'move';
                }
            } else {
                 for (let i = 0; i < this.state.canvasState.layers.length; i++) {
                    if (this.isPointInMovieLayer(point, this.state.canvasState.layers[i])) {
                        newCursor = 'pointer';
                        break;
                    }
                }
            }
            if (this.state.isCanvasViewZoomedOut) { this.dom.pasteboardOverlayCanvas.style.cursor = newCursor; }
            else { this.dom.movieCanvas.style.cursor = newCursor; }
        },

        handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') { if (key === 'escape') document.activeElement.blur(); return; }
            
            if ((e.metaKey || e.ctrlKey) && key === 'z') { e.preventDefault(); this.undo(); return; }
            if ((e.metaKey || e.ctrlKey) && (key === 'y' || (e.shiftKey && key === 'z'))) { e.preventDefault(); this.redo(); return; }


            if ((e.metaKey || e.ctrlKey) && key === 's') { e.preventDefault(); if (!this.dom.saveProjectBtn.disabled) this.saveProjectToLibrary(); return; }
            if (key === 'z' && !(e.metaKey || e.ctrlKey)) { e.preventDefault(); this.toggleCanvasZoom(); return; }
            if (key === 'escape' && this.state.eraserMode !== 'none') { e.preventDefault(); this.deactivateEraser(); return; }
            const activeLayer = this.getActiveLayer();
            if (!activeLayer) return;
            if (key === 'q' || key === 'w') {
                e.preventDefault();
                const moved = this.nudgeLayerZ(activeLayer.id, key === 'q' ? -1 : +1);
                if (moved) { this.renderLayerPalette(); this.renderTextLayerPalette(); if(this.updateTextOrderButtonsState) this.updateTextOrderButtonsState(); this.drawFrame(); this.saveState(); }
                return;
            }
            let stateChanged = false;
            if (key === 'd' || key === 'f') {
                e.preventDefault();
                const scaleFactor = key === 'd' ? 1.05 : 0.95;
                if (activeLayer.type === 'image') {
                    activeLayer.size *= scaleFactor;
                    activeLayer.propSize = activeLayer.size / this.dom.movieCanvas.width;
                } else if (activeLayer.type === 'text') {
                    activeLayer.fontSize *= scaleFactor;
                    activeLayer.propSize = activeLayer.fontSize / this.dom.movieCanvas.height;
                    this.dom.textSizeSlider.value = activeLayer.fontSize;
                }
                 stateChanged = true;
            }
            else if (key === 's' && !(e.metaKey || e.ctrlKey)) { e.preventDefault(); activeLayer.flipX = !activeLayer.flipX; stateChanged = true; } 
            else if (key === 'delete' || key === 'backspace') { e.preventDefault(); this.deleteMovieLayer(activeLayer.id); this.toast('Layer deleted', 2000); return; }

            if (stateChanged) {
                this.drawFrame();
                this.saveStateDebounced();
            }
        },

        clearCanvas(isSoft = false) {
            this.state.canvasState = { currentProjectId: null, backgroundElement: null, backgroundType: 'none', backgroundHash: null, bgBrightness: 1, bgSaturation: 1, layers: [] };
            this.state.activeLayerId = null;
            this.deactivateEraser();
            this.dom.movieCtx.clearRect(0, 0, this.dom.movieCanvas.width, this.dom.movieCanvas.height);
            this.dom.controlsCtx.clearRect(0, 0, this.dom.controlsOverlayCanvas.width, this.dom.controlsOverlayCanvas.height);
            this.dom.canvasPlaceholder.classList.remove('hidden');
            localStorage.removeItem('ims-autosave-project');
            this.updateControlsState();
            this.updateEditPanelsUI();
            this.drawFrame();
            if (!isSoft) {
                this.toast("Canvas cleared. Saved projects are safe.", 2000);
                this.state.history = [];
                this.state.historyIndex = -1;
                this.saveState();
            }
        },

               deactivateEraser(shouldCloseDropdown = false) {
            if (this.state.eraserMode === 'none') return;
            this.state.eraserMode = 'none';
            this.state.isEraserArmed = false;
            this.showEraserHUD(false);
            this.showEraserZoom(false);
            document.getElementById('eraser-controls-wrapper').classList.add('disabled');
            this.dom.eraseBtn.classList.remove('active');
            this.dom.uneraseBtn.classList.remove('active');
            this.dom.eraseToolBtn.classList.remove('active');
            this.dom.movieCanvas.classList.remove('erase-cursor');
            this.hideToast();
            this.drawFrame();

            if (shouldCloseDropdown) {
                this.dom.eraseToolDropdown.classList.remove('visible');
            }
        },

              toggleDropdownEraserMode(mode) {
            const activeLayer = this.getActiveLayer();
            if (!activeLayer || activeLayer.type !== 'image') {
                this.toast('Select an image layer to use the eraser.', 3000);
                return;
            }

            if (this.state.eraserMode === mode) {
                this.deactivateEraser();
                return;
            }

            this.state.eraserMode = mode;
            this.state.isEraserArmed = false;
            this.dom.movieCanvas.classList.add('erase-cursor');
            this.dom.eraseBtn.classList.toggle('active', mode === 'erase');
            this.dom.uneraseBtn.classList.toggle('active', mode === 'unerase');
            this.dom.eraseToolBtn.classList.add('active');
            document.getElementById('eraser-controls-wrapper').classList.remove('disabled');
            this.drawFrame();
        },
        
        armEraser() {
            if (this.state.eraserMode === 'none' || this.state.isEraserArmed) return;
            this.state.isEraserArmed = true;
            this.dom.eraseToolDropdown.classList.remove('visible');
            this.showEraserHUD(true);
            this.updateEraserHudState();
            this.dom.movieCanvas.classList.add('erase-cursor');
            this.toast(`${this.state.eraserMode === 'erase' ? 'Erase' : 'Unerase'} Mode Armed. Click to use.`, 2500);
            this.drawFrame();
        },

        armEraserFromHUD(mode) {
             if (this.state.eraserMode !== mode) { this.state.eraserMode = mode; this.updateEraserHudState(); }
             this.state.isEraserArmed = true;
             this.toast(`${this.state.eraserMode === 'erase' ? 'Erase' : 'Unerase'} Mode Activated`, 1500);
        },

        openConfirmationModal(text, onConfirm) { this.dom.confirmationText.textContent = text; this.state.confirmCallback = onConfirm; this.dom.confirmationOverlay.classList.add('visible'); },
        closeConfirmationModal() { this.dom.confirmationOverlay.classList.remove('visible'); this.state.confirmCallback = null; },

        updateTextOrderButtonsState() {
            const textMoveBackBtn = document.getElementById('text-move-back');
            const textMoveForwardBtn = document.getElementById('text-move-forward');
            if (!textMoveBackBtn || !textMoveForwardBtn) return;
            const l = this.getActiveLayer();
            if (!l || l.type !== 'text') { textMoveBackBtn.disabled = true; textMoveForwardBtn.disabled = true; return; }
            const idx = this.state.canvasState.layers.findIndex(x => x.id === l.id);
            textMoveForwardBtn.disabled = (idx === 0);
            textMoveBackBtn.disabled = (idx === this.state.canvasState.layers.length - 1);
        },
        
        async getBgSession(mode) {
            if (this.state.bgSessionCache.has(mode)) return this.state.bgSessionCache.get(mode);
            const url = this.config.BG_MODELS[mode] || this.config.BG_MODELS.fast;
            const modelName = mode.charAt(0).toUpperCase() + mode.slice(1);
            this.toast(`Loading ${modelName} model`, null);
            try {
                const resp = await fetch(url, { mode: 'cors', cache: 'force-cache' });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const bytes = await resp.arrayBuffer();
                const session = await ort.InferenceSession.create(bytes, {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all',
                });
                this.state.bgSessionCache.set(mode, session);
                this.hideToast();
                return session;
            } catch (e) {
                this.hideToast();
                console.error(`Failed to load '${mode}' model from ${url}. Error: ${e.message}`);
                this.toast('Critical: Background removal model failed to load.', 5000);
                throw new Error("Could not load the background removal model.");
            }
        },

        rgbaToCHWFloat32(imgData, size = 320) {
            const { data } = imgData;
            const chw = new Float32Array(3 * size * size);
            let p = 0, rOff = 0, gOff = size * size, bOff = 2 * size * size;
            for (let i = 0; i < data.length; i += 4) {
                chw[rOff + p] = data[i] / 255;
                chw[gOff + p] = data[i + 1] / 255;
                chw[bOff + p] = data[i + 2] / 255;
                p++;
            }
            return chw;
        },

        letterboxToSquareBitmap(imgBitmap, size = 320) {
            const canvas = new OffscreenCanvas(size, size);
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            const scale = Math.min(size / imgBitmap.width, size / imgBitmap.height);
            const dw = Math.round(imgBitmap.width * scale), dh = Math.round(imgBitmap.height * scale);
            const dx = Math.floor((size - dw) / 2), dy = Math.floor((size - dh) / 2);
            ctx.clearRect(0, 0, size, size);
            ctx.drawImage(imgBitmap, 0, 0, imgBitmap.width, imgBitmap.height, dx, dy, dw, dh);
            return { canvas, dx, dy, dw, dh };
        },
        
        async runU2NetOnImageLayer(layer, session) {
            const bmp = await createImageBitmap(layer.asset);
            const side = 320;
            const boxed = this.letterboxToSquareBitmap(bmp, side);
            const pctx = boxed.canvas.getContext('2d', { willReadFrequently: true });
            const imgData = pctx.getImageData(0, 0, side, side);
            const chw = this.rgbaToCHWFloat32(imgData, side);
            const input = new ort.Tensor('float32', chw, [1, 3, side, side]);
            const feeds = { [session.inputNames[0]]: input };
            const results = await session.run(feeds);
            const out = results[session.outputNames[0]].data;
            const maskCanvas = new OffscreenCanvas(side, side);
            const mctx = maskCanvas.getContext('2d');
            const mImg = mctx.createImageData(side, side);
            for (let i = 0; i < out.length; i++) {
                const a = Math.max(0, Math.min(1, out[i]));
                const j = i * 4;
                mImg.data[j] = mImg.data[j+1] = mImg.data[j+2] = 255;
                mImg.data[j+3] = Math.round(a * 255);
            }
            mctx.putImageData(mImg, 0, 0);
            this.featherMask(maskCanvas, 1.2);
            const maskBitmap = await createImageBitmap(maskCanvas);
            const proxy = layer.proxyCanvas, ctx = layer.proxyCtx;
            ctx.clearRect(0,0,proxy.width,proxy.height);
            ctx.drawImage(layer.asset, 0, 0);
            const maskFull = this.upscaleMaskToLayer(maskBitmap, boxed, proxy.width, proxy.height);
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(maskFull, 0, 0);
            ctx.restore();
        },

        async removeBgForActiveImageLayer() {
            if (this.dom.aiToolsDropdown) this.dom.aiToolsDropdown.classList.remove('visible');
            const active = this.getActiveLayer();
            if (!active || active.type !== 'image') { this.toast('Select an image layer first.', 2500); return; }
            const mode = 'fast';
            try {
                const session = await this.getBgSession(mode);
                if (!session) return; 
                this.toast(`Removing background`, null);
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.runU2NetOnImageLayer(active, session);
                this.toast(`Background removed.`, 2500);
                if(this.renderLayerPalette) this.renderLayerPalette();
                if(this.drawFrame) this.drawFrame();
                this.saveState();
            } catch (err) {
                console.error(err);
                this.hideToast();
                this.toast('BG removal failed. See console.', 4000);
            }
        },
        
        upscaleMaskToLayer(maskBitmap, boxed, layerWidth, layerHeight) {
            const { dx, dy, dw, dh } = boxed;
            const tempMaskCanvas = new OffscreenCanvas(maskBitmap.width, maskBitmap.height);
            tempMaskCanvas.getContext('2d').drawImage(maskBitmap, 0, 0);
            const croppedMaskCanvas = new OffscreenCanvas(dw, dh);
            croppedMaskCanvas.getContext('2d').drawImage(tempMaskCanvas, dx, dy, dw, dh, 0, 0, dw, dh);
            const finalMaskCanvas = new OffscreenCanvas(layerWidth, layerHeight);
            const finalCtx = finalMaskCanvas.getContext('2d');
            finalCtx.imageSmoothingEnabled = true;
            finalCtx.imageSmoothingQuality = 'high';
            finalCtx.drawImage(croppedMaskCanvas, 0, 0, dw, dh, 0, 0, layerWidth, layerHeight);
            return finalMaskCanvas;
        },

        featherMask(canvas, amount = 1.2) {
            const ctx = canvas.getContext('2d');
            if (amount > 0) {
                ctx.filter = `blur(${amount}px)`;
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }
        },
        
        async getSavableState() {
            const savableState = {
                currentProjectId: this.state.canvasState.currentProjectId,
                bgBrightness: this.state.canvasState.bgBrightness,
                bgSaturation: this.state.canvasState.bgSaturation,
                backgroundHash: this.state.canvasState.backgroundHash,
                layers: []
            };
            for (const layer of this.state.canvasState.layers) {
                if (layer.type === 'image') {
                    const { asset, proxyCanvas, proxyCtx, ...serializableLayer } = layer;
                    serializableLayer.proxyCanvasDataURL = proxyCanvas.toDataURL();
                    savableState.layers.push(serializableLayer);
                } else if (layer.type === 'text') {
                    savableState.layers.push({ ...layer });
                }
            }
            return savableState;
        },

        async saveCurrentWork() {
            if (!this.state.canvasState.backgroundElement) return;
            try {
                const state = await this.getSavableState();
                localStorage.setItem('ims-autosave-project', JSON.stringify(state));
            } catch (e) {
                console.warn("Failed to autosave project:", e);
            }
        },

        async saveProjectToLibrary() {
            if (!this.state.canvasState.backgroundElement) { this.toast("A background is required to save a project.", 3000); return; }
            this.toast("Saving project to library...", null);
            const thumbCanvas = document.createElement('canvas');
            const THUMB_MAX_SIZE = 256;
            const aspect = this.dom.movieCanvas.width / this.dom.movieCanvas.height;
            thumbCanvas.width = aspect >= 1 ? THUMB_MAX_SIZE : THUMB_MAX_SIZE * aspect;
            thumbCanvas.height = aspect < 1 ? THUMB_MAX_SIZE : THUMB_MAX_SIZE / aspect;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.imageSmoothingQuality = 'high';
            thumbCtx.filter = `brightness(${this.state.canvasState.bgBrightness}) saturate(${this.state.canvasState.bgSaturation})`;
            thumbCtx.drawImage(this.state.canvasState.backgroundElement, 0, 0, thumbCanvas.width, thumbCanvas.height);
            thumbCtx.filter = 'none';
            thumbCtx.save();
            thumbCtx.scale(thumbCanvas.width / this.dom.movieCanvas.width, thumbCanvas.height / this.dom.movieCanvas.height);
            this.drawLayers(thumbCtx, this.state.canvasState.layers, true);
            thumbCtx.restore();
            const thumbnailBlob = await new Promise(resolve => thumbCanvas.toBlob(resolve, 'image/webp', 0.8));
            const projectState = await this.getSavableState();
            const record = { createdAt: Date.now(), thumbnail: thumbnailBlob, projectState };
            let toastMessage = "Project saved to library!";
            if (this.state.canvasState.currentProjectId) { record.id = this.state.canvasState.currentProjectId; toastMessage = "Project updated in library!"; }
            const savedRecord = await this.idbPut(record, 'projects');
            this.state.canvasState.currentProjectId = savedRecord.id;
            await this.saveCurrentWork();
            this.toast(toastMessage, 2500);
        },

        async createLayerFromSave(savedLayer) {
            if (savedLayer.type === 'text') {
                return { ...savedLayer, createdAt: Date.now() };
            }
            if (savedLayer.type === 'image') {
                try {
                    const assetRecords = await this.idbFindByHash(savedLayer.hash);
                    if (!assetRecords || assetRecords.length === 0) { throw new Error(`Asset with hash ${savedLayer.hash} not in library.`); }
                    const asset = new Image();
                    asset.src = URL.createObjectURL(assetRecords[0].full);
                    const proxyImage = new Image();
                    proxyImage.src = savedLayer.proxyCanvasDataURL;
                    await Promise.all([asset.decode(), proxyImage.decode()]);
                    const proxyCanvas = document.createElement('canvas');
                    proxyCanvas.width = proxyImage.naturalWidth;
                    proxyCanvas.height = proxyImage.naturalHeight;
                    const proxyCtx = proxyCanvas.getContext('2d');
                    proxyCtx.drawImage(proxyImage, 0, 0);
                    
                    const restoredLayer = { ...savedLayer, asset, proxyCanvas, proxyCtx, createdAt: Date.now() };
                    
                    if (!restoredLayer.contentFrame) {
                        restoredLayer.contentFrame = this.calculateContentBounds(proxyCanvas);
                    }

                    delete restoredLayer.proxyCanvasDataURL;
                    return restoredLayer;
                } catch (error) {
                    console.error("Error restoring image layer:", error);
                    this.toast(`Skipping a layer: ${error.message}`, 3500);
                    return null;
                }
            }
            return null;
        },

        async restoreProjectState(projectState) {
            const textLayers = projectState.layers.filter(l => l.type === 'text' && l.font);
            const uniqueFontValues = [...new Set(textLayers.map(l => l.font))];
            const fontNamesToLoad = uniqueFontValues.map(value => this.config.fontValueToNameMap.get(value)).filter(name => name && name !== 'VT323');
            await this.loadSpecificFonts(fontNamesToLoad);
            if (!projectState.backgroundHash) { throw new Error("Saved project is missing a background."); }
            const bgAssets = await this.idbFindByHash(projectState.backgroundHash);
            if (!bgAssets || bgAssets.length === 0) { throw new Error("Background asset for saved project not found in library."); }
            const img = new Image();
            img.src = URL.createObjectURL(bgAssets[0].full);
            await img.decode();
            this.clearCanvas(true);
            this.setBackground(img, projectState.backgroundHash, true);
            this.state.canvasState.bgBrightness = projectState.bgBrightness || 1;
            this.state.canvasState.bgSaturation = projectState.bgSaturation || 1;
            this.state.canvasState.currentProjectId = projectState.currentProjectId || null;
            const layerPromises = projectState.layers.map(l => this.createLayerFromSave(l));
            const loadedLayers = await Promise.all(layerPromises);
            this.state.canvasState.layers = loadedLayers.filter(l => l !== null);
            this.updateControlsState();
            this.updateEditPanelsUI();
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            this.drawFrame();
            await this.saveCurrentWork();
            this.state.history = [];
            this.state.historyIndex = -1;
            this.saveState();
        },
        
        async restoreCurrentWork() {
            const savedData = localStorage.getItem('ims-autosave-project');
            if (!savedData) { this.saveState(); return; } 
            try {
                const projectState = JSON.parse(savedData);
                this.toast("Restoring previous work...", null);
                await this.restoreProjectState(projectState);
                this.toast("Work restored!", 2000);
            } catch (error) {
                console.error("Failed to restore project:", error);
                this.toast(`Could not restore work: ${error.message}`, 4000);
                localStorage.removeItem('ims-autosave-project');
                this.saveState();
            }
        },

        debounce(func, delay) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        },

        saveStateDebounced: null, 

        saveState() {
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.history = this.state.history.slice(0, this.state.historyIndex + 1);
            }

            const snapshot = {
                ...this.state.canvasState,
                layers: this.state.canvasState.layers.map(layer => {
                    const { asset, proxyCanvas, proxyCtx, ...leanLayer } = layer;
                    if (layer.type === 'image' && proxyCanvas) {
                        leanLayer.proxyCanvasDataURL = proxyCanvas.toDataURL();
                    }
                    return leanLayer;
                }),
                backgroundElement: null
            };
            
            this.state.history.push(snapshot);

            if (this.state.history.length > this.config.HISTORY_LIMIT) {
                this.state.history.shift();
            }
            
            this.state.historyIndex = this.state.history.length - 1;
        },

        async applyState(stateToApply) {
            for (const layer of stateToApply.layers) {
                if (layer.type === 'image' && layer.proxyCanvasDataURL) {
                    const img = new Image();
                    img.src = layer.proxyCanvasDataURL;
                    await img.decode();
                    const proxyCanvas = document.createElement('canvas');
                    proxyCanvas.width = img.width;
                    proxyCanvas.height = img.height;
                    const proxyCtx = proxyCanvas.getContext('2d');
                    proxyCtx.drawImage(img, 0, 0);
                    layer.proxyCanvas = proxyCanvas;
                    layer.proxyCtx = proxyCtx;
                }
            }

            stateToApply.backgroundElement = this.state.canvasState.backgroundElement;
            this.state.canvasState = stateToApply;

            this.updateEditPanelsUI();
            this.renderLayerPalette();
            this.renderTextLayerPalette();
            this.drawFrame();
        },

        undo() {
            if (this.state.historyIndex > 0) {
                this.state.historyIndex--;
                const stateToRestore = JSON.parse(JSON.stringify(this.state.history[this.state.historyIndex]));
                this.applyState(stateToRestore);
                this.toast('Undo', 1500);
            } else {
                this.toast("Nothing more to undo", 2000);
            }
        },

        redo() {
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.historyIndex++;
                const stateToRestore = JSON.parse(JSON.stringify(this.state.history[this.state.historyIndex]));
                this.applyState(stateToRestore);
                this.toast('Redo', 1500);
            } else {
                this.toast("Nothing more to redo", 2000);
            }
        },

        addBgUI() {
            const panel = this.dom.aiToolsDropdown;
            if (!panel) return;
            panel.innerHTML = `<h5>Background Remover</h5>`;
            const btn = document.createElement('button');
            btn.className = 'mg-btn';
            btn.textContent = 'Remove Background';
            btn.style.marginTop = '0.5rem';
            btn.addEventListener('click', () => this.removeBgForActiveImageLayer());
            panel.appendChild(btn);
        },

        setupEventListeners() {
            const versionLink = document.getElementById('version-link'), versionPopupOverlay = document.getElementById('version-popup-overlay'), closeButton = document.getElementById('close-popup');
            versionLink.addEventListener('click', (e) => { e.preventDefault(); versionPopupOverlay.style.display = 'flex'; });
            closeButton.addEventListener('click', () => { versionPopupOverlay.style.display = 'none'; });
            versionPopupOverlay.addEventListener('click', (e) => { if (e.target === versionPopupOverlay) versionPopupOverlay.style.display = 'none'; });
            this.dom.themeSelectLink.addEventListener('click', (e) => { e.preventDefault(); this.state.themeChosen = false; this.dom.themePopupOverlay.style.display = 'flex'; });
            this.dom.themePopupContent.addEventListener('mouseleave', () => { if (!this.state.themeChosen) this.applyTheme(this.state.originalTheme, true); });
            this.dom.themePopupOverlay.addEventListener('click', (e) => { if (e.target === this.dom.themePopupOverlay) { if (!this.state.themeChosen) this.applyTheme(this.state.originalTheme); this.dom.themePopupOverlay.style.display = 'none'; } });
            this.dom.canvasPlaceholder.addEventListener('click', () => this.dom.initialBackgroundInput.click());
            this.dom.initialBackgroundInput.addEventListener('change', e => { this.handleBackgroundUpload(e.target.files[0]); e.target.value = null; });
            this.dom.downloadImageBtn.addEventListener('click', () => this.downloadImage());
            this.dom.saveProjectBtn.addEventListener('click', () => this.saveProjectToLibrary());
            this.dom.clearCanvasBtn.addEventListener('click', () => this.openConfirmationModal("This will clear the canvas and start a new project. Are you sure?", () => { this.clearCanvas(); this.closeConfirmationModal(); }));
            const addLayerCloseBtn = document.getElementById('mg-asset-library-close'), dropZone = document.getElementById('mg-asset-drop-zone');
            addLayerCloseBtn.addEventListener('click', () => this.closeAddLayerPopup());
            this.dom.addLayerOverlay.addEventListener('click', e => { if (e.target === this.dom.addLayerOverlay) this.closeAddLayerPopup() });
            dropZone.addEventListener('click', () => this.dom.addLayerFileInput.click());
            this.dom.addLayerFileInput.addEventListener('change', e => { this.processUploadedFile(e.target.files?.[0]); e.target.value = null; });
            dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag-over'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
            dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) { this.processUploadedFile(file); } });
            this.dom.textBtn.addEventListener('click', e => { this.loadSecondaryFonts(); e.stopPropagation(); this.deactivateEraser(true); this.dom.textDropdown.classList.toggle('visible'); this.dom.visualsDropdown.classList.remove('visible'); this.dom.shortcutsDropdown.classList.remove('visible'); this.dom.eraseToolDropdown.classList.remove('visible'); this.dom.aiToolsDropdown.classList.remove('visible'); this.closeFontDropdown(); });
            this.dom.aiToolsBtn.addEventListener('click', e => { e.stopPropagation(); this.deactivateEraser(true); this.dom.aiToolsDropdown.classList.toggle('visible'); this.dom.visualsDropdown.classList.remove('visible'); this.dom.shortcutsDropdown.classList.remove('visible'); this.dom.eraseToolDropdown.classList.remove('visible'); this.dom.textDropdown.classList.remove('visible'); this.closeFontDropdown(); });
            this.dom.addNewTextLayerBtn.addEventListener('click', () => this.addTextLayer());
            this.dom.confirmYesBtn.addEventListener('click', async (e) => { e.stopPropagation(); const fn = this.state.confirmCallback; this.state.confirmCallback = null; try { if (typeof fn === 'function') await fn(); } catch (err) { console.error('Confirmation action failed:', err); this.toast('Error: Could not complete the action.', 4000); } finally { this.closeConfirmationModal(); } });
            this.dom.confirmNoBtn.addEventListener('click', (e) => { e.stopPropagation(); this.closeConfirmationModal(); });
            this.dom.confirmationOverlay.addEventListener('click', (e) => { if (e.target === this.dom.confirmationOverlay) this.closeConfirmationModal(); });
            this.dom.canvasPanel.addEventListener('mousedown', (e) => this.handleMovieInteractionStart(e));
            window.addEventListener('mousemove', (e) => this.handleMovieInteractionMove(e));
            this.dom.canvasPanel.addEventListener('mouseleave', () => { if (!this.state.movieInteraction.active) { this.dom.movieCanvas.style.cursor = 'default'; this.dom.pasteboardOverlayCanvas.style.cursor = 'default'; } this.state.eraseBrushPos = {x: -1000, y: -1000}; if(this.state.eraserMode !== 'none') { this.drawControlsOverlay(); } });
            window.addEventListener('keydown', (e) => this.handleKeyDown(e));
            window.addEventListener('beforeunload', () => this.saveCurrentWork());
            this.dom.canvasPanel.addEventListener('dragover', e => { e.preventDefault(); this.dom.canvasPanel.classList.add('drag-over') });
            this.dom.canvasPanel.addEventListener('dragleave', () => this.dom.canvasPanel.classList.remove('drag-over'));
            this.dom.canvasPanel.addEventListener('drop', e => { e.preventDefault(); this.dom.canvasPanel.classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) { if (!this.state.canvasState.backgroundElement) this.handleBackgroundUpload(file); else this.processUploadedFile(file); } });
            window.addEventListener('paste', e => {
                const items = e.clipboardData?.items;
                if (!items) return;
                let imageFile = null;
                for (let i = 0; i < items.length; i++) { if (items[i].type.indexOf('image') !== -1) { imageFile = items[i].getAsFile(); break; } }
                if (imageFile) {
                    e.preventDefault();
                    if (this.dom.addLayerOverlay.classList.contains('visible')) { this.processUploadedFile(imageFile); } 
                    else if (!this.state.canvasState.backgroundElement) { this.handleBackgroundUpload(imageFile); } 
                    else { this.processUploadedFile(imageFile); }
                }
            });
            this.dom.shortcutsBtn.addEventListener('click', e => { e.stopPropagation(); this.deactivateEraser(true); this.dom.shortcutsDropdown.classList.toggle('visible'); this.dom.visualsDropdown.classList.remove('visible'); this.dom.textDropdown.classList.remove('visible'); this.dom.eraseToolDropdown.classList.remove('visible'); this.dom.aiToolsDropdown.classList.remove('visible'); this.closeFontDropdown();});
            this.dom.visualsBtn.addEventListener('click', e => { e.stopPropagation(); this.deactivateEraser(true); this.dom.visualsDropdown.classList.toggle('visible'); if (this.dom.visualsDropdown.classList.contains('visible')) { if (this.getActiveLayer() && this.getActiveLayer().type === 'image') { this.switchVisualsTab('asset'); } else { this.switchVisualsTab('background'); } } this.dom.shortcutsDropdown.classList.remove('visible'); this.dom.textDropdown.classList.remove('visible'); this.dom.eraseToolDropdown.classList.remove('visible'); this.dom.aiToolsDropdown.classList.remove('visible'); this.closeFontDropdown(); });
            this.dom.visualsTabAssetBtn.addEventListener('click', () => { this.switchVisualsTab('asset'); if (!this.getActiveLayer() || this.getActiveLayer().type !== 'image') { this.toast('Select an image layer to enable asset editing.', 3000); } });
            this.dom.visualsTabBackgroundBtn.addEventListener('click', () => this.switchVisualsTab('background'));
            this.dom.eraseToolBtn.addEventListener('click', e => {
                e.stopPropagation();
                const isDropdownVisible = this.dom.eraseToolDropdown.classList.contains('visible');
                if (this.state.isEraserArmed) {
                    this.deactivateEraser(true);
                }
                else if (isDropdownVisible) {
                    if (this.state.eraserMode !== 'none') {
                        this.state.isEraserArmed = true;
                        this.showEraserHUD(true);
                        this.updateEraserHudState();
                        this.dom.movieCanvas.classList.add('erase-cursor');
                        this.toast(`${this.state.eraserMode === 'erase' ? 'Erase' : 'Unerase'} Mode Armed`, 2000);
                    }
                    this.dom.eraseToolDropdown.classList.remove('visible');
                    this.drawFrame();
                }
                else {
                    this.deactivateEraser();
                    this.dom.eraseToolDropdown.classList.add('visible');
                    this.dom.shortcutsDropdown.classList.remove('visible');
                    this.dom.visualsDropdown.classList.remove('visible');
                    this.dom.textDropdown.classList.remove('visible');
                    this.dom.aiToolsDropdown.classList.remove('visible');
                    this.closeFontDropdown();
                }
            });
            this.dom.fontSelectTrigger.addEventListener('click', (e) => { e.stopPropagation(); if (this.dom.customFontSelect.classList.contains('open')) { this.closeFontDropdown(); } else { this.openFontDropdown(); } });
            this.dom.fontSelectDropdown.addEventListener('mouseleave', () => this.handleFontHoverEnd());
            this.dom.eraseBtn.addEventListener('click', () => this.toggleDropdownEraserMode('erase'));
            this.dom.uneraseBtn.addEventListener('click', () => this.toggleDropdownEraserMode('unerase'));
            this.dom.eraseToolDropdown.addEventListener('mousedown', e => e.stopPropagation());
            this.dom.hudEraseBtn.addEventListener('click', () => this.armEraserFromHUD('erase'));
            this.dom.hudUneraseBtn.addEventListener('click', () => this.armEraserFromHUD('unerase'));
            this.dom.eraserHud.addEventListener('mousedown', e => e.stopPropagation());
            
            document.querySelectorAll('#visuals-dropdown input, #visuals-dropdown select, #text-dropdown input, #text-dropdown textarea').forEach(input => {
                const isSlider = input.type === 'range';
                const inputEvent = isSlider ? 'input' : 'input'; 
                const changeEvent = 'change';

                const action = () => {
                    const l = this.getActiveLayer();
                    if (!l && !input.id.startsWith('bg-')) return;
                     switch(input.id) {
                        case 'asset-opacity': l.opacity = parseFloat(input.value); break;
                        case 'asset-brightness': l.brightness = parseFloat(input.value); break;
                        case 'asset-saturation': l.saturation = parseFloat(input.value); break;
                        case 'bg-brightness': this.state.canvasState.bgBrightness = parseFloat(input.value); break;
                        case 'bg-saturation': this.state.canvasState.bgSaturation = parseFloat(input.value); break;
                        case 'text-content': if(l.type==='text') l.text = input.value; this.renderTextLayerPalette(); break;
                        case 'text-size': if(l.type==='text') { l.fontSize = parseFloat(input.value); l.propSize = l.fontSize / this.dom.movieCanvas.height; } break;
                        case 'text-color': if(l.type==='text') l.color = input.value; break;
                        case 'text-edge-color': if(l.type==='text') l.strokeColor = input.value; break;
                        case 'text-edge-width': if(l.type==='text') l.strokeWidth = parseFloat(input.value); break;
                        case 'shadow-enable': if(l) { l.shadow.enabled = input.checked; document.getElementById('shadow-controls').classList.toggle('disabled', !input.checked); } break;
                        case 'shadow-color': if(l) l.shadow.color = input.value; break;
                        case 'shadow-blur': if(l) l.shadow.blur = input.value; break;
                        case 'shadow-offset-x': if(l) l.shadow.offsetX = input.value; break;
                        case 'shadow-offset-y': if(l) l.shadow.offsetY = input.value; break;
                        case 'text-shadow-enable': if(l?.type==='text') { l.shadow.enabled = input.checked; document.getElementById('text-shadow-controls').classList.toggle('disabled', !input.checked); } break;
                        case 'text-shadow-color': if(l?.type==='text') l.shadow.color = input.value; break;
                        case 'text-shadow-blur': if(l?.type==='text') l.shadow.blur = input.value; break;
                        case 'text-shadow-offset-x': if(l?.type==='text') l.shadow.offsetX = input.value; break;
                        case 'text-shadow-offset-y': if(l?.type==='text') l.shadow.offsetY = input.value; break;
                        case 'asset-edge-enable': if(l) { l.border.enabled = input.checked; document.getElementById('asset-edge-controls').classList.toggle('disabled', !input.checked); } break;
                        case 'asset-edge-color': if(l) l.border.color = input.value; break;
                        case 'asset-edge-width': if(l) l.border.width = input.value; break;
                    }
                    if (!this.state.movieInteraction.active) this.drawFrame();
                };

                input.addEventListener(inputEvent, action);
                
                const canBeChangedRapidly = (input.type === 'range' || input.type === 'color' || input.tagName === 'TEXTAREA' || input.type === 'number');
                if (canBeChangedRapidly) {
                     input.addEventListener(changeEvent, () => this.saveStateDebounced());
                } else {
                     input.addEventListener(changeEvent, () => this.saveState());
                }
            });

            const textMoveForwardBtn = document.getElementById('text-move-forward'), textMoveBackBtn = document.getElementById('text-move-back');
            if (textMoveForwardBtn) textMoveForwardBtn.addEventListener('click', () => { const l = this.getActiveLayer(); if (l?.type === 'text' && this.nudgeLayerZ(l.id, -1)) { this.renderLayerPalette(); this.renderTextLayerPalette(); this.updateTextOrderButtonsState(); this.drawFrame(); this.saveState(); } });
            if (textMoveBackBtn) textMoveBackBtn.addEventListener('click', () => { const l = this.getActiveLayer(); if (l?.type === 'text' && this.nudgeLayerZ(l.id, +1)) { this.renderLayerPalette(); this.renderTextLayerPalette(); this.updateTextOrderButtonsState(); this.drawFrame(); this.saveState(); } });
            
            this.dom.viewAllLocalAssetsBtn.addEventListener('click', () => {
                this.populateProjectLibraryPopup();
                const lastTab = localStorage.getItem('ims-last-library-tab') || 'assets';
                this.setLocalFolderTab(lastTab);
                this.dom.projectLibraryPopupOverlay.classList.add('visible');
            });
            this.dom.projectLibraryPopupCloseBtn.addEventListener('click', () => this.dom.projectLibraryPopupOverlay.classList.remove('visible'));
            this.dom.projectLibraryPopupOverlay.addEventListener('click', (e) => { if (e.target === this.dom.projectLibraryPopupOverlay) this.dom.projectLibraryPopupOverlay.classList.remove('visible'); });
            this.dom.libraryTabProjectsBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('projects'));
            this.dom.libraryTabAssetsBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('assets'));
            this.dom.libraryTabBackgroundsBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('backgrounds'));
            this.dom.libraryTabFavoritesBtn.addEventListener('click', () => this.switchAndSaveLibraryTab('favorites'));
            this.dom.eraserSizeDropdown.addEventListener('input', () => { this.dom.eraserSizeSlider.value = this.dom.eraserSizeDropdown.value; });
            this.dom.eraserSizeDropdown.addEventListener('change', () => this.saveStateDebounced());
            this.dom.eraserStrengthDropdown.addEventListener('input', () => { this.dom.eraserStrengthSlider.value = this.dom.eraserStrengthDropdown.value; });
            this.dom.eraserStrengthDropdown.addEventListener('change', () => this.saveStateDebounced());
            this.dom.eraserSizeSlider.addEventListener('input', () => { this.dom.eraserSizeDropdown.value = this.dom.eraserSizeSlider.value; if (this.dom.eraserZoomCanvas.classList.contains('visible') && this.state.lastEraseCanvasPoint) this.drawEraserZoomAt(this.state.lastEraseCanvasPoint); });
            this.dom.eraserSizeSlider.addEventListener('change', () => this.saveStateDebounced());
            this.dom.eraserStrengthSlider.addEventListener('input', () => { this.dom.eraserStrengthDropdown.value = this.dom.eraserStrengthSlider.value; });
            this.dom.eraserStrengthSlider.addEventListener('change', () => this.saveStateDebounced());
            this.dom.toggleViewBtn.addEventListener('click', () => this.toggleCanvasZoom());

            const dropdownsToScrub = [
                this.dom.visualsDropdown,
                this.dom.textDropdown,
                this.dom.eraseToolDropdown,
                this.dom.eraserHud
            ];
            dropdownsToScrub.forEach(dropdownEl => {
                if (!dropdownEl) return;
                dropdownEl.querySelectorAll('input[type="range"]').forEach(slider => {
                    if (slider.id === 'eraser-strength-dropdown' || slider.id === 'mg-eraser-strength-mini') {
                        return;
                    }

                    const sliderContainer = slider.closest('.slider-container, .row');
                    slider.addEventListener('mousedown', () => {
                        dropdownEl.classList.add('is-scrubbing');
                        if (sliderContainer) {
                            sliderContainer.classList.add('is-active-slider');
                        }
                    });
                });
            });

            window.addEventListener('mouseup', (e) => {
                this.handleMovieInteractionEnd(e);
                dropdownsToScrub.forEach(dropdownEl => {
                    if (dropdownEl && dropdownEl.classList.contains('is-scrubbing')) {
                        dropdownEl.classList.remove('is-scrubbing');
                        dropdownEl.querySelectorAll('.is-active-slider').forEach(container => {
                            container.classList.remove('is-active-slider');
                        });
                    }
                });
            });

window.addEventListener('click', (e) => {
    const dropdowns = [
        { el: this.dom.visualsDropdown, btn: this.dom.visualsBtn },
        { el: this.dom.textDropdown, btn: this.dom.textBtn },
        { el: this.dom.shortcutsDropdown, btn: this.dom.shortcutsBtn },
        { el: this.dom.eraseToolDropdown, btn: this.dom.eraseToolBtn },
        { el: this.dom.aiToolsDropdown, btn: this.dom.aiToolsBtn }
    ];

    dropdowns.forEach(item => {
        if (item.el && item.el.classList.contains('visible') && !item.el.contains(e.target) && !item.btn.contains(e.target)) {
            if (item.el === this.dom.eraseToolDropdown) {
                this.armEraser();
            }
            item.el.classList.remove('visible');
        }
    });
    
    if (this.dom.customFontSelect && this.dom.customFontSelect.classList.contains('open') && !this.dom.customFontSelect.contains(e.target)) {
        this.closeFontDropdown();
    }
});


            const canvasResizeObserver = new ResizeObserver(() => { this.resizeCanvas(); this.drawFrame(); });
            canvasResizeObserver.observe(this.dom.canvasPanel);
        },
        
        getActiveLayer() { 
            return this.state.canvasState.layers.find(l => l.id === this.state.activeLayerId);
        },

        async init() {
            ort.env.wasm.simd = true;
            ort.env.wasm.numThreads = 1;

            this.dom.loadingOverlay = document.getElementById('loading-overlay');
            this.dom.loadingMessage = this.dom.loadingOverlay.querySelector('h1');
            this.dom.toastEl = document.getElementById('mg-toast');
            this.dom.addLayerOverlay = document.getElementById('mg-asset-library-overlay');
            this.dom.assetPalette = document.getElementById('mg-asset-palette');
            this.dom.addLayerFileInput = document.getElementById('mg-asset-picker-file');
            this.dom.canvasPanel = document.getElementById('canvas-panel');
            this.dom.canvasPlaceholder = document.getElementById('canvas-placeholder');
            this.dom.controlsOverlayCanvas = document.getElementById('mg-controls-overlay-canvas');
            this.dom.initialBackgroundInput = document.getElementById('initial-background-input');
            this.dom.layerInstructions = document.getElementById('layer-instructions');
            this.dom.movieCanvas = document.getElementById('mg-movie-canvas');
            this.dom.downloadImageBtn = document.getElementById('mg-download-image-btn');
            this.dom.saveProjectBtn = document.getElementById('mg-save-project-btn');
            this.dom.clearCanvasBtn = document.getElementById('mg-clear-canvas-btn');
            this.dom.confirmationOverlay = document.getElementById('mg-confirmation-overlay');
            this.dom.confirmationText = document.getElementById('mg-confirmation-text');
            this.dom.confirmYesBtn = document.getElementById('mg-confirm-yes-btn');
            this.dom.confirmNoBtn = document.getElementById('mg-confirm-no-btn');
            this.dom.shortcutsBtn = document.getElementById('shortcuts-btn');
            this.dom.shortcutsDropdown = document.getElementById('shortcuts-dropdown');
            this.dom.visualsBtn = document.getElementById('visuals-btn');
            this.dom.visualsDropdown = document.getElementById('visuals-dropdown');
            this.dom.assetVisualsControls = document.getElementById('asset-visuals-controls');
            this.dom.assetOpacitySlider = document.getElementById('asset-opacity');
            this.dom.assetBrightnessSlider = document.getElementById('asset-brightness');
            this.dom.assetSaturationSlider = document.getElementById('asset-saturation');
            this.dom.bgBrightnessSlider = document.getElementById('bg-brightness');
            this.dom.bgSaturationSlider = document.getElementById('bg-saturation');
            this.dom.textBtn = document.getElementById('text-btn');
            this.dom.textDropdown = document.getElementById('text-dropdown');
            this.dom.textVisualsControls = document.getElementById('text-visuals-controls');
            this.dom.textContentInput = document.getElementById('text-content');
            this.dom.textSizeSlider = document.getElementById('text-size');
            this.dom.textColorInput = document.getElementById('text-color');
            this.dom.textEdgeColorInput = document.getElementById('text-edge-color');
            this.dom.textEdgeWidthSlider = document.getElementById('text-edge-width');
            this.dom.addNewTextLayerBtn = document.getElementById('add-new-text-layer-btn');
            this.dom.textLayerPalette = document.getElementById('text-layer-palette');
            this.dom.toggleViewBtn = document.getElementById('toggle-view-btn');
            this.dom.eraseToolBtn = document.getElementById('erase-tool-btn');
            this.dom.eraseToolDropdown = document.getElementById('erase-tool-dropdown');
            this.dom.eraseBtn = document.getElementById('erase-btn');
            this.dom.uneraseBtn = document.getElementById('unerase-btn');
            this.dom.aiToolsBtn = document.getElementById('ai-tools-btn');
            this.dom.aiToolsDropdown = document.getElementById('ai-tools-dropdown');
            this.dom.assetsFolderFieldset = document.getElementById('assets-folder-fieldset');
            this.dom.localAssetPalette = document.getElementById('mg-local-asset-palette');
            this.dom.localBackgroundPalette = document.getElementById('mg-local-background-palette');
            this.dom.viewAllLocalAssetsBtn = document.getElementById('mg-view-all-local-assets-btn');
            this.dom.projectLibraryPopupOverlay = document.getElementById('project-library-popup-overlay');
            this.dom.projectLibraryGridProjects = document.getElementById('project-library-grid-projects');
            this.dom.projectLibraryGridAssets = document.getElementById('project-library-grid-assets');
            this.dom.projectLibraryGridBackgrounds = document.getElementById('project-library-grid-backgrounds');
            this.dom.projectLibraryGridFavorites = document.getElementById('project-library-grid-favorites');
            this.dom.libraryTabProjectsBtn = document.getElementById('library-tab-projects');
            this.dom.libraryTabAssetsBtn = document.getElementById('library-tab-assets');
            this.dom.libraryTabBackgroundsBtn = document.getElementById('library-tab-backgrounds');
            this.dom.libraryTabFavoritesBtn = document.getElementById('library-tab-favorites');
            this.dom.projectLibraryPopupCloseBtn = document.getElementById('project-library-popup-close');
            this.dom.visualsTabAssetBtn = document.getElementById('visuals-tab-asset');
            this.dom.visualsTabBackgroundBtn = document.getElementById('visuals-tab-background');
            this.dom.assetTabPanel = document.getElementById('asset-tab-panel');
            this.dom.backgroundTabPanel = document.getElementById('background-tab-panel');
            this.dom.customFontSelect = document.getElementById('custom-font-select');
            this.dom.fontSelectTrigger = document.getElementById('font-select-trigger');
            this.dom.fontSelectDropdown = document.getElementById('font-select-dropdown');
            this.dom.fontSelectList = document.getElementById('font-select-list');
            this.dom.eraserZoomCanvas = document.getElementById('mg-eraser-zoom');
            this.dom.eraserHud = document.getElementById('mg-eraser-hud');
            this.dom.hudEraseBtn = document.getElementById('mg-hud-erase-btn');
            this.dom.hudUneraseBtn = document.getElementById('mg-hud-unerase-btn');
            this.dom.eraserSizeSlider = document.getElementById('mg-eraser-size-mini');
            this.dom.eraserStrengthSlider = document.getElementById('mg-eraser-strength-mini');
            this.dom.eraserSizeDropdown = document.getElementById('eraser-size-dropdown');
            this.dom.eraserStrengthDropdown = document.getElementById('eraser-strength-dropdown');
            this.dom.themePopupOverlay = document.getElementById('theme-popup-overlay');
            this.dom.themePopupContent = document.getElementById('theme-popup-content');
            this.dom.themeList = document.getElementById('theme-list');
            this.dom.themeSelectLink = document.getElementById('theme-select-link');
            this.dom.currentThemeNameSpan = document.getElementById('current-theme-name');
            this.dom.pasteboardOverlayCanvas = document.getElementById('mg-pasteboard-overlay-canvas');

            this.dom.movieCtx = this.dom.movieCanvas.getContext('2d');
            this.dom.controlsCtx = this.dom.controlsOverlayCanvas.getContext('2d');
            this.dom.pasteboardCtx = this.dom.pasteboardOverlayCanvas.getContext('2d');
            this.dom.eraserZoomCtx = this.dom.eraserZoomCanvas.getContext('2d');
            
            this.saveStateDebounced = this.debounce(this.saveState, this.config.DEBOUNCE_DELAY);
            this.config.themes = window.themes;

            const savedThemeName = localStorage.getItem('selectedTheme') || 'classic light';
            
            this.applyTheme(savedThemeName);
            
            this.state.originalTheme = savedThemeName;
            if (this.dom.currentThemeNameSpan) {
                this.dom.currentThemeNameSpan.textContent = savedThemeName;
            }

            this.config.availableFonts.forEach(font => this.config.fontValueToNameMap.set(font.value, font.name));

            const minDisplayTime = new Promise(resolve => setTimeout(resolve, 2400)); 
            const setupPromise = (async () => {
                this.injectNonCriticalStyles();
                this.populateThemeList();
                this.populateCustomFontSelector();
                this.addBgUI();
                await this.dedupeExistingAssetsByHashKeepNewest();
                await this.restoreCurrentWork();
                this.updateControlsState();
                this.updateEditPanelsUI();
                this.setupEventListeners();
                this.drawFrame();
            })();

            try {
                await Promise.all([minDisplayTime, setupPromise]);
            } catch (error) {
                console.error("Initialization failed, but proceeding to the app anyway.", error);
                this.toast("Could not restore a previous session.", 4000);
            } finally {
                this.hideLoadingScreen();
            }
        }
    };

    // Kick off the application
    ImageMakerStudio.init();
</script>
</body>
</html>
