<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Image Maker Studio</title>
<link rel="icon" type="image/png" href="favicon.ico">
<!-- === FONT LOADING OPTIMIZATION: Load critical and fallback fonts first === -->
<link href="https://fonts.googleapis.com/css2?family=VT323&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
/* --- CRITICAL CSS: Inlined for fastest first paint --- */
:root{--bg:#f2efe8;--ink:#2b2b2b;--mid:#c2c2c2;--light:#faf9f5;--light-rgb:250,249,245;--shadow:#7a7a7a;--danger-color:#cc4444;--action-color:#4477cc;--success-color:#55cc55;--bg-rgb:242,239,232;--action-color-rgb:68,119,204;transition:--bg .3s, --ink .3s, --mid .3s, --light .3s, --shadow .3s, --action-color .3s, --danger-color .3s, --success-color .3s}
html{box-sizing:border-box}*,:before,:after{box-sizing:inherit}
body{font-family:'VT323',monospace;background:var(--bg);color:var(--ink);display:flex;flex-direction:column;align-items:center;padding:10px;margin:0;height:100vh;overflow:hidden;transition:background-color .3s,color .3s}
#loading-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:var(--bg);color:var(--ink);display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity .5s ease-in-out}
#loading-overlay h1{font-family:'VT323',monospace;font-size:2.5rem;text-shadow:1px 1px 0 var(--shadow)}
#loading-overlay h1::after{content:'.';display:inline-block;width:3ch;text-align:left;animation:ellipsis 1.4s infinite}
@keyframes ellipsis{0%{content:'.'}33%{content:'..'}66%{content:'...'}}

/* === INTEGRATED DROPDOWN STYLES START === */
.window{position:relative;background:var(--light);border:2px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s;border-radius:3px}
.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:2px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}
.titlebar-controls{display:flex;align-items:center;gap:8px}
.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:2px solid var(--ink)}
.controls-fake .btn-square:first-child{background-color:var(--success-color)}
.controls-fake .btn-square:last-child{background-color:var(--danger-color)}

/* Dropdown Button Styling */
#erase-tool-btn, #shortcuts-btn, #text-btn, #toggle-view-btn, #visuals-btn, #ai-tools-btn {
    font-family: inherit;
    font-size: 1.1rem;
    background: var(--light);
    border: 2px solid var(--ink);
    padding: 0 8px;
    cursor: pointer;
    color: var(--ink);
    border-radius: 3px;
    box-shadow: 2px 2px 0 var(--shadow);
    transition: transform .15s ease-out, box-shadow .15s ease-out;
}
#erase-tool-btn:hover, #shortcuts-btn:hover, #text-btn:hover, #toggle-view-btn:hover, #visuals-btn:hover, #ai-tools-btn:hover {
    transform: translate(1px, 1px);
    box-shadow: 1px 1px 0 var(--shadow);
}
#erase-tool-btn:active, #shortcuts-btn:active, #text-btn:active, #toggle-view-btn:active, #visuals-btn:active, #ai-tools-btn:active {
    transform: translate(2px, 2px);
    box-shadow: none;
}
#toggle-view-btn { /* Specific style for the toggle button */
    padding: 0 4px;
    font-size: 18px;
}

/* === MODIFIED: Dropdown Panel Styling with Scroll === */
#erase-tool-dropdown, #shortcuts-dropdown, #text-dropdown, #visuals-dropdown, #ai-tools-dropdown {
    position: absolute;
    top: 28px;
    background: rgba(var(--light-rgb), .65);
    -webkit-backdrop-filter: blur(4px);
    backdrop-filter: blur(4px);
    border: 2px solid var(--ink);
    box-shadow: 2px 2px 0 var(--shadow);
    padding: .5rem 1rem;
    z-index: 100;
    width: 250px;
    border-radius: 4px;
    opacity: 0;
    transform: translateY(-10px);
    transition: opacity .2s ease-out, transform .2s ease-out;
    pointer-events: none;
    display: none;
    max-height: calc(100vh - 88px); /* New */
    overflow-y: auto; /* New */
}


/* Positioning for each dropdown */
#visuals-dropdown   { right: 382px; width: 280px; }
#erase-tool-dropdown  { right: 288px; width: auto; }
#ai-tools-dropdown    { right: 198px; }
#text-dropdown        { right: 102px; width: 280px; }
#shortcuts-dropdown   { right: 8px; }


/* Visibility Toggle */
#erase-tool-dropdown.visible, #shortcuts-dropdown.visible, #text-dropdown.visible, #visuals-dropdown.visible, #ai-tools-dropdown.visible {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
    display: block; /* Use display to show/hide */
}

/* Headers and content within dropdowns */
#erase-tool-dropdown h5, #shortcuts-dropdown h5, #text-dropdown h5, #visuals-dropdown h5, #ai-tools-dropdown h5 {
    margin: 0 0 .5rem;
    font-size: 1.25rem;
    text-align: center;
}
#erase-tool-dropdown h6, #text-dropdown h6, #visuals-dropdown h6 {
    font-size: 1.15rem;
    font-weight: 700;
    text-align: left;
    margin-top: .5rem;
    margin-bottom: .5rem;
    border-bottom: 2px solid var(--mid);
    padding-bottom: 2px;
}
.compact-slider-row { display: flex; align-items: center; gap: .75rem; margin-bottom: .5rem; }
.compact-slider-row label { flex-shrink: 0; margin: 0; }
.compact-slider-row input[type=range] { width: 100%; }
.compact-color-row { display: flex; align-items: flex-start; gap: .75rem; }
.compact-color-row .slider-container { flex: 1; }
.compact-color-row input[type="color"] { width: 100%; height: 25px; padding: 0; border: 1px solid var(--ink); }
.compact-color-row label { margin-bottom: 2px; }

#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}
#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}
#shortcuts-dropdown li kbd{font-family:inherit;border:2px solid var(--ink);padding:0 4px;background:var(--bg);transition:background-color .3s,border-color .3s,color .3s}

/* Additional styles to integrate with your existing code */
main#studio-container { display:grid; grid-template-columns:320px 1fr; grid-template-rows:minmax(0,1fr); gap:1.5rem; padding:1.5rem; flex-grow:1; min-height:0 }
#controls-panel { display:flex; flex-direction:column; gap:1rem; overflow-y:auto; min-height:0 }
#canvas-panel { display:flex; align-items:center; justify-content:center; border:2px solid var(--ink); background-color:var(--mid); position:relative; min-height:0; transition:background-color .5s ease-in-out; overflow:hidden }
#controls-panel fieldset { border: 2px solid var(--ink); padding: .8rem; margin: 0; }
.hidden { display: none !important; }
.disabled { opacity: 0.5; pointer-events: none; }
.slider-container { margin-bottom: 0.5rem; }
.mg-btn{font-family:inherit;font-size:18px;background:var(--light);border:2px solid var(--ink);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0 var(--shadow);width:100%;white-space:nowrap;border-radius:3px}
.mg-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}
.mg-btn:active{transform:translate(2px,2px);box-shadow:none}.mg-btn.disabled,.mg-btn:disabled{opacity:.5;pointer-events:none;box-shadow:none;transform:none}
.mg-btn.active{background-color:var(--action-color);color:var(--light);box-shadow:none;transform:translate(2px,2px)}
.eraser-mode-selector { display: flex; gap: 0.5rem; }
#text-layer-manager { display: flex; gap: .5rem; align-items:center; padding-bottom:.5rem; margin-bottom:.5rem; border-bottom:2px solid var(--mid); }
.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}
.effects-controls{padding-left:1.5rem;border-left:2px solid var(--mid);margin-left:.5rem}
footer{height:28px;padding:0 8px;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:2px solid var(--ink)}
.footer-links,.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}
footer a{color:var(--ink);text-decoration:none;transition:opacity .2s,color .3s;opacity:.7}
footer a:hover{opacity:1}footer a i{margin-right:.5em}
.mg-overlay-base{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .3s,visibility 0s .3s;background:rgba(10,10,10,.25)}
.mg-overlay-base.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .3s,visibility 0s 0s}
#canvas-placeholder { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
.placeholder-text { color: var(--shadow); }

#eraser-hardness-presets {
    justify-content: space-around;
    margin-top: 0.5rem;
}
#eraser-hardness-presets .mg-btn {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    padding: 0;
    flex-shrink: 0;
    border-width: 2px;
    box-shadow: 1px 1px 0 var(--shadow);
    transform: translateY(0);
}
#eraser-hardness-presets .mg-btn:hover {
    transform: translate(1px, 1px);
    box-shadow: none;
}
#eraser-hardness-presets .mg-btn.active {
    background-color: var(--action-color);
    transform: translateY(1px);
    box-shadow: none;
}

/* === RESTORED: PROJECT LIBRARY STYLES (MAIN PANEL) === */
#assets-folder-fieldset { position: relative; }
#assets-folder-actions { display:flex; justify-content:space-between; align-items:center; margin-bottom:.5rem; }
#assets-folder-actions p { font-size:1.1rem; margin:0; }
#mg-view-all-local-assets-btn { 
    position: absolute; 
    top: -14px; 
    right: 12px;
    width:auto; 
    padding: 2px 8px; 
    font-size: 16px; 
    margin: 0;
}


/* === POPUP: PROJECT LIBRARY STYLES === */
.visuals-main-tab-btn {
    font-family:inherit; font-size:16px; background:var(--light); border:2px solid var(--ink);
    padding:4px 8px; cursor:pointer; color:var(--ink); transition:.2s all;
    box-shadow:2px 2px 0 var(--shadow); flex-grow:1; text-align:center; border-radius:3px
}
.visuals-main-tab-btn:hover { transform:translate(1px,1px); box-shadow:1px 1px 0 var(--shadow) }
.visuals-main-tab-btn.active { background-color:var(--action-color); color:var(--light); transform:translate(2px,2px); box-shadow:none }

body[data-theme-name="classic light"] .visuals-main-tab-btn.active,
body[data-theme-name="classic light"] .mg-btn.active {
    color: var(--bg);
}
body[data-theme-name="dark"] .mg-btn.active,
body[data-theme-name="dark"] .visuals-main-tab-btn.active {
    color: var(--ink);
}



#project-library-popup {
    width:90%; max-width:800px; height:80vh; padding:0; display:flex; flex-direction:column;
}
#project-library-popup .titlebar { flex-shrink:0; }
#project-library-grids-container { flex-grow: 1; overflow-y: auto; }
.project-library-grid {
    padding:1rem; display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
    gap:1rem; align-content:flex-start;
}
.project-library-grid h5 {
    grid-column: 1 / -1;
    text-align: left;
    font-size: 1.25rem;
    margin: 0.5rem 0 0;
    border-bottom: 2px solid var(--mid);
    padding-bottom: 4px;
}
.library-grid-item {
    width:100%; aspect-ratio:1/1; border:2px solid var(--ink); background:var(--light);
    position:relative; box-shadow:3px 3px 0 var(--ink); transition:transform .15s ease-out,box-shadow .15s ease-out;
    border-radius:3px;
}

/* === MODIFIED: Favorite & Delete Button Styles === */
.library-grid-item .delete-btn {
    position:absolute; top:-8px; right:-8px; background:var(--danger-color); color:var(--light);
    border:2px solid var(--ink); width:24px; height:24px; font-size:16px;
    cursor:pointer; display:flex; align-items:center; justify-content:center;
    line-height:1; z-index:2; opacity:0; transition: all .15s ease-out;
    border-radius: 2px; font-family: monospace;
}

.library-grid-item .favorite-btn {
    position:absolute; top:-8px; left:-8px; background:var(--mid); color:var(--ink);
    border:2px solid var(--ink); width:24px; height:24px; font-size:16px;
    cursor:pointer; display:flex; align-items:center; justify-content:center;
    line-height:1; z-index:2; opacity:0; transition: all .15s ease-out;
    border-radius: 2px; box-shadow: 1px 1px 0 var(--ink);
}

/* Lift buttons on hover for interactivity */
.library-grid-item .delete-btn:hover,
.library-grid-item .favorite-btn:hover {
    transform: translateY(-1px);
    box-shadow: 2px 2px 0 var(--ink);
}
/* Press buttons down on click */
.library-grid-item .delete-btn:active,
.library-grid-item .favorite-btn:active {
    transform: scale(0.95) translateY(1px);
    box-shadow: none;
}

/* Keep favorite button pressed down when active */
.library-grid-item .favorite-btn.is-favorite {
    background-color: var(--action-color);
    transform: translateY(1px);
    box-shadow: none;
}

.library-grid-item .favorite-btn::before {
    font-family: "Font Awesome 6 Free";
    font-weight: 400; /* Hollow star by default */
    content: "\f005";
    transition: font-weight .2s, color .2s;
}

/* When favorited, icon color should contrast with new background */
.library-grid-item .favorite-btn.is-favorite::before {
    color: var(--light);
}

/* On hover OR if favorited, make the star solid */
.library-grid-item .favorite-btn:hover::before,
.library-grid-item .favorite-btn.is-favorite::before {
    font-weight: 900;
}

.library-grid-item:hover .delete-btn, .library-grid-item:hover .favorite-btn { opacity:1; }

.library-grid-item > div { cursor:pointer; width:100%; height:100%; }
.library-grid-item:hover {
    transform:translate(-2px,-2px) scale(1.03); box-shadow:5px 5px 0 var(--ink); border-color:var(--action-color);
}
.library-grid-item img, .library-grid-item video {
    width:100%; height:100%; object-fit:cover; pointer-events:none;
}

/* === MODIFIED: Popup Close Button Styles === */
.overlay-close-btn {
    width: 20px;
    height: 20px;
    background: var(--danger-color);
    border: 2px solid var(--ink);
    color: var(--ink);
    font-family: 'VT323', monospace;
    font-size: 18px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    cursor: pointer;
    z-index: 10;
    transition: filter .2s;
}
.overlay-close-btn:hover {
    filter: brightness(1.2);
}
#project-library-popup .overlay-close-btn {
    margin-left: auto; /* Push to the right */
}
#mg-asset-picker-wrapper .overlay-close-btn {
    position: absolute;
    top: 10px;
    right: 12px;
}

#mg-asset-picker-wrapper.window{background:rgba(var(--light-rgb),.85);-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);padding:2rem;max-width:450px;width:90vw;text-align:center;color:var(--ink);height:auto;max-height:90vh}
body[data-theme-is-dark=true] #mg-asset-picker-wrapper,
body[data-theme-is-dark=true] #mg-asset-picker-wrapper .overlay-close-btn{color:var(--ink)}
#mg-asset-picker-wrapper h4{font-size:1.8rem;font-weight:400;margin:0 0 .5rem}
#mg-asset-picker-wrapper>p{font-size:1rem;margin:0 0 1.5rem}
#mg-asset-drop-zone{border:4px dashed var(--mid);border-radius:10px;padding:2rem;color:var(--mid);cursor:pointer;transition:all .2s ease-in-out;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1}
#mg-asset-drop-zone h3{font-size:1.5rem;margin:0 0 .5rem;pointer-events:none}
#mg-asset-drop-zone p{font-size:1rem;margin:0;pointer-events:none}
#mg-asset-drop-zone.drag-over,#mg-asset-drop-zone:hover{border-color:var(--ink);color:var(--ink);background-color:rgba(var(--action-color-rgb),.1);border-style:solid}

</style>
</head>
<body>
<script>
  (function() {
    try {
        const themes = {
            'classic light': { name: 'classic light', isDark: false, colors: ['#f2efe8', '#2b2b2b', '#c2c2c2'], css: { '--bg': '#f2efe8', '--ink': '#2b2b2b', '--mid': '#c2c2c2', '--light': '#faf9f5', '--shadow': '#7a7a7a', '--action-color': '#2b2b2b', '--danger-color': '#cc4444', '--success-color': '#55cc55' } },
            'dark': { name: 'dark', isDark: true, colors: ['#1a1d2d', '#e0e5f0', '#3d4a6e'], css: { '--bg': '#1a1d2d', '--ink': '#e0e5f0', '--mid': '#3d4a6e', '--light': '#252a40', '--shadow': '#0d0f16', '--action-color': '#1a1d2d', '--danger-color': '#a83e3e', '--success-color': '#4a9d4a' } },
            'イーピーイッピ': { name: 'イーピーイッピ', isDark: true, colors: ['#5c3d46', '#dcd0c0', '#a26769'], css: { '--bg': '#2a1d21', '--ink': '#dcd0c0', '--mid': '#5c3d46', '--light': '#402d32', '--shadow': '#1a1114', '--action-color': '#a26769', '--danger-color': '#a26769', '--success-color': '#69a267' } },
            'zarah': { name: 'zarah', isDark: false, colors: ['#7b9c98', '#eaf1f3', '#495555'], css: { '--bg': '#7b9c98', '--ink': '#eaf1f3', '--mid': '#495755', '--light': '#6c8985', '--shadow': '#3e4a48', '--action-color': '#eaf1f3' } },
            'lavender': { name: 'lavender', isDark: false, colors: ['#b3b3d9', '#282846', '#656599'], css: { '--bg': '#b3b3d9', '--ink': '#282846', '--mid': '#656599', '--light': '#c4c4e2', '--shadow': '#47476b', '--action-color': '#8c58a6' } },
            'café': { name: 'café', isDark: false, colors: ['#ceb18d', '#4e433f', '#d4d2d1'], css: { '--bg': '#ceb18d', '--ink': '#4e433f', '--mid': '#d4d2d1', '--light': '#f7f2ea', '--shadow': '#8a7a6a', '--action-color': '#8a6ea2' } },
            'mizu': { name: 'mizu', isDark: false, colors: ['#b8dceb', '#091f2c', '#89a5bb'], css: { '--bg': '#b8dceb', '--ink': '#091f2c', '--mid': '#89a5bb', '--light': '#cfe5ee', '--shadow': '#627382', '--action-color': '#005a8e' } },
            'キティ': { name: 'キティ', isDark: false, colors: ['#fdf6e3', '#657b83', '#93a1a1'], css: { '--bg': '#fdf6e3', '--ink': '#657b83', '--mid': '#93a1a1', '--light': '#eee8d5', '--shadow': '#586e75', '--action-color': '#268bd2' } },
            'aura': { name: 'aura', isDark: true, colors: ['#29423D', '#EAE8E1', '#C9A59C'], css: { '--bg': '#1A2A27', '--ink': '#EAE8E1', '--mid': '#3E5D56', '--light': '#29423D', '--shadow': '#111C19', '--action-color': '#C9A59C', '--danger-color': '#b05454', '--success-color': '#5a9e7a' } }
        };
        const savedThemeName = localStorage.getItem('selectedTheme') || 'classic light';
        const theme = themes[savedThemeName];
        if (theme) {
            const style = document.createElement('style');
            const cssVars = Object.entries(theme.css).map(([key, value]) => `${key}: ${value};`).join('');
            style.textContent = `:root { ${cssVars} }`;
            document.head.appendChild(style);
            document.body.dataset.themeName = savedThemeName;
        }
    } catch (e) { console.warn("Theme pre-loader failed.", e); }
  })();
</script>

<div class=window>
<div id="loading-overlay"><h1>Initializing Image-Maker-Studio.exe</h1></div>
<div class=titlebar><span>Image-Maker-Studio.exe</span><div class=titlebar-controls>
    <button id="toggle-view-btn" title="Toggle Canvas View (Z)">⬚</button>
    <button id=visuals-btn>Edit Visuals</button>
    <div id="visuals-dropdown">
        <h5>Visuals Editor</h5>
        <div id="visuals-tabs" class="eraser-mode-selector" style="margin-bottom: 0.8rem;"><button id="visuals-tab-asset" class="mg-btn" type="button">Asset</button><button id="visuals-tab-background" class="mg-btn active" type="button">Background</button></div>
        <div id="asset-tab-panel" class="hidden">
            <div id="asset-visuals-controls" class="disabled">
                <h6>Filters</h6>
                <div class=slider-container><label for=asset-opacity>Opacity</label><input type=range id=asset-opacity min=0 max=1 step=.01 value=1></div>
                <div class=slider-container><label for=asset-brightness>Brightness</label><input type=range id=asset-brightness min=0 max=2 step=.01 value=1></div>
                <div class=slider-container><label for=asset-saturation>Saturation</label><input type=range id=asset-saturation min=0 max=2 step=.01 value=1></div>
                
                <h6>Drop Shadow</h6>
                <div class="effects-checkbox" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
                    <div><input type="checkbox" id="shadow-enable"><label for="shadow-enable">Enable</label></div>
                    <input type="color" id="shadow-color" value="#000000" style="width: 100px; height: 25px; border: 1px solid var(--ink); padding: 0;">
                </div>
                <div id="shadow-controls" class="effects-controls disabled">
                    <div class="slider-container"><label for="shadow-blur">Blur</label><input type="range" id="shadow-blur" min="0" max="50" value="10"></div>
                    <div class="slider-container"><label for="shadow-offset-x">Offset X</label><input type="range" id="shadow-offset-x" min="-50" max="50" value="10"></div>
                    <div class="slider-container"><label for="shadow-offset-y">Offset Y</label><input type="range" id="shadow-offset-y" min="-50" max="50" value="10"></div>
                </div>
                
                <h6>Edge</h6>
                 <div class="effects-checkbox" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
                     <div><input type="checkbox" id="asset-edge-enable"><label for="asset-edge-enable">Enable</label></div>
                     <input type="color" id="asset-edge-color" value="#FFFFFF" style="width: 100px; height: 25px; border: 1px solid var(--ink); padding: 0;">
                </div>
                <div id="asset-edge-controls" class="effects-controls disabled">
                    <div class="slider-container"><label for="asset-edge-width">Width</label><input type="range" id="asset-edge-width" min="0" max="20" value="4"></div>
                </div>
            </div>
        </div>
        <div id="background-tab-panel">
             <div id="background-visuals-controls">
                <h6>Background Filters</h6>
                <div class=slider-container><label for=bg-brightness>Brightness</label><input type=range id=bg-brightness min=0 max=2 step=.01 value=1></div>
                <div class=slider-container><label for=bg-saturation>Saturation</label><input type=range id=bg-saturation min=0 max=2 step=.01 value=1></div>
            </div>
        </div>
    </div>
    <button id="erase-tool-btn">Erase</button>
    <div id="erase-tool-dropdown">
        <h5>Eraser Tool</h5>
        <div class="eraser-mode-selector">
            <button class="mg-btn" id="erase-btn">Erase</button>
            <button class="mg-btn" id="unerase-btn">Unerase</button>
        </div>
        <div id="eraser-controls-wrapper" class="disabled">
            <div class="slider-container">
                <label for="eraser-size-dropdown">Size</label>
                <input type="range" id="eraser-size-dropdown" min="5" max="250" value="128">
            </div>
            <div class="slider-container">
                <label for="eraser-strength-dropdown">Strength</label>
                <input type="range" id="eraser-strength-dropdown" min="0" max="1" step="0.01" value="1">
            </div>
        </div>
    </div>
    <button id="ai-tools-btn">BG Remover.exe</button><div id="ai-tools-dropdown"><h5>Background Remover</h5></div><button id=text-btn>Text</button><div id=text-dropdown><h5>Text Editor</h5><div id=text-layer-manager><div id=text-layer-palette></div><button id=add-new-text-layer-btn class="palette-slot empty" title="Add new text layer">+</button></div><div id=text-visuals-controls class=disabled><div class=slider-container><label for=text-content>Text Content</label><textarea id=text-content rows=3 style="width:100%;font-family:inherit;font-size:1rem;padding:4px;border:1px solid var(--ink);background:var(--bg);line-height:1.1;">New Text</textarea></div>
        <div class="slider-container">
            <label>Font</label>
            <div id="custom-font-select">
                <div id="font-select-trigger" tabindex="0"><span>VT323</span> <i class="fas fa-chevron-down"></i></div>
                <div id="font-select-dropdown" class="hidden"><ul id="font-select-list"></ul></div>
            </div>
        </div>
        <div class=slider-container><label for=text-size>Size</label><input type=range id=text-size min=20 max=800 step=1 value=410></div>
        <div class="compact-color-row">
            <div class=slider-container><label for=text-color>Color</label><input type=color id=text-color value=#FFFFFF></div>
            <div class=slider-container><label for="text-edge-color">Edge Color</label><input type="color" id="text-edge-color" value="#000000"></div>
        </div>
        <div class="slider-container"><label for="text-edge-width">Edge Density</label><input type="range" id="text-edge-width" min="0" max="20" step="0.1" value="0"></div>
        <h6>Drop Shadow</h6>
        <div class="effects-checkbox" style="display: flex; justify-content: space-between; align-items: center;">
            <div><input type="checkbox" id="text-shadow-enable"><label for="text-shadow-enable">Enable</label></div>
            <div class="slider-container" style="margin-bottom: 0; width: 60%;"><label for="text-shadow-color" style="margin-top:0;">Color</label><input type="color" id="text-shadow-color" value="#000000" style="width:100%;border:none;padding:0"></div>
        </div>
        <div id="text-shadow-controls" class="effects-controls disabled">
            <div class="slider-container"><label for="text-shadow-blur">Blur</label><input type="range" id="text-shadow-blur" min="0" max="50" value="10"></div>
            <div class="slider-container"><label for="text-shadow-offset-x">Offset X</label><input type="range" id="text-shadow-offset-x" min="-50" max="50" value="10"></div>
            <div class="slider-container"><label for="text-shadow-offset-y">Offset Y</label><input type="range" id="text-shadow-offset-y" min="-50" max="50" value="10"></div>
        </div>
        <div id="text-zorder-controls" style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem;"><button id="text-move-back" class="mg-btn" type="button" style="width:auto;padding:2px 8px;">Move back</button><button id="text-move-forward" class="mg-btn" type="button" style="width:auto;padding:2px 8px;">Move forward</button></div></div></div>
<button id=shortcuts-btn>Shortcuts</button><div class=controls-fake><div class=btn-square></div><div class=btn-square></div></div><div id=shortcuts-dropdown><h5>Keyboard Shortcuts</h5><ul><li><span>Toggle Canvas View</span><kbd>Z</kbd></li><li><span>Enlarge Asset</span><kbd>D</kbd></li><li><span>Shrink Asset</span><kbd>F</kbd></li><li><span>Flip Asset Horizontally</span><kbd>S</kbd></li><li><span>Move Layer Forward</span><kbd>Q</kbd></li><li><span>Move Layer Backward</span><kbd>W</kbd></li><li><span>Delete Asset</span><kbd>Delete</kbd></li><li><span>Save Project</span><kbd>Cmd/Ctrl + S</kbd></li></ul></div></div></div><main id=studio-container><div id=controls-panel>
    <fieldset id="assets-folder-fieldset">
        <legend>Project Library</legend>
        <button id="mg-view-all-local-assets-btn" class="mg-btn">View All</button>
        <div id="assets-folder-actions"><p>Your recent assets</p></div>
        <div id="mg-local-asset-palette"></div>
        <p style="font-size: 1.1rem; margin-top: 0.6rem; margin-bottom: 0.5rem;">Your recent backgrounds</p>
        <div id="mg-local-background-palette"></div>
    </fieldset>
    <fieldset id="layers-fieldset"><legend>Layers</legend><p id=layer-instructions class=placeholder-text>Add a background to begin.</p><div id="mg-asset-palette"></div></fieldset>
<fieldset><legend>Canvas Actions</legend><div class="action-buttons" style="margin-bottom: 0.5rem; display: flex; gap: 0.5rem;"><button class="mg-btn" id="mg-save-project-btn" disabled>Save Project</button><button class="mg-btn" id="mg-clear-canvas-btn" disabled>Clear Canvas</button></div><button class="mg-btn generate" id=mg-download-image-btn disabled>Download Image</button></fieldset></div><div id=canvas-panel>
<canvas id=mg-movie-canvas></canvas><canvas id=mg-controls-overlay-canvas></canvas><canvas id="mg-pasteboard-overlay-canvas"></canvas><canvas id="mg-eraser-zoom"></canvas>
<div id="mg-eraser-hud">
    <div class="row eraser-mode-selector" style="margin-bottom:6px; width: 100%;"><button class="mg-btn" id="mg-hud-erase-btn" type="button" title="Erase">Erase</button><button class="mg-btn" id="mg-hud-unerase-btn" type="button" title="Unerase">Unerase</button></div>
    <div class="row"><label for="mg-eraser-size-mini" style="font-size:14px;">Size</label><input id="mg-eraser-size-mini" type="range" min="5" max="250" value="128"></div>
    <div class="row" style="margin-top: 4px;"><label for="mg-eraser-strength-mini" style="font-size:14px;">Strength</label><input id="mg-eraser-strength-mini" type="range" min="0" max="1" step="0.01" value="1"></div>
</div>
<div id=canvas-placeholder><img src="welcome.png" alt="Click or drag and drop to start creating"><h3>Click, Paste, or Drag & Drop File</h3><p>to add a background image & begin creating</p></div></div></main>
<footer>
    <div class="footer-links"><a href="#"><i class="fas fa-envelope"></i>feedback</a><a href="#"><i class="fab fa-twitter"></i>updates</a><a href="#"><i class="fas fa-file-alt"></i>license</a><a href="#"><i class="fas fa-shield-alt"></i>report</a><a href="#"><i class="fas fa-lock"></i>privacy</a></div>
    <div class="footer-right"><a href="#" id="theme-select-link"><i class="fas fa-palette"></i><span id="current-theme-name"></span></a><a href="#" id="version-link"><i class="fas fa-code-branch"></i>v4.18.1</a></div>
</footer>
<input type=file id=initial-background-input accept=image/* style=display:none></div>

<!-- === MODIFIED: This is the new Add Layer popup based on the reference === -->
<div id="mg-asset-library-overlay" class="mg-overlay-base">
    <div id="mg-asset-picker-wrapper" class="window">
        <button id="mg-asset-library-close" class="overlay-close-btn">X</button>
        <h4>Add a New Layer</h4>
        <p>Add your own image to the current scene.</p>
        <div id="mg-asset-drop-zone">
            <h3>Click, Paste, or Drag & Drop File</h3>
            <p>Supported formats: PNG, JPG, JPEG</p>
        </div>
        <div id="mg-asset-picker-actions">
             <input type="file" id="mg-asset-picker-file" accept="image/png, image/jpeg" style="display:none">
        </div>
    </div>
</div>


<div id="project-library-popup-overlay" class="mg-overlay-base">
    <div id="project-library-popup" class="window">
        <div class="titlebar">
            <span>Project Library</span>
            <button id="project-library-popup-close" class="overlay-close-btn">X</button>
        </div>
        <div class="library-tabs" style="padding: 0.5rem 1rem; display: flex; gap: 0.5rem; border-bottom: 2px solid var(--ink);">
            <button id="library-tab-projects" class="visuals-main-tab-btn">Projects</button>
            <button id="library-tab-assets" class="visuals-main-tab-btn active">Assets</button>
            <button id="library-tab-backgrounds" class="visuals-main-tab-btn">Backgrounds</button>
            <button id="library-tab-favorites" class="visuals-main-tab-btn">Favorites</button>
        </div>
        <div id="project-library-grids-container" style="flex-grow: 1; overflow-y: auto;">
            <div id="project-library-grid-projects" class="project-library-grid hidden"></div>
            <div id="project-library-grid-assets" class="project-library-grid"></div>
            <div id="project-library-grid-backgrounds" class="project-library-grid hidden"></div>
            <div id="project-library-grid-favorites" class="project-library-grid hidden"></div>
        </div>
    </div>
</div>

<div id=mg-confirmation-overlay class=mg-overlay-base><div id=mg-confirmation-dialog class=window><p id=mg-confirmation-text>Are you sure?</p><div class=action-buttons><button id="mg-confirm-yes-btn" class="mg-btn active" type="button">Yes</button><button id="mg-confirm-no-btn" class="mg-btn" type="button">No</button></div></div></div>
<div id="mg-asset-action-overlay" class=mg-overlay-base style="display: none;"><div id="mg-asset-action-dialog" class=window><p>How would you like to use this asset?</p><div class="action-buttons"><button id="mg-asset-action-background-btn" class="mg-btn">Set as Background</button><button id="mg-asset-action-layer-btn" class="mg-btn">Add as Layer</button></div></div></div>
<div id="version-popup-overlay" style="display: none;">
    <div id="version-popup-content">
        <span id="close-popup">X</span>
        <h4>v4.18.1</h4>
        <h6>12 Sep 2025</h6>
        <p>A performance and user experience patch focused on improving initial load times and refining UI elements based on user feedback.</p>
        <h5>Features</h5>
        <ul>
            <li><strong>performance:</strong> Implemented "critical CSS" to ensure the loading screen appears almost instantly. Non-essential styles are now loaded asynchronously.</li>
            <li><strong>performance:</strong> Decorative fonts are now loaded on-demand when the user opens the Text Editor for the first time, saving multiple network requests on initial load.</li>
        </ul>
        <h5>Improvements</h5>
        <ul>
            <li><strong>performance:</strong> Removed the background removal tool to significantly reduce the initial JavaScript bundle size.</li>
            <li><strong>performance:</strong> Replaced the welcome video with a static, compressed PNG to speed up the placeholder view.</li>
            <li><strong>ux:</strong> The border style selector popup is now a perfectly sized, non-scrollable grid with centered previews and improved spacing.</li>
            <li><strong>ux:</strong> Previews in the border style selector now use the theme's main ink color (e.g., black) instead of green for better visual consistency.</li>
            <li><strong>ui:</strong> Added small 'x' markers to the corners of the "Classic Barb" border preview to better reflect its on-canvas appearance.</li>
        </ul>
        <h5>Fixes</h5>
        <ul>
            <li><strong>style:</strong> Corrected the "Classic Wiggle" rotator handle on the canvas, which was incorrectly showing a black fill; it now correctly shows only the green stroke.</li>
        </ul>

        <hr style="margin: 2rem 0;">

        <h4>v4.18.0</h4>
        <h6>11 Sep 2025</h6>
        <p>A major update focused on UI/UX enhancements and bug fixes, particularly for the editing tools.</p>
        <h5>Features</h5>
        <ul>
            <li><strong>ui:</strong> re-architected the 'Edit Visuals' dropdown into a tabbed interface ("Asset" and "Background") to improve organization and ensure it fits on smaller screens</li>
            <li><strong>eraser:</strong> added a floating side HUD that appears when the eraser tool is active, providing quick access to primary controls without reopening the main dropdown</li>
            <li><strong>ux:</strong> implemented a smooth "scrubbing" effect for sliders, which fades out non-essential UI elements during adjustment for better focus</li>
        </ul>
        <h5>Improvements</h5>
        <ul>
            <li><strong>style:</strong> reduced border and box-shadow thickness sitewide for a lighter, more refined aesthetic</li>
            <li><strong>eraser:</strong> redesigned the side HUD with clear "Erase" and "Unerase" buttons that dynamically match the application's selected theme</li>
            <li><strong>eraser:</strong> added a "Strength" slider to the side HUD for quick access to both primary brush settings</li>
            <li><strong>eraser:</strong> refined the activation flow to keep the main dropdown open for initial adjustments; the side HUD now appears only after the user moves to the canvas</li>
            <li><strong>ui:</strong> added smooth fade-in and fade-out transitions to the eraser's side HUD and magnifying zoom window for a more polished feel</li>
            <li><strong>ux:</strong> the "Asset" tab in the Visuals Editor is now always clickable and provides a helpful toast message if no asset is currently selected</li>
            <li><strong>ux:</strong> improved instructional text for the eraser, changing "Armed" to "Activated" and clarifying how to deactivate the tool</li>
            <li><strong>text:</strong> renamed "Stroke Width" to "Density" in the Text Editor</li>
            <li><strong>performance:</strong> capped the eraser's undo history to a maximum of 10 steps per layer to prevent excessive memory usage</li>
        </ul>
        <h5>Fixes</h5>
        <ul>
            <li><strong>download:</strong> implemented a missing `toast` function that was causing a critical error and preventing the "Download Image" button from working</li>
            <li><strong>eraser:</strong> the floating side HUD no longer incorrectly disappears when a user interacts with its sliders</li>
            <li><strong>eraser:</strong> the Size and Strength sliders are now perfectly synced in real-time between the main dropdown and the side HUD</li>
            <li><strong>eraser:</strong> the side HUD now correctly disappears the moment an erase action begins (mouse-down) and reappears immediately upon release (mouse-up)</li>
            <li><strong>ui:</strong> disabled the "scrubbing" fade-out effect for all "Strength" sliders, as hiding the UI was not necessary for that specific adjustment</li>
        </ul>
    </div>
</div>
<div id="theme-popup-overlay" style="display: none;"><div id="theme-popup-content"><ul id="theme-list"></ul></div></div>
<div id=mg-toast></div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
<script>
    (function () {
        // --- ONNX RUNTIME CONFIG ---
        ort.env.wasm.simd = true;
        ort.env.wasm.numThreads = 1; // Use single-thread for max compatibility

        // --- DEFERRED ASSETS LOGIC ---
        let secondaryFontsLoaded = false;
        const loadedFonts = new Set(['VT323']); // Default font is always "loaded"

        function loadSpecificFonts(fontNames) {
            if (!Array.isArray(fontNames) || fontNames.length === 0) {
                return Promise.resolve();
            }
            const fontsToLoad = fontNames.filter(f => !loadedFonts.has(f));
            if (fontsToLoad.length === 0) {
                return Promise.resolve();
            }
            const baseUrl = 'https://fonts.googleapis.com/css2?';
            const familyParams = fontsToLoad.map(font => `family=${font.replace(/ /g, '+')}`).join('&');
            const url = `${baseUrl}${familyParams}&display=swap`;

            return new Promise((resolve, reject) => {
                const link = document.createElement('link');
                link.href = url;
                link.rel = 'stylesheet';
                link.onload = () => {
                    fontsToLoad.forEach(f => loadedFonts.add(f));
                    resolve();
                };
                link.onerror = () => {
                    console.error('Failed to load specific fonts:', fontsToLoad);
                    reject(new Error(`Could not load fonts: ${fontsToLoad.join(', ')}`));
                };
                document.head.appendChild(link);
            });
        }
        
        function loadSecondaryFonts() {
            if (secondaryFontsLoaded) return;
            const allFontNames = availableFonts.map(f => f.name);
            loadSpecificFonts(allFontNames).then(() => {
                secondaryFontsLoaded = true;
            });
        }

        function injectNonCriticalStyles() {
            const nonCriticalCSS = `textarea#text-content, #font-select-trigger span {color:var(--ink)}.window{position:relative;background:var(--light);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s;border-radius:3px}.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:1px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}.titlebar-controls{display:flex;align-items:center;gap:8px}.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:1px solid var(--ink)}.controls-fake .btn-square:first-child{background-color:var(--success-color)}.controls-fake .btn-square:last-child{background-color:var(--danger-color)}#shortcuts-btn,#visuals-btn,#text-btn,#toggle-view-btn,#erase-tool-btn,#ai-tools-btn{font-family:inherit;font-size:1.1rem;background:var(--light);border:1px solid;border-color:var(--mid) var(--ink) var(--ink) var(--mid);padding:0 8px;cursor:pointer;transition:all .2s;color:var(--ink);border-radius:3px;transform:translateY(-1px)}#shortcuts-btn:hover,#visuals-btn:hover,#text-btn:hover,#toggle-view-btn:hover,#erase-tool-btn:hover,#ai-tools-btn:hover{transform:translateY(-2px);filter:brightness(1.1)}#shortcuts-btn:active,#visuals-btn:active,#text-btn:active,#toggle-view-btn:active,#erase-tool-btn:active,#ai-tools-btn:active,#erase-tool-btn.active{transform:translateY(0);border-color:var(--ink) var(--mid) var(--mid) var(--ink)}#toggle-view-btn{padding:0 4px;font-size:18px}#shortcuts-dropdown{right:8px}#shortcuts-dropdown.visible{display:block}#shortcuts-dropdown h5{margin:0 0 .5rem 0;font-size:1.25rem;text-align:center}#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}#shortcuts-dropdown li kbd{font-family:inherit;border:1px solid var(--ink);padding:0 4px;background:var(--bg)}#visuals-dropdown,#text-dropdown,#shortcuts-dropdown,#erase-tool-dropdown,#ai-tools-dropdown{display:none;position:absolute;top:28px;background:rgba(var(--light-rgb),.3);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:.5rem 1rem;z-index:100;width:250px;transition:background .2s,backdrop-filter .2s,box-shadow .2s,border-color .2s;border-radius:4px}#visuals-dropdown{right:382px}#erase-tool-dropdown{right:288px}#ai-tools-dropdown{right:198px}#text-dropdown{right:74px}#visuals-dropdown.visible,#text-dropdown.visible,#erase-tool-dropdown.visible,#ai-tools-dropdown.visible{display:block}#visuals-dropdown h5,#visuals-dropdown h6,#visuals-dropdown .slider-container,#text-dropdown h5,#text-dropdown h6,#text-dropdown .slider-container,#erase-tool-dropdown h5,#erase-tool-dropdown h6,#erase-tool-dropdown .eraser-mode-controls,#erase-tool-dropdown>.mg-btn,#ai-tools-dropdown h5{transition:opacity .2s}#visuals-dropdown h5,#text-dropdown h5,#erase-tool-dropdown h5,#ai-tools-dropdown h5{margin:0 0 .5rem 0;font-size:1.25rem;text-align:center}#visuals-dropdown h6,#text-dropdown h6,#erase-tool-dropdown h6{font-size:1.15rem;font-weight:700;text-align:left;margin-top:.5rem;margin-bottom:.5rem;border-bottom:1px solid var(--mid);padding-bottom:2px}#visuals-dropdown label,#text-dropdown label,#erase-tool-dropdown label{display:block;margin-top:.5rem;font-size:1rem}#visuals-dropdown.is-scrubbing,#text-dropdown.is-scrubbing,#erase-tool-dropdown.is-scrubbing{background:transparent;backdrop-filter:none;-webkit-backdrop-filter:none;box-shadow:none;border-color:transparent}#visuals-dropdown.is-scrubbing>h5,#visuals-dropdown.is-scrubbing #visuals-tabs,#visuals-dropdown.is-scrubbing>div>div>h6,#visuals-dropdown.is-scrubbing .slider-container:not(.is-active-slider){opacity:0;pointer-events:none}#text-dropdown.is-scrubbing>h5,#text-dropdown.is-scrubbing #text-layer-manager,#text-dropdown.is-scrubbing .slider-container:not(.is-active-slider){opacity:0;pointer-events:none}#erase-tool-dropdown.is-scrubbing>h5,#erase-tool-dropdown.is-scrubbing .eraser-mode-selector,#erase-tool-dropdown.is-scrubbing #eraser-controls-wrapper>.slider-container:not(.is-active-slider){opacity:0;pointer-events:none}#visuals-dropdown.is-scrubbing .slider-container.is-active-slider,#text-dropdown.is-scrubbing .slider-container.is-active-slider,#erase-tool-dropdown.is-scrubbing .slider-container.is-active-slider{opacity:1;pointer-events:auto;transition:opacity .1s}#visuals-dropdown input[type=range],#text-dropdown input[type=range],#erase-tool-dropdown input[type=range],#mg-eraser-hud input[type=range]{width:100%;-webkit-appearance:none;appearance:none;height:2px;background:var(--ink);outline:0}#visuals-dropdown input[type=range]::-webkit-slider-thumb,#text-dropdown input[type=range]::-webkit-slider-thumb,#erase-tool-dropdown input[type=range]::-webkit-slider-thumb,#mg-eraser-hud input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer}#visuals-dropdown input[type=range]::-moz-range-thumb,#text-dropdown input[type=range]::-moz-range-thumb,#erase-tool-dropdown input[type=range]::-moz-range-thumb,#mg-eraser-hud input[type=range]::-moz-range-thumb{width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer;border:none}#asset-visuals-controls.disabled,#text-visuals-controls.disabled,#eraser-controls-wrapper.disabled{opacity:.5;pointer-events:none}.mg-btn{font-family:inherit;font-size:18px;background:var(--light);border:1px solid;border-color:var(--mid) var(--ink) var(--ink) var(--mid);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:all .2s;transform:translateY(-2px);border-radius:3px}.mg-btn:hover{filter:brightness(1.1);transform:translateY(-3px)}.mg-btn:disabled,.mg-btn.disabled{opacity:.5;pointer-events:none;transform:none;border-color:var(--mid)}.mg-btn:active,.mg-btn.active{transform:translateY(0);border-color:var(--ink) var(--mid) var(--mid) var(--ink);background-color:var(--action-color);color:var(--light)}.mg-btn.success{background-color:var(--success-color)}.mg-btn.generate{background-color:var(--ink);color:var(--light)}.mg-btn.generate:active{background-color:var(--ink);color:var(--light)}.hidden{display:none!important}#studio-container{display:grid;grid-template-columns:320px 1fr;grid-template-rows:minmax(0,1fr);gap:1.5rem;padding:1.5rem;flex-grow:1;min-height:0}#controls-panel{display:flex;flex-direction:column;gap:1rem;overflow-y:auto;min-height:0}#canvas-panel{display:flex;align-items:center;justify-content:center;border:1px solid var(--ink);background-color:var(--mid);position:relative;min-height:0;transition:background-color .5s ease-in-out;overflow:hidden}#controls-panel fieldset{background:var(--light);border:1px solid var(--ink);padding:.8rem;margin:0;text-align:left;transition:background-color .3s,border-color .3s,color .3s,opacity .3s;border-radius:3px}#controls-panel legend{font-size:1.2rem;font-weight:400;padding:0 .5rem;margin-left:.5rem;background:var(--light)}.placeholder-text{color:var(--mid);font-size:1.1rem;text-align:center;padding:1rem;width:100%}body[data-theme-is-dark=true] #layer-instructions{color:var(--ink)}#mg-asset-palette,#mg-local-asset-palette,#mg-local-background-palette{display:flex;gap:.5rem;flex-wrap:wrap;min-height:70px;align-content:flex-start}.palette-slot,.layer-thumb{width:60px;height:60px;border:1px solid var(--ink);background:var(--light);cursor:pointer;position:relative;border-radius:3px;box-shadow:3px 3px 0 var(--ink);transform:translate(0,0);transition:transform .15s ease-out,box-shadow .15s ease-out}.palette-slot.empty{display:flex;align-items:center;justify-content:center;font-size:3rem;line-height:1;color:var(--mid)}.layer-thumb:hover,.palette-slot.empty:hover{transform:translate(-2px,-2px);box-shadow:5px 5px 0 var(--ink)}.layer-thumb.active{transform:translate(1px,1px);box-shadow:none;border:2px solid var(--action-color)}.layer-thumb{cursor:grab}.layer-thumb img{width:100%;height:100%;object-fit:cover;pointer-events:none}.layer-controls{position:absolute;top:-5px;right:-5px;display:flex;gap:2px}.layer-btn{background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:700;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center}#mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{position:absolute}#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{pointer-events:none}#mg-movie-canvas{pointer-events:auto}#mg-asset-picker-actions{display:none}#mg-local-asset-grid,#mg-local-asset-grid-assets,#mg-local-asset-grid-backgrounds{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:1rem;overflow-y:auto;padding:1rem;flex-grow:1}.mg-template{position:relative;aspect-ratio:1/1;border:1px solid var(--mid);background-color:var(--bg);box-shadow:3px 3px 0 var(--ink);transition:transform .15s ease-out,box-shadow .15s ease-out;border-radius:3px}.mg-template:hover{transform:translate(-2px,-2px) scale(1.03);box-shadow:5px 5px 0 var(--ink)}.mg-template img{display:block;width:100%;height:100%;object-fit:cover;cursor:pointer}.mg-template .layer-btn.delete{position:absolute;top:4px;right:4px;z-index:5;width:22px;height:22px;font-size:1rem;display:flex;align-items:center;justify-content:center;border-radius:2px}.mg-btn.tab{color:var(--ink);opacity:.7;background:transparent;box-shadow:1px 1px 0 var(--shadow);transform:translateY(0);transition:transform .1s ease,box-shadow .1s ease,background-color .2s,opacity .2s}.mg-btn.tab:hover{opacity:1;transform:translateY(-1px);box-shadow:1px 1px 0 var(--shadow)}.mg-btn.tab.active{background-color:var(--mid);opacity:1;transform:translateY(1px);box-shadow:0 0 0 var(--shadow)}#mg-toast{visibility:hidden;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--light);border:1px solid var(--ink);padding:.5rem 1rem;color:var(--ink);font-size:1rem;z-index:2000;box-shadow:2px 2px 0 var(--shadow)}#canvas-placeholder{position:absolute;width:calc(100% - 20px);height:calc(100% - 20px);border:2px dashed var(--mid);border-radius:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:pointer;color:var(--mid);transition:all .2s;padding:2rem;overflow:hidden;position:relative}#canvas-placeholder h3,#canvas-placeholder p{position:relative;z-index:2}#canvas-placeholder img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:1;opacity:.6}#canvas-placeholder h3{font-size:2.2rem;margin:0 0 .5rem}#canvas-placeholder p{font-size:1.3rem}#canvas-placeholder:hover,#canvas-panel.drag-over #canvas-placeholder{border-color:var(--ink);color:var(--ink);background-color:rgba(255,255,255,.5)}#canvas-panel.drag-over{background-color:var(--shadow)}#layer-instructions{padding:0 0 .5rem 0;margin:0;font-size:1.1rem}#mg-confirmation-overlay,#mg-asset-action-overlay{z-index:5000}#mg-confirmation-dialog,#mg-asset-action-dialog{padding:1.5rem;text-align:center;width:90%;max-width:400px;height:auto}#mg-confirmation-dialog p,#mg-asset-action-dialog p{font-size:1.2rem;margin:0 0 1.5rem}#mg-confirmation-dialog .action-buttons,#mg-asset-action-dialog .action-buttons{display:flex;justify-content:center;gap:.5rem}#text-content,#text-font{transition:background-color .3s,border-color .3s,color .3s}#text-layer-manager{display:flex;gap:.5rem;align-items:center;padding-bottom:.5rem;margin-bottom:.5rem;border-bottom:1px solid var(--mid)}#text-layer-palette{display:flex;gap:.5rem;flex-wrap:wrap;flex-grow:1;min-height:44px}#add-new-text-layer-btn{width:40px;height:40px;flex-shrink:0;font-size:2rem;line-height:1;padding:0}.text-thumb{width:60px;height:40px;display:flex;align-items:center;justify-content:center;overflow:hidden;background-color:var(--ink);color:var(--light);font-size:.8rem;padding:2px;text-align:center}.text-thumb span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;pointer-events:none}.palette-slot.empty:disabled{opacity:.4;cursor:default;pointer-events:none;background-color:var(--light)}.palette-slot.empty:disabled:hover{background-color:var(--light);color:var(--mid)}#shortcuts-btn:disabled,#visuals-btn:disabled,#text-btn:disabled,#erase-tool-btn:disabled,#ai-tools-btn:disabled{opacity:.5;pointer-events:none;cursor:default}.layer-thumb.dragging{opacity:.4;transform:rotate(-3deg) scale(1.05);box-shadow:0 8px 20px rgba(0,0,0,.3);cursor:grabbing}.layer-thumb.drag-over{border:3px dashed var(--action-color);transform:scale(1.02);background-color:rgba(var(--action-color-rgb),.1)}#mg-pasteboard-overlay-canvas{position:absolute;pointer-events:none;display:none}#canvas-panel.is-zoomed-out{background-color:var(--shadow)}#mg-movie-canvas,#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{transition:transform .3s ease-in-out,box-shadow .3s ease-in-out}#canvas-panel.is-zoomed-out #mg-movie-canvas,#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas,#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{transform:scale(.8);box-shadow:0 0 15px rgba(0,0,0,.5)}#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas{display:none}#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{display:block}#toggle-view-btn:disabled,#toggle-view-btn:disabled:hover{opacity:.5;pointer-events:none;cursor:default}.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}.effects-checkbox input{margin-right:.5rem}.effects-controls{padding-left:1.5rem;border-left:1px solid var(--mid);margin-left:.5rem}.effects-controls.disabled{opacity:.5;pointer-events:none}#erase-tool-btn.active{background-color:var(--action-color);color:var(--light)}#mg-movie-canvas.erase-cursor{cursor:none}#erase-tool-dropdown .mg-btn{margin-top:.5rem}.eraser-mode-selector{display:flex;gap:.5rem;margin-bottom:.5rem}.eraser-mode-selector .mg-btn{width:50%;margin:0;padding:4px 8px;font-size:16px}.eraser-mode-selector .mg-btn:active,.eraser-mode-selector .mg-btn.active{background-color:var(--action-color);color:var(--light);transform:none;box-shadow:inset 1px 1px 0 rgba(0,0,0,.2)}#mg-eraser-hud .mg-btn.active{background-color:var(--action-color);color:var(--light);transform:translateY(1px);box-shadow:none}#assets-folder-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem}#assets-folder-actions p{font-size:1.1rem;margin:0}#assets-folder-fieldset.disabled legend{color:var(--shadow)}#mg-eraser-zoom,#mg-eraser-hud{position:absolute;z-index:5;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .2s,visibility 0s .2s}#mg-eraser-zoom.visible,#mg-eraser-hud.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .2s,visibility 0s 0s}#mg-eraser-zoom{right:12px;bottom:12px;width:160px;height:160px;border:1px solid var(--ink);background:var(--light);box-shadow:2px 2px 0 var(--shadow)}#mg-eraser-hud{right:12px;bottom:184px;background:var(--light);border:1px solid var(--ink);padding:6px 8px;box-shadow:2px 2px 0 var(--shadow);z-index:6;transition:background .2s,border-color .2s,box-shadow .2s,opacity .2s,visibility 0s .2s}#mg-eraser-hud .row{display:flex;align-items:center;gap:.5rem;transition:opacity .2s}#mg-eraser-hud button{font-family:inherit;font-size:14px;background:transparent;color:var(--ink);border:1px solid var(--ink);padding:2px 8px;cursor:pointer;box-shadow:1px 1px 0 var(--shadow)}#mg-eraser-hud.is-scrubbing{background:transparent;border-color:transparent;box-shadow:none}#mg-eraser-hud.is-scrubbing .row:not(.is-active-slider){opacity:0;pointer-events:none}#mg-eraser-hud.is-scrubbing .row.is-active-slider{opacity:1;pointer-events:auto}footer{padding:.5rem 1.5rem;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;flex-wrap:wrap;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:none}.footer-links,.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}footer a{color:var(--ink);text-decoration:none;transition:opacity .2s;opacity:.7}footer a:hover{opacity:1}footer a i{margin-right:.5em}@media (max-width:980px){footer{justify-content:center}}#theme-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:7000}#theme-popup-content{background:var(--bg);border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);padding:1rem;width:90%;max-width:400px;max-height:80vh;display:flex;flex-direction:column;transition:background-color .3s}#theme-list{list-style:none;margin:0;padding:0;overflow-y:auto}#theme-list li{padding:.75rem 1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .2s;border-radius:4px}#theme-list li.active{background-color:var(--action-color);color:var(--light)}#theme-list li.active::before{content:'✓';margin-right:.5rem}#theme-list li:not(.active):hover{background-color:var(--mid)}.theme-colors{display:flex;gap:.5rem}.theme-color-dot{width:16px;height:16px;border-radius:50%;border:1px solid var(--ink)}#version-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.7);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:6000}#version-popup-content{background-color:var(--bg);padding:2rem;border:1px solid var(--ink);box-shadow:2px 2px 0 var(--shadow);width:80%;height:80%;max-width:800px;position:relative;color:var(--ink);overflow-y:auto}#version-popup-content h4{font-size:2rem;margin-bottom:.5rem}#version-popup-content h6{font-size:1rem;margin-top:0;opacity:.7;margin-bottom:1.5rem}#version-popup-content h5{font-size:1.5rem;margin-top:1.5rem;border-bottom:1px solid var(--mid);padding-bottom:.25rem}#version-popup-content ul{list-style:none;padding-left:0}#version-popup-content li{margin-bottom:.75rem;line-height:1.4}#close-popup{position:absolute;top:1rem;right:1.5rem;font-size:2rem;color:var(--ink);cursor:pointer;font-family:'VT323',monospace;line-height:1;transition:opacity .2s}#close-popup:hover{opacity:.6}#custom-font-select{position:relative}#font-select-trigger{background:var(--bg);border:1px solid var(--ink);padding:4px 8px;font-size:1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .3s,border-color .3s}#font-select-trigger:focus,#custom-font-select.open #font-select-trigger{border-color:var(--action-color)}#font-select-trigger span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}#font-select-trigger i{transition:transform .2s ease-in-out;font-size:.8em}#custom-font-select.open #font-select-trigger i{transform:rotate(180deg)}#font-select-dropdown{position:absolute;top:calc(100% + 2px);left:0;right:0;background:var(--light);border:1px solid var(--ink);z-index:101;max-height:250px;overflow-y:auto;box-shadow:2px 2px 0 var(--shadow)}#font-select-list{list-style:none;margin:0;padding:0}#font-select-list li{padding:6px 10px;cursor:pointer;transition:background-color .2s;white-space:nowrap;font-size:.9rem}#font-select-list li:hover,#font-select-list li.hover-preview{background-color:var(--mid)}#font-select-list li.selected{background-color:var(--action-color);color:var(--light)}`;
            const style = document.createElement('style');
            style.textContent = nonCriticalCSS;
            document.head.appendChild(style);
        }

        // --- THEME SELECTOR LOGIC (DEFERRED) ---
        const themes = {
            'classic light': { name: 'classic light', isDark: false, colors: ['#f2efe8', '#2b2b2b', '#d98c5f'], css: { '--bg': '#f2efe8', '--ink': '#2b2b2b', '--mid': '#c2c2c2', '--light': '#faf9f5', '--shadow': '#7a7a7a', '--action-color': '#2b2b2b', '--danger-color': '#cc4444', '--success-color': '#55cc55' } },
            'dark': { name: 'dark', isDark: true, colors: ['#1a1d2d', '#e0e5f0', '#e8a85a'], css: { '--bg': '#1a1d2d', '--ink': '#e0e5f0', '--mid': '#3d4a6e', '--light': '#252a40', '--shadow': '#0d0f16', '--action-color': '#1a1d2d', '--danger-color': '#a83e3e', '--success-color': '#4a9d4a' } },
            'イーピーイッピ': { name: 'イーピーイッピ', isDark: true, colors: ['#5c3d46', '#dcd0c0', '#a26769'], css: { '--bg': '#2a1d21', '--ink': '#dcd0c0', '--mid': '#5c3d46', '--light': '#402d32', '--shadow': '#1a1114', '--action-color': '#a26769', '--danger-color': '#a26769', '--success-color': '#69a267' } },
            'zarah': { name: 'zarah', isDark: false, colors: ['#7b9c98', '#eaf1f3', '#495555'], css: { '--bg': '#7b9c98', '--ink': '#eaf1f3', '--mid': '#495755', '--light': '#6c8985', '--shadow': '#3e4a48', '--action-color': '#eaf1f3' } },
            'lavender': { name: 'lavender', isDark: false, colors: ['#b3b3d9', '#282846', '#656599'], css: { '--bg': '#b3b3d9', '--ink': '#282846', '--mid': '#656599', '--light': '#c4c4e2', '--shadow': '#47476b', '--action-color': '#8c58a6' } },
            'café': { name: 'café', isDark: false, colors: ['#ceb18d', '#4e433f', '#d4d2d1'], css: { '--bg': '#ceb18d', '--ink': '#4e433f', '--mid': '#d4d2d1', '--light': '#f7f2ea', '--shadow': '#8a7a6a', '--action-color': '#8a6ea2' } },
            'mizu': { name: 'mizu', isDark: false, colors: ['#b8dceb', '#091f2c', '#89a5bb'], css: { '--bg': '#b8dceb', '--ink': '#091f2c', '--mid': '#89a5bb', '--light': '#cfe5ee', '--shadow': '#627382', '--action-color': '#005a8e' } },
            'キティ': { name: 'キティ', isDark: false, colors: ['#fdf6e3', '#657b83', '#93a1a1'], css: { '--bg': '#fdf6e3', '--ink': '#657b83', '--mid': '#93a1a1', '--light': '#eee8d5', '--shadow': '#586e75', '--action-color': '#268bd2' } },
            'aura': { name: 'aura', isDark: true, colors: ['#29423D', '#EAE8E1', '#C9A59C'], css: { '--bg': '#1A2A27', '--ink': '#EAE8E1', '--mid': '#3E5D56', '--light': '#29423D', '--shadow': '#111C19', '--action-color': '#C9A59C', '--danger-color': '#b05454', '--success-color': '#5a9e7a' } },
        };
        
        const themePopupOverlay = document.getElementById('theme-popup-overlay');
        const themePopupContent = document.getElementById('theme-popup-content');
        const themeList = document.getElementById('theme-list');
        const themeSelectLink = document.getElementById('theme-select-link');
        const currentThemeNameSpan = document.getElementById('current-theme-name');
        let originalTheme = 'classic light';
        let themeChosen = false;
        
        // --- Variable Declarations ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessage = loadingOverlay.querySelector('h1');
        const addLayerOverlay = document.getElementById('mg-asset-library-overlay');
        const assetPalette = document.getElementById('mg-asset-palette');
        const addLayerFileInput = document.getElementById('mg-asset-picker-file');
        const canvasPanel = document.getElementById('canvas-panel');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const controlsOverlayCanvas = document.getElementById('mg-controls-overlay-canvas');
        const controlsCtx = controlsOverlayCanvas.getContext('2d');
        const pasteboardOverlayCanvas = document.getElementById('mg-pasteboard-overlay-canvas');
        const pasteboardCtx = pasteboardOverlayCanvas.getContext('2d');
        const PASTEBOARD_MARGIN = 1500;
        const initialBackgroundInput = document.getElementById('initial-background-input');
        const layerInstructions = document.getElementById('layer-instructions');
        const movieCanvas = document.getElementById('mg-movie-canvas');
        const movieCtx = movieCanvas.getContext('2d');
        const downloadImageBtn = document.getElementById('mg-download-image-btn');
        const saveProjectBtn = document.getElementById('mg-save-project-btn');
        const clearCanvasBtn = document.getElementById('mg-clear-canvas-btn');
        const confirmationOverlay = document.getElementById('mg-confirmation-overlay');
        const confirmationText = document.getElementById('mg-confirmation-text');
        const confirmYesBtn = document.getElementById('mg-confirm-yes-btn');
        const confirmNoBtn = document.getElementById('mg-confirm-no-btn');
        const shortcutsBtn = document.getElementById('shortcuts-btn');
        const shortcutsDropdown = document.getElementById('shortcuts-dropdown');
        const visualsBtn = document.getElementById('visuals-btn');
        const visualsDropdown = document.getElementById('visuals-dropdown');
        const assetVisualsControls = document.getElementById('asset-visuals-controls');
        const assetOpacitySlider = document.getElementById('asset-opacity');
        const assetBrightnessSlider = document.getElementById('asset-brightness');
        const assetSaturationSlider = document.getElementById('asset-saturation');
        const bgBrightnessSlider = document.getElementById('bg-brightness');
        const bgSaturationSlider = document.getElementById('bg-saturation');
        const textBtn = document.getElementById('text-btn');
        const textDropdown = document.getElementById('text-dropdown');
        const textVisualsControls = document.getElementById('text-visuals-controls');
        const textContentInput = document.getElementById('text-content');
        const textSizeSlider = document.getElementById('text-size');
        const textColorInput = document.getElementById('text-color');
        const textEdgeColorInput = document.getElementById('text-edge-color');
        const textEdgeWidthSlider = document.getElementById('text-edge-width');
        const addNewTextLayerBtn = document.getElementById('add-new-text-layer-btn');
        const textLayerPalette = document.getElementById('text-layer-palette');
        const toggleViewBtn = document.getElementById('toggle-view-btn');
        const eraseToolBtn = document.getElementById('erase-tool-btn');
        const eraseToolDropdown = document.getElementById('erase-tool-dropdown');
        const eraseBtn = document.getElementById('erase-btn');
        const uneraseBtn = document.getElementById('unerase-btn');
        const aiToolsBtn = document.getElementById('ai-tools-btn');
        const aiToolsDropdown = document.getElementById('ai-tools-dropdown');

        // --- PROJECT LIBRARY VARIABLE DECLARATIONS (RESTORED & NEW) ---
        const assetsFolderFieldset = document.getElementById('assets-folder-fieldset');
        const localAssetPalette = document.getElementById('mg-local-asset-palette');
        const localBackgroundPalette = document.getElementById('mg-local-background-palette');
        const viewAllLocalAssetsBtn = document.getElementById('mg-view-all-local-assets-btn');
        const projectLibraryPopupOverlay = document.getElementById('project-library-popup-overlay');
        const projectLibraryGridProjects = document.getElementById('project-library-grid-projects');
        const projectLibraryGridAssets = document.getElementById('project-library-grid-assets');
        const projectLibraryGridBackgrounds = document.getElementById('project-library-grid-backgrounds');
        const projectLibraryGridFavorites = document.getElementById('project-library-grid-favorites');
        const libraryTabProjectsBtn = document.getElementById('library-tab-projects');
        const libraryTabAssetsBtn = document.getElementById('library-tab-assets');
        const libraryTabBackgroundsBtn = document.getElementById('library-tab-backgrounds');
        const libraryTabFavoritesBtn = document.getElementById('library-tab-favorites');
        const projectLibraryPopupCloseBtn = document.getElementById('project-library-popup-close');
        
        const visualsTabAssetBtn = document.getElementById('visuals-tab-asset');
        const visualsTabBackgroundBtn = document.getElementById('visuals-tab-background');
        const assetTabPanel = document.getElementById('asset-tab-panel');
        const backgroundTabPanel = document.getElementById('background-tab-panel');

        const customFontSelect = document.getElementById('custom-font-select');
        const fontSelectTrigger = document.getElementById('font-select-trigger');
        const fontSelectDropdown = document.getElementById('font-select-dropdown');
        const fontSelectList = document.getElementById('font-select-list');
        let originalFontOnHover = null;
        const availableFonts = [
            { name: 'VT323', value: "'VT323', monospace" },
            { name: 'Yomogi', value: "'Yomogi', cursive" },
            { name: 'Young Serif', value: "'Young Serif', serif" },
            { name: 'Times New Roman', value: "Times New Roman, serif" },
            { name: 'Special Elite', value: "'Special Elite', cursive" },
            { name: 'Rubik Mono One', value: "'Rubik Mono One', sans-serif" },
            { name: 'Rubik Beastly', value: "'Rubik Beastly', cursive" },
            { name: 'Press Start 2P', value: "'Press Start 2P', cursive", style: "font-size: 0.6rem;" },
            { name: 'Patua One', value: "'Patua One', cursive" },
            { name: 'Nosifer', value: "'Nosifer', cursive" },
            { name: 'Monoton', value: "'Monoton', cursive" },
            { name: 'Modak', value: "'Modak', cursive" },
            { name: 'Metal Mania', value: "'Metal Mania', cursive" },
            { name: 'Major Mono Display', value: "'Major Mono Display', monospace", style: "font-size: 0.8rem;" },
            { name: 'Luckiest Guy', value: "'Luckiest Guy', cursive" },
            { name: 'Londrina Outline', value: "'Londrina Outline', cursive" },
            { name: 'Joti One', value: "'Joti One', cursive" },
            { name: 'Impact', value: "Impact, fantasy" },
            { name: 'Gorditas', value: "'Gorditas', cursive" },
            { name: 'Graduate', value: "'Graduate', cursive" },
            { name: 'Gloria Hallelujah', value: "'Gloria Hallelujah', cursive" },
            { name: 'Frijole', value: "'Frijole', cursive" },
            { name: 'Erica One', value: "'Erica One', cursive" },
            { name: 'Eater', value: "'Eater', cursive" },
            { name: 'Dokdo', value: "'Dokdo', cursive" },
            { name: 'Cute Font', value: "'Cute Font', cursive" },
            { name: 'Courier New', value: "Courier New, monospace" },
            { name: 'Creepster', value: "'Creepster', cursive" },
            { name: 'Codystar', value: "'Codystar', cursive" },
            { name: 'Comic Sans MS', value: "Comic Sans MS, cursive" },
            { name: 'Barrio', value: "'Barrio', cursive" },
            { name: 'Bahiana', value: "'Bahiana', cursive" },
            { name: 'Astloch', value: "'Astloch', cursive" },
            { name: 'Are You Serious', value: "'Are You Serious', cursive" }
        ];
        const fontValueToNameMap = new Map();
        availableFonts.forEach(font => fontValueToNameMap.set(font.value, font.name));

        const UI_MIN_PX = 120, UI_MAX_PX = 220, TARGET_RADIUS_PX = 34, MIN_MARGIN_PREVIEW = 12, MIN_ZOOM_FEEL = 1.08, BRUSH_MIN = 5, BRUSH_MAX = 250;
        let lastEraseCanvasPoint = null;

        const eraserZoomCanvas = document.getElementById('mg-eraser-zoom');
        const eraserZoomCtx = eraserZoomCanvas.getContext('2d');
        const eraserHud = document.getElementById('mg-eraser-hud');
        const hudEraseBtn = document.getElementById('mg-hud-erase-btn');
        const hudUneraseBtn = document.getElementById('mg-hud-unerase-btn');
        const eraserSizeSlider = document.getElementById('mg-eraser-size-mini');
        const eraserStrengthSlider = document.getElementById('mg-eraser-strength-mini');
        const eraserSizeDropdown = document.getElementById('eraser-size-dropdown');
        const eraserStrengthDropdown = document.getElementById('eraser-strength-dropdown');
        
        let toastTimeout;
        let toastAnimationInterval = null;
        const toastEl = document.getElementById('mg-toast');
        
        let canvasState = { currentProjectId: null, backgroundElement: null, backgroundType: 'none', backgroundHash: null, bgBrightness: 1, bgSaturation: 1, layers: [] };

        const assetCache = {};
        let activeLayerId = null;
        let movieInteraction = { active: false };
        let animationFrameId = null;
        const FADE_IN_DURATION = 300;
        let isAnimatingRender = false;
        let masterWidth = 0, masterHeight = 0;
        let isCanvasViewZoomedOut = false;
        let eraserMode = 'none', isEraserArmed = false;
        let eraseBrushPos = { x: 0, y: 0 };
        
        const getActiveLayer = () => canvasState.layers.find(l => l.id === activeLayerId);

        function applyTheme(themeName, isPreview = false) {
            const theme = themes[themeName];
            if (!theme) return;
            const root = document.documentElement;
            if (isPreview) { root.style.transition = 'none'; }
            for (const [key, value] of Object.entries(theme.css)) {
                root.style.setProperty(key, value);
                if (key === '--light') root.style.setProperty('--light-rgb', hexToRgb(value));
                if (key === '--bg') root.style.setProperty('--bg-rgb', hexToRgb(value));
                if (key === '--action-color') root.style.setProperty('--action-color-rgb', hexToRgb(value));
            }
            document.body.dataset.themeIsDark = theme.isDark;
            document.body.dataset.themeName = themeName;
            if (isPreview) { void root.offsetWidth; root.style.transition = ''; }
        }

        function hexToRgb(hex) {
            let r=0,g=0,b=0;
            if(hex.length==4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16)}
            else if(hex.length==7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16)}
            return `${r},${g},${b}`;
        }

        function saveAndApplyTheme(themeName) {
            themeChosen = true;
            applyTheme(themeName);
            localStorage.setItem('selectedTheme', themeName);
            originalTheme = themeName;
            currentThemeNameSpan.textContent = themeName;
            const currentActive = themeList.querySelector('.active');
            if (currentActive) currentActive.classList.remove('active');
            const newActive = themeList.querySelector(`[data-theme-name="${themeName}"]`);
            if (newActive) newActive.classList.add('active');
            themePopupOverlay.style.display = 'none';
        }

        function populateThemeList() {
            themeList.innerHTML = '';
            const currentTheme = localStorage.getItem('selectedTheme') || 'classic light';
            for (const themeName in themes) {
                const theme = themes[themeName];
                const li = document.createElement('li');
                li.dataset.themeName = themeName;
                if(themeName === currentTheme) li.classList.add('active');
                let content = `<span>${theme.name}</span>`;
                let colorDots = '<div class="theme-colors">';
                theme.colors.forEach(color => { colorDots += `<div class="theme-color-dot" style="background-color: ${color};"></div>`; });
                colorDots += '</div>';
                li.innerHTML = content + colorDots;
                li.addEventListener('click', () => saveAndApplyTheme(themeName));
                li.addEventListener('mouseenter', () => applyTheme(themeName, true));
                themeList.appendChild(li);
            }
        }
        
        const savedTheme = localStorage.getItem('selectedTheme') || 'classic light';
        originalTheme = savedTheme;
        applyTheme(savedTheme);
        currentThemeNameSpan.textContent = savedTheme;
        
        function showLoadingScreen(message = 'Loading...') {
            loadingMessage.textContent = message;
            loadingOverlay.style.display = 'flex';
            void loadingOverlay.offsetWidth; 
            loadingOverlay.style.opacity = '1';
        }

        function hideLoadingScreen() {
            loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
            }, 500);
        }

        // --- APP LOGIC ---
        function toast(message, duration = 3000) {
            if (!toastEl) return;
            clearTimeout(toastTimeout);
            clearInterval(toastAnimationInterval);
            toastEl.textContent = message;
            toastEl.style.visibility = 'visible';

            if (duration === null) {
                // Indefinite toast, no animation. Will be hidden by hideToast().
            } else {
                toastTimeout = setTimeout(() => {
                    toastEl.style.visibility = 'hidden';
                    clearInterval(toastAnimationInterval);
                }, duration);
            }
        }

        function hideToast() {
            if (!toastEl) return;
            clearTimeout(toastTimeout);
            clearInterval(toastAnimationInterval);
            toastEl.style.visibility = 'hidden';
        }

        async function sha256Hex(blob) {
            const buf = await blob.arrayBuffer();
            const digest = await crypto.subtle.digest('SHA-256', buf);
            const bytes = new Uint8Array(digest);
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function idbOpen(dbName = 'ims-db') {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(dbName, 5); // DB version incremented for new index
                req.onupgradeneeded = (e) => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('assets')) {
                        const assetsStore = db.createObjectStore('assets', { keyPath: 'id', autoIncrement: true });
                        assetsStore.createIndex('createdAt', 'createdAt');
                        assetsStore.createIndex('hash', 'hash', { unique: false });
                        assetsStore.createIndex('kind', 'kind', { unique: false });
                    }
                     if (!db.objectStoreNames.contains('projects')) {
                        const projectsStore = db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
                        projectsStore.createIndex('createdAt', 'createdAt');
                    }
                    if (e.oldVersion < 5) {
                        const assetsStore = req.transaction.objectStore('assets');
                        if (!assetsStore.indexNames.contains('isFavorite')) {
                            assetsStore.createIndex('isFavorite', 'isFavorite');
                        }
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function idbGet(id, storeName) {
            const db = await idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function idbPut(record, storeName) {
            const db = await idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                const req = tx.objectStore(storeName).put(record);
                req.onsuccess = () => { if (record.id == null) record.id = req.result; };
                tx.oncomplete = () => resolve(record);
                tx.onerror = () => reject(tx.error);
            });
        }

        async function idbGetAll(storeName) {
            const db = await idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readonly');
                const req = tx.objectStore(storeName).getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function idbDelete(id, storeName) {
            const db = await idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                tx.objectStore(storeName).delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }
        
        async function idbFindByHash(hash) {
            const db = await idbOpen();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('assets', 'readonly');
                const os = tx.objectStore('assets');
                const idx = os.index('hash');
                const req = idx.getAll(hash);
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
            });
        }

        async function dedupeExistingAssetsByHashKeepNewest() {
            const all = await idbGetAll('assets');
            for (const rec of all) {
                if (!rec.hash && rec.full) {
                    try {
                        if (!(rec.full instanceof Blob)) { throw new Error("Asset data is not a valid Blob."); }
                        rec.hash = await sha256Hex(rec.full);
                        await idbPut(rec, 'assets');
                    } catch (error) {
                        console.error(`A corrupted or invalid asset record (ID: ${rec.id}) was detected and will be deleted.`, { record: rec, error: error });
                        if (rec.id) { await idbDelete(rec.id, 'assets'); }
                    }
                }
            }
            const byHash = new Map();
            const cleanAssets = await idbGetAll('assets'); 
            for (const rec of cleanAssets) {
                if (!rec.hash) continue;
                const best = byHash.get(rec.hash);
                if (!best || rec.createdAt > best.createdAt) {
                    byHash.set(rec.hash, rec);
                }
            }
            for (const rec of cleanAssets) {
                if (rec.hash && byHash.has(rec.hash) && byHash.get(rec.hash).id !== rec.id) {
                    await idbDelete(rec.id, 'assets');
                }
            }
            await renderLocalAssetPalette_IDB();
            await renderLocalBackgroundPalette_IDB();
        }

        async function toBlobFromDataURL(dataURL) { const res = await fetch(dataURL); return await res.blob(); }

        async function createThumbBlob(imgBlob, max = 256, type = 'image/webp', quality = 0.8) {
            try {
                const bmp = await createImageBitmap(imgBlob);
                const scale = Math.min(max / bmp.width, max / bmp.height, 1);
                const w = Math.round(bmp.width * scale);
                const h = Math.round(bmp.height * scale);
                const c = new OffscreenCanvas(w, h);
                c.getContext('2d').drawImage(bmp, 0, 0, w, h);
                return await c.convertToBlob({ type, quality });
            } catch (e) {
                console.error("Could not create thumbnail from blob, possibly a non-image type.", e);
                return await (await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAmMBb3eGmC0AAAAASUVORK5CYII=')).blob();
            }
        }
        
        async function saveAssetToLibrary({ dataURL, mime = 'image/png', kind = 'asset' }) {
            const fullBlob = await toBlobFromDataURL(dataURL);
            const hash = await sha256Hex(fullBlob);
            const existingAssets = await idbFindByHash(hash);
            const existingAssetOfSameKind = existingAssets.find(a => a.kind === kind);

            const thumbBlob = await createThumbBlob(fullBlob);
            const record = {
                full: fullBlob,
                thumb: thumbBlob,
                mime,
                createdAt: Date.now(),
                hash,
                kind,
                isFavorite: existingAssetOfSameKind ? existingAssetOfSameKind.isFavorite : false
            };

            if (existingAssetOfSameKind) {
                record.id = existingAssetOfSameKind.id;
            }

            await idbPut(record, 'assets');
            await enforceQuota(80 * 1024 * 1024);
            await renderLocalAssetPalette_IDB();
            await renderLocalBackgroundPalette_IDB();
            if (projectLibraryPopupOverlay.classList.contains('visible')) {
                await populateProjectLibraryPopup();
            }
            return hash;
        }
        
        async function enforceQuota(limitBytes) {
            const assets = await idbGetAll('assets');
            let totalBytes = assets.reduce((sum, r) => sum + (r.full?.size || 0) + (r.thumb?.size || 0), 0);
            if (totalBytes <= limitBytes) return;

            const nonFavorites = assets.filter(a => !a.isFavorite);
            nonFavorites.sort((a, b) => a.createdAt - b.createdAt);
            
            for (const rec of nonFavorites) {
                if (totalBytes <= limitBytes) break;
                await idbDelete(rec.id, 'assets');
                totalBytes -= (rec.full?.size || 0) + (r.thumb?.size || 0);
                toast('Oldest non-favorite asset removed to free space.', 3000);
            }
        }
        
        async function deleteAssetFromLibrary(assetId) {
            try {
                const idNum = typeof assetId === 'string' ? Number(assetId) : assetId;
                if (!Number.isFinite(idNum)) throw new Error(`Invalid asset id: ${assetId}`);
                await idbDelete(idNum, 'assets');
                toast('Asset removed from folder.', 1500);
                await renderLocalAssetPalette_IDB();
                await renderLocalBackgroundPalette_IDB();
                if (projectLibraryPopupOverlay.classList.contains('visible')) { await populateProjectLibraryPopup(); }
            } catch (error) {
                console.error("Failed to delete asset:", error);
                toast("Error: Could not delete asset.", 4000);
            }
        }

        async function renderLocalAssetPalette_IDB() {
            const all = await idbGetAll('assets');
            const assetsOnly = all.map(r => ({ ...r, kind: r.kind || 'asset' })).filter(r => r.kind === 'asset').sort((a, b) => b.createdAt - a.createdAt);
            localAssetPalette.innerHTML = '';
            const toShow = assetsOnly.slice(0, 4);
            for (const asset of toShow) {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.title = "Add asset as a new layer";
                const thumbUrl = URL.createObjectURL(asset.thumb);
                const img = new Image();
                img.src = thumbUrl;
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                thumb.appendChild(img);
                thumb.addEventListener('click', () => {
                    if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); return; }
                    addImageLayer(URL.createObjectURL(asset.full), asset.hash);
                });
                localAssetPalette.appendChild(thumb);
            }
            if (assetsOnly.length === 0) { localAssetPalette.innerHTML = `<p class="placeholder-text" style="padding:0;line-height:1.2;">Your recent assets will appear here.</p>`; }
        }

        async function renderLocalBackgroundPalette_IDB() {
            const all = await idbGetAll('assets');
            const backgroundsOnly = all.filter(r => (r.kind || 'asset') === 'background').sort((a, b) => b.createdAt - a.createdAt);
            
            localBackgroundPalette.innerHTML = '';
            
            const toShow = backgroundsOnly.slice(0, 3);
            
            for (const bg of toShow) {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.title = "Set as background";
                
                const thumbUrl = URL.createObjectURL(bg.thumb);
                const img = new Image();
                img.src = thumbUrl;
                img.onload = () => URL.revokeObjectURL(thumbUrl);
                thumb.appendChild(img);
                
                thumb.addEventListener('click', () => {
                    const fullUrl = URL.createObjectURL(bg.full);
                    const fullImage = new Image();
                    fullImage.onload = () => {
                        setBackground(fullImage, bg.hash);
                        URL.revokeObjectURL(fullUrl);
                    };
                    fullImage.onerror = () => {
                        toast('Error loading this background.');
                        URL.revokeObjectURL(fullUrl);
                    }
                    fullImage.src = fullUrl;
                });
                
                localBackgroundPalette.appendChild(thumb);
            }
            
            const addBgBtn = document.createElement('button');
            addBgBtn.className = 'palette-slot empty';
            addBgBtn.innerHTML = '+';
            addBgBtn.title = "Add or change background";
            addBgBtn.addEventListener('click', () => initialBackgroundInput.click());
            localBackgroundPalette.appendChild(addBgBtn);
        }

        function setLocalFolderTab(tab) {
            const isProjects = tab === 'projects';
            const isAssets = tab === 'assets';
            const isBackgrounds = tab === 'backgrounds';
            const isFavorites = tab === 'favorites';

            libraryTabProjectsBtn.classList.toggle('active', isProjects);
            libraryTabAssetsBtn.classList.toggle('active', isAssets);
            libraryTabBackgroundsBtn.classList.toggle('active', isBackgrounds);
            libraryTabFavoritesBtn.classList.toggle('active', isFavorites);

            projectLibraryGridProjects.classList.toggle('hidden', !isProjects);
            projectLibraryGridAssets.classList.toggle('hidden', !isAssets);
            projectLibraryGridBackgrounds.classList.toggle('hidden', !isBackgrounds);
            projectLibraryGridFavorites.classList.toggle('hidden', !isFavorites);
        }

        function switchAndSaveLibraryTab(tabId) {
            setLocalFolderTab(tabId);
            localStorage.setItem('ims-last-library-tab', tabId);
        }
        
        async function deleteProjectFromLibrary(projectId) {
            await idbDelete(projectId, 'projects');
            toast('Project deleted from library.', 2000);
            await populateProjectLibraryPopup();
        }
        
                async function loadProjectFromLibrary(projectId) {
            showLoadingScreen('Loading Project');
            
            // This now sets a guaranteed minimum display time of 2 seconds (2000ms).
            const minDisplayTime = new Promise(resolve => setTimeout(resolve, 2400));

            const loadingPromise = (async () => {
                const projectRecord = await idbGet(projectId, 'projects');
                if (!projectRecord) {
                    throw new Error("Project not found.");
                }
                projectRecord.projectState.currentProjectId = projectId;
                await restoreProjectState(projectRecord.projectState);
            })();

            try {
                // Wait for both the loading to finish AND the 2-second minimum time to pass.
                await Promise.all([minDisplayTime, loadingPromise]);
                
                projectLibraryPopupOverlay.classList.remove('visible');
                toast("Project loaded.", 2000);
            } catch (e) {
                console.error("Failed to load project from library:", e);
                toast(`Error: Could not load project. ${e.message}`, 4000);
            } finally {
                hideLoadingScreen();
            }
        }
        async function populateProjectLibraryPopup() {
            const allAssets = await idbGetAll('assets');
            const createAssetGridItem = async (rec, onClick, context = 'recents') => {
                const item = document.createElement('div');
                item.className = 'library-grid-item';
                item.dataset.assetId = String(rec.id);
                
                const content = document.createElement('div');
                const thumbUrl = URL.createObjectURL(rec.thumb);
                content.innerHTML = `<img src="${thumbUrl}" alt="${rec.kind}">`;
                content.addEventListener('click', () => { onClick(rec); projectLibraryPopupOverlay.classList.remove('visible'); });

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                
                const favoriteBtn = document.createElement('button');
                favoriteBtn.className = 'favorite-btn';
                favoriteBtn.classList.toggle('is-favorite', !!rec.isFavorite);
                favoriteBtn.title = rec.isFavorite ? 'Remove from favorites' : 'Add to favorites';
                
                if (context === 'favorites') {
                    deleteBtn.style.display = 'none';
                    favoriteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openConfirmationModal('Remove this from your favorites?', async () => {
                           const assetToUpdate = await idbGet(rec.id, 'assets');
                           assetToUpdate.isFavorite = false;
                           await idbPut(assetToUpdate, 'assets');
                           toast('Removed from favorites.', 2000);
                           await populateProjectLibraryPopup();
                           closeConfirmationModal();
                        });
                    });
                } else { // 'recents' context
                    deleteBtn.title = `Permanently delete from storage`;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openConfirmationModal('Permanently delete this item?', async () => {
                            await deleteAssetFromLibrary(rec.id);
                            closeConfirmationModal();
                        });
                    });
                    favoriteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const assetToUpdate = await idbGet(rec.id, 'assets');
                        assetToUpdate.isFavorite = !assetToUpdate.isFavorite;
                        await idbPut(assetToUpdate, 'assets');
                        await populateProjectLibraryPopup();
                        if (assetToUpdate.isFavorite) {
                            toast(`${assetToUpdate.kind.charAt(0).toUpperCase() + assetToUpdate.kind.slice(1)} added to favorites!`, 2000);
                        } else {
                            toast('Removed from favorites.', 2000);
                        }
                    });
                }

                item.appendChild(content);
                item.appendChild(deleteBtn);
                item.appendChild(favoriteBtn);
                return item;
            };

            const assets = allAssets.filter(r => (r.kind || 'asset') === 'asset').sort((a,b) => b.createdAt - a.createdAt);
            const bgs = allAssets.filter(r => r.kind === 'background').sort((a,b) => b.createdAt - a.createdAt);
            const favoriteAssets = allAssets.filter(r => r.isFavorite && (r.kind || 'asset') === 'asset').sort((a,b) => b.createdAt - a.createdAt);
            const favoriteBgs = allAssets.filter(r => r.isFavorite && r.kind === 'background').sort((a,b) => b.createdAt - a.createdAt);

            // Populate Assets
            projectLibraryGridAssets.innerHTML = '<h5>Recent Assets</h5>';
            if (assets.length === 0) {
                projectLibraryGridAssets.insertAdjacentHTML('beforeend', `<p class="placeholder-text">No recent assets.</p>`);
            } else {
                for (const rec of assets) projectLibraryGridAssets.appendChild(await createAssetGridItem(rec, r => {
                    if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); return; }
                    addImageLayer(URL.createObjectURL(r.full), r.hash);
                }));
            }

            // Populate Backgrounds
            projectLibraryGridBackgrounds.innerHTML = '<h5>Recent Backgrounds</h5>';
            if (bgs.length === 0) {
                 projectLibraryGridBackgrounds.insertAdjacentHTML('beforeend', `<p class="placeholder-text">No recent backgrounds.</p>`);
            } else {
                 for(const rec of bgs) projectLibraryGridBackgrounds.appendChild(await createAssetGridItem(rec, r => {
                    const fullUrl = URL.createObjectURL(r.full);
                    const imgEl = new Image();
                    imgEl.onload = () => { setBackground(imgEl, r.hash); URL.revokeObjectURL(fullUrl); };
                    imgEl.onerror = () => { URL.revokeObjectURL(fullUrl); toast('Could not load background image.', 3000); };
                    imgEl.src = fullUrl;
                }));
            }

            // Populate Favorites
            projectLibraryGridFavorites.innerHTML = '';
             if (favoriteAssets.length > 0) {
                 projectLibraryGridFavorites.insertAdjacentHTML('beforeend', '<h5>Favorite Assets</h5>');
                 for(const rec of favoriteAssets) projectLibraryGridFavorites.appendChild(await createAssetGridItem(rec, r => {
                    if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); return; }
                    addImageLayer(URL.createObjectURL(r.full), r.hash);
                }, 'favorites'));
            }
            if (favoriteBgs.length > 0) {
                 projectLibraryGridFavorites.insertAdjacentHTML('beforeend', '<h5>Favorite Backgrounds</h5>');
                 for(const rec of favoriteBgs) projectLibraryGridFavorites.appendChild(await createAssetGridItem(rec, r => {
                    const fullUrl = URL.createObjectURL(r.full);
                    const imgEl = new Image();
                    imgEl.onload = () => { setBackground(imgEl, r.hash); URL.revokeObjectURL(fullUrl); };
                    imgEl.onerror = () => { URL.revokeObjectURL(fullUrl); toast('Could not load background image.', 3000); };
                    imgEl.src = fullUrl;
                }, 'favorites'));
            }
            if (favoriteAssets.length === 0 && favoriteBgs.length === 0) {
                projectLibraryGridFavorites.innerHTML = `<p class="placeholder-text">Star an asset or background to save it here.</p>`;
            }

            // Populate Projects
            const allProjects = await idbGetAll('projects');
            projectLibraryGridProjects.innerHTML = '<h5>Saved Projects</h5>';
            if (allProjects.length === 0) {
                 projectLibraryGridProjects.insertAdjacentHTML('beforeend', `<p class="placeholder-text">No saved projects.</p>`);
            } else {
                allProjects.sort((a, b) => b.createdAt - a.createdAt).forEach(rec => {
                    const item = document.createElement('div');
                    item.className = 'library-grid-item';
                    item.dataset.projectId = String(rec.id);
                    const content = document.createElement('div');
                    const thumbUrl = URL.createObjectURL(rec.thumbnail);
                    content.innerHTML = `<img src="${thumbUrl}" alt="Saved Project">`;
                    content.addEventListener('click', () => loadProjectFromLibrary(rec.id));

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = `Delete project`;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openConfirmationModal('Permanently delete this project?', async () => {
                            await deleteProjectFromLibrary(rec.id);
                            closeConfirmationModal();
                        });
                    });

                    item.appendChild(content);
                    item.appendChild(deleteBtn);
                    projectLibraryGridProjects.appendChild(item);
                });
            }
        }


        async function handleBackgroundUpload(file) {
            if (!file || !file.type.startsWith('image/')) { toast('Unsupported file type for background. Please use an image.'); return; }
            const reader = new FileReader();
            reader.onload = async (e) => {
                const dataURL = e.target.result;
                const hash = await saveAssetToLibrary({ dataURL, kind: 'background' });
                const img = new Image();
                img.onload = () => { setBackground(img, hash); };
                img.onerror = () => toast('Could not load background image.');
                img.src = dataURL;
            };
            reader.readAsDataURL(file);
        }
        
        async function processUploadedFile(file) {
            if (!file || !['image/png', 'image/jpeg'].includes(file.type)) {
                toast('Unsupported file type. Please use PNG, JPG, or JPEG.', 3000);
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                const dataURL = e.target.result;
                const hash = await saveAssetToLibrary({ dataURL, kind: 'asset' });
                addImageLayer(dataURL, hash);
                closeAddLayerPopup();
            };
            reader.readAsDataURL(file);
        }
        
        async function handleNewAsset(src, hash) {
            if (!canvasState.backgroundElement) { toast('Please set a background before adding layers.', 2000); return; }
            if (!src.startsWith('blob:')) { hash = await saveAssetToLibrary({ dataURL: src, kind: 'asset' }); }
            addImageLayer(src, hash);
        }
        
        function addImageLayer(src, hash) {
            if (!canvasState.backgroundElement) { toast('Please add a background image first.', 2000); return; }
            const createFromImage = (img) => {
                const w = img.naturalWidth || 0;
                const h = img.naturalHeight || 0;
                if (!w || !h) { img.addEventListener('load', () => createFromImage(img), { once: true }); return; }
                const proxyCanvas = document.createElement('canvas');
                proxyCanvas.width = w;
                proxyCanvas.height = h;
                proxyCanvas.getContext('2d').drawImage(img, 0, 0);
                const newSize = Math.max(20, Math.min(movieCanvas.width, movieCanvas.height) * 0.4);
                const newLayer = { id: (Date.now() + Math.random()).toString(), src, hash, asset: img, type: 'image', x: movieCanvas.width / 2, y: movieCanvas.height / 2, size: newSize, rot: 0, flipX: false, opacity: 1, brightness: 1, saturation: 1, shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 }, border: { enabled: false, color: '#FFFFFF', width: 4 }, proxyCanvas, proxyCtx: proxyCanvas.getContext('2d'), createdAt: Date.now() };
                newLayer.propX = newLayer.x / movieCanvas.width;
                newLayer.propY = newLayer.y / movieCanvas.height;
                newLayer.propSize = newLayer.size / movieCanvas.width;
                canvasState.layers.unshift(newLayer);
                activeLayerId = newLayer.id;
                renderLayerPalette();
                renderTextLayerPalette();
                updateEditPanelsUI();
                triggerAnimatedRender();
            };
            if (assetCache[src]) { createFromImage(assetCache[src]); return; }
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => { assetCache[src] = image; createFromImage(image); };
            image.onerror = () => toast(`Could not load asset: ${src}`);
            image.src = src;
        }
        
        function updateControlsState() {
            const hasBackground = !!canvasState.backgroundElement;
            downloadImageBtn.disabled = !hasBackground;
            saveProjectBtn.disabled = !hasBackground;
            clearCanvasBtn.disabled = !hasBackground;
            visualsBtn.disabled = !hasBackground;
            textBtn.disabled = !hasBackground;
            eraseToolBtn.disabled = !hasBackground;
            aiToolsBtn.disabled = !hasBackground;
            addNewTextLayerBtn.disabled = !hasBackground;
            renderLayerPalette();
            renderTextLayerPalette();
        }

        function setBackground(element, hash, isRestoring = false) {
            const oldCanvasWidth = movieCanvas.width;
            const oldCanvasHeight = movieCanvas.height;
            const isFirstBackground = !canvasState.backgroundElement;

            canvasState.backgroundElement = element;
            canvasState.backgroundType = 'image';
            canvasState.backgroundHash = hash;
            
            if (!isRestoring) {
                 canvasState.currentProjectId = null;
                 canvasState.layers = []; // Clear layers when changing background on a non-restored project
            }

            const w = element.naturalWidth;
            const h = element.naturalHeight;

            const MIN_CANVAS_SIDE = 1280;
            let canvasW = w, canvasH = h;

            if (w < MIN_CANVAS_SIDE || h < MIN_CANVAS_SIDE) {
                const ratio = w / h;
                if (ratio < 1) { // Portrait or square
                    canvasW = MIN_CANVAS_SIDE;
                    canvasH = MIN_CANVAS_SIDE / ratio;
                } else { // Landscape
                    canvasH = MIN_CANVAS_SIDE;
                    canvasW = MIN_CANVAS_SIDE * ratio;
                }
            }
            
            masterWidth = w;
            masterHeight = h;
            const newCanvasWidth = Math.round(canvasW);
            const newCanvasHeight = Math.round(canvasH);

            movieCanvas.width = controlsOverlayCanvas.width = newCanvasWidth;
            movieCanvas.height = controlsOverlayCanvas.height = newCanvasHeight;

            resizeCanvas();
            updateControlsState();
            updateEditPanelsUI();
            
            let startTime = null;
            function animateBackground(currentTime) {
                if (!startTime) startTime = currentTime;
                const progress = Math.min((currentTime - startTime) / 500, 1);
                if (!canvasPlaceholder.classList.contains('hidden')) { canvasPlaceholder.classList.add('hidden'); }
                movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
                movieCtx.save();
                movieCtx.globalAlpha = progress;
                movieCtx.filter = `brightness(${canvasState.bgBrightness}) saturate(${canvasState.bgSaturation})`;
                movieCtx.drawImage(canvasState.backgroundElement, 0, 0, movieCanvas.width, movieCanvas.height);
                movieCtx.restore();
                drawLayers(movieCtx, canvasState.layers);
                drawControlsOverlay();
                if (progress < 1) { requestAnimationFrame(animateBackground); } 
                else { drawFrame(); }
            }
            requestAnimationFrame(animateBackground);
            
            if (isFirstBackground) {
                toast('Background set! Add layers to create your image.', 3000);
            }
        }
        
        function resizeCanvas() {
            const panelWidth = canvasPanel.clientWidth;
            const panelHeight = canvasPanel.clientHeight;
            if (panelWidth === 0 || panelHeight === 0) return;

            const canvasAspectRatio = movieCanvas.width / movieCanvas.height;
            let displayWidth, displayHeight;
            if (panelWidth / panelHeight > canvasAspectRatio) {
                displayHeight = panelHeight;
                displayWidth = displayHeight * canvasAspectRatio;
            } else {
                displayWidth = panelWidth;
                displayHeight = displayWidth / canvasAspectRatio;
            }

            const topOffset = (panelHeight - displayHeight) / 2;
            const leftOffset = (panelWidth - displayWidth) / 2;

            [movieCanvas, controlsOverlayCanvas].forEach(c => {
                c.style.width = `${displayWidth}px`;
                c.style.height = `${displayHeight}px`;
                c.style.position = 'absolute';
                c.style.top = `${topOffset}px`;
                c.style.left = `${leftOffset}px`;
            });

            pasteboardOverlayCanvas.width = movieCanvas.width + PASTEBOARD_MARGIN * 2;
            pasteboardOverlayCanvas.height = movieCanvas.height + PASTEBOARD_MARGIN * 2;

            const scaleFactor = displayWidth / movieCanvas.width;
            pasteboardOverlayCanvas.style.width = `${pasteboardOverlayCanvas.width * scaleFactor}px`;
            pasteboardOverlayCanvas.style.height = `${pasteboardOverlayCanvas.height * scaleFactor}px`;
            
            const pasteboardTopOffset = topOffset - (PASTEBOARD_MARGIN * scaleFactor);
            const pasteboardLeftOffset = leftOffset - (PASTEBOARD_MARGIN * scaleFactor);
            
            pasteboardOverlayCanvas.style.position = 'absolute';
            pasteboardOverlayCanvas.style.top = `${pasteboardTopOffset}px`;
            pasteboardOverlayCanvas.style.left = `${pasteboardLeftOffset}px`;
        }
        
        function openAddLayerPopup() {
            if (!canvasState.backgroundElement) {
                toast('Please set a background before adding layers.', 2000);
                return;
            }
            addLayerOverlay.classList.add('visible');
        }

        function closeAddLayerPopup() {
            addLayerOverlay.classList.remove('visible');
        }

        function updateLayerInstructions() {
            layerInstructions.classList.remove('placeholder-text');
            if (!canvasState.backgroundElement) { layerInstructions.textContent = "Add a background to begin."; layerInstructions.classList.add('placeholder-text'); } 
            else if (canvasState.layers.filter(l => l.type === 'image').length === 0) { layerInstructions.textContent = "Click '+' to add your first visual layer."; } 
            else { layerInstructions.textContent = "Click & drag layers to re-order them, or use [Q] & [W]."; }
        }

        function renderTextLayerPalette() {
            textLayerPalette.innerHTML = '';
            if (!canvasState.backgroundElement) return;
            const textLayers = canvasState.layers.filter(l => l.type === 'text');
            textLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb text-thumb';
                thumb.classList.toggle('active', layer.id === activeLayerId);
                thumb.dataset.layerId = layer.id;
                thumb.title = "Click to select";
                thumb.innerHTML = `<span>${layer.text.split('\n')[0] || "Empty"}</span><div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                thumb.addEventListener('click', (e) => {
                    e.stopPropagation(); // <-- Fix: Prevent dropdown from closing
                    if (e.target.classList.contains('layer-btn')) return;
                     if (activeLayerId !== layer.id) deactivateEraser();
                    activeLayerId = layer.id;
                    renderLayerPalette();
                    renderTextLayerPalette();
                    updateEditPanelsUI();
                    drawFrame();
                });
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteMovieLayer(layer.id); };
                textLayerPalette.appendChild(thumb);
            });
        }
        
        function addDragAndDropHandlers(thumb) {
            thumb.setAttribute('draggable', 'true');
            thumb.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', thumb.dataset.layerId); setTimeout(() => thumb.classList.add('dragging'), 0); });
            thumb.addEventListener('dragend', () => { document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); thumb.classList.remove('dragging'); });
            thumb.addEventListener('dragover', (e) => { e.preventDefault(); if (document.querySelector('.dragging') !== thumb) { thumb.classList.add('drag-over'); } });
            thumb.addEventListener('dragleave', () => thumb.classList.remove('drag-over'));
            thumb.addEventListener('drop', (e) => {
                e.preventDefault();
                thumb.classList.remove('drag-over');
                const draggedId = e.dataTransfer.getData('text/plain');
                const droppedOnId = thumb.dataset.layerId;
                if (draggedId === droppedOnId) return;
                const i1 = canvasState.layers.findIndex(l => l.id.toString() === draggedId);
                const i2 = canvasState.layers.findIndex(l => l.id.toString() === droppedOnId);
                if (i1 > -1 && i2 > -1) {
                    const [item] = canvasState.layers.splice(i1, 1);
                    canvasState.layers.splice(i2, 0, item);
                    renderLayerPalette();
                    updateTextOrderButtonsState?.();
                    drawFrame();
                }
            });
        }
        
        function renderLayerPalette() {
            assetPalette.innerHTML = '';
            updateLayerInstructions();
            const hasBackground = !!canvasState.backgroundElement;
            const visualLayers = hasBackground ? canvasState.layers.filter(l => l.type === 'image') : [];
            visualLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.classList.toggle('active', layer.id === activeLayerId);
                thumb.dataset.layerId = layer.id;
                let thumbSrc = '';
                try { thumbSrc = layer.proxyCanvas.toDataURL(); } catch (e) { thumbSrc = ''; }
                thumb.innerHTML = `${thumbSrc ? `<img src="${thumbSrc}">` : '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:10px;">(loading)</div>'}<div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                addDragAndDropHandlers(thumb);
                thumb.addEventListener('click', (e) => {
                    if (e.target.classList.contains('layer-btn')) return;
                    if (activeLayerId !== layer.id) deactivateEraser();
                    activeLayerId = layer.id;
                    renderLayerPalette();
                    renderTextLayerPalette();
                    updateEditPanelsUI();
                    drawFrame();
                });
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteMovieLayer(layer.id); };
                assetPalette.appendChild(thumb);
            });
            const emptySlot = document.createElement('button');
            emptySlot.className = 'palette-slot empty';
            emptySlot.innerHTML = '+';
            emptySlot.title = hasBackground ? 'Add a new image asset' : 'Add a background to enable layers';
            emptySlot.disabled = !hasBackground;
            if (hasBackground) { emptySlot.onclick = openAddLayerPopup; }
            assetPalette.appendChild(emptySlot);
        }
        
        function switchVisualsTab(tabToShow) {
            const isAssetTab = tabToShow === 'asset';
            visualsTabAssetBtn.classList.toggle('active', isAssetTab);
            visualsTabBackgroundBtn.classList.toggle('active', !isAssetTab);
            assetTabPanel.classList.toggle('hidden', !isAssetTab);
            backgroundTabPanel.classList.toggle('hidden', isAssetTab);
        }
        
        function updateAssetVisualsUI() {
            const activeLayer = getActiveLayer();
            if (activeLayer && activeLayer.type === 'image') {
                if (visualsDropdown.classList.contains('visible') && !visualsTabAssetBtn.classList.contains('active')) { switchVisualsTab('asset'); }
                assetVisualsControls.classList.remove('disabled');
                assetOpacitySlider.value = activeLayer.opacity;
                assetBrightnessSlider.value = activeLayer.brightness;
                assetSaturationSlider.value = activeLayer.saturation;
                document.getElementById('shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('shadow-color').value = activeLayer.shadow.color;
                document.getElementById('shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('shadow-offset-y').value = activeLayer.shadow.offsetY;
                document.getElementById('asset-edge-enable').checked = activeLayer.border.enabled;
                document.getElementById('asset-edge-controls').classList.toggle('disabled', !activeLayer.border.enabled);
                document.getElementById('asset-edge-color').value = activeLayer.border.color;
                document.getElementById('asset-edge-width').value = activeLayer.border.width;
            } else {
                if (visualsDropdown.classList.contains('visible') && visualsTabAssetBtn.classList.contains('active')) { switchVisualsTab('background'); }
                assetVisualsControls.classList.add('disabled');
            }
        }
        
        function populateCustomFontSelector() {
            fontSelectList.innerHTML = '';
            // Alphabetize the font list for better UX
            availableFonts.sort((a, b) => a.name.localeCompare(b.name));
            availableFonts.forEach(font => {
                const li = document.createElement('li');
                li.textContent = font.name;
                li.dataset.fontValue = font.value;
                li.style.fontFamily = font.value;
                if (font.style) { li.setAttribute('style', `font-family: ${font.value}; ${font.style}`); }
                li.addEventListener('mouseenter', handleFontHoverPreview);
                li.addEventListener('click', handleFontSelect);
                fontSelectList.appendChild(li);
            });
        }

        function handleFontHoverPreview(e) {
            const activeLayer = getActiveLayer();
            if (!activeLayer || activeLayer.type !== 'text') return;
            if (originalFontOnHover === null) { originalFontOnHover = activeLayer.font; }
            activeLayer.font = e.target.dataset.fontValue;
            if (!movieInteraction.active) drawFrame();
        }

        function handleFontHoverEnd() {
            const activeLayer = getActiveLayer();
            if (originalFontOnHover && activeLayer && activeLayer.type === 'text') {
                activeLayer.font = originalFontOnHover;
                originalFontOnHover = null;
                if (!movieInteraction.active) drawFrame();
            }
        }

        function handleFontSelect(e) {
            const activeLayer = getActiveLayer();
            const newFontValue = e.target.dataset.fontValue;
            if (activeLayer && activeLayer.type === 'text') { activeLayer.font = newFontValue; }
            originalFontOnHover = null; 
            fontSelectTrigger.querySelector('span').textContent = e.target.textContent;
            fontSelectTrigger.querySelector('span').style.fontFamily = newFontValue;
            fontSelectList.querySelector('.selected')?.classList.remove('selected');
            e.target.classList.add('selected');
            closeFontDropdown();
            if (!movieInteraction.active) drawFrame();
        }

        function openFontDropdown() {
            customFontSelect.classList.add('open');
            fontSelectDropdown.classList.remove('hidden');
            originalFontOnHover = null;
        }

        function closeFontDropdown() {
            if (!customFontSelect.classList.contains('open')) return;
            handleFontHoverEnd();
            customFontSelect.classList.remove('open');
            fontSelectDropdown.classList.add('hidden');
        }

        function updateTextVisualsUI() {
            const activeLayer = getActiveLayer();
            if (activeLayer && activeLayer.type === 'text') {
                textVisualsControls.classList.remove('disabled');
                textContentInput.value = activeLayer.text;
                textSizeSlider.value = activeLayer.fontSize;
                textColorInput.value = activeLayer.color;
                textEdgeColorInput.value = activeLayer.strokeColor;
                textEdgeWidthSlider.value = activeLayer.strokeWidth;
                
                document.getElementById('text-shadow-enable').checked = activeLayer.shadow.enabled;
                document.getElementById('text-shadow-controls').classList.toggle('disabled', !activeLayer.shadow.enabled);
                document.getElementById('text-shadow-color').value = activeLayer.shadow.color;
                document.getElementById('text-shadow-blur').value = activeLayer.shadow.blur;
                document.getElementById('text-shadow-offset-x').value = activeLayer.shadow.offsetX;
                document.getElementById('text-shadow-offset-y').value = activeLayer.shadow.offsetY;

                const fontName = availableFonts.find(f => f.value === activeLayer.font)?.name || 'Select Font';
                const fontValue = activeLayer.font;
                fontSelectTrigger.querySelector('span').textContent = fontName;
                fontSelectTrigger.querySelector('span').style.fontFamily = fontValue;
                fontSelectList.querySelector('.selected')?.classList.remove('selected');
                const liToSelect = fontSelectList.querySelector(`[data-font-value="${fontValue}"]`);
                if (liToSelect) liToSelect.classList.add('selected');
            } else {
                textVisualsControls.classList.add('disabled');
            }
        }

        function updateBackgroundVisualsUI() {
            bgBrightnessSlider.value = canvasState.bgBrightness;
            bgSaturationSlider.value = canvasState.bgSaturation;
        }

        function updateEditPanelsUI() {
            updateAssetVisualsUI();
            updateTextVisualsUI();
            updateBackgroundVisualsUI();
            updateTextOrderButtonsState();
        }

        function addTextLayer() {
            if (!canvasState.backgroundElement) { toast('Add a background first.', 2000); return; }

            const previousTextLayer = canvasState.layers.find(l => l.type === 'text');
            const newFontSize = Math.max(20, Math.min(movieCanvas.width, movieCanvas.height) * 0.15);
            
            // Create the new layer with default settings first
            const newTextLayer = { 
                id: (Date.now() + Math.random()).toString(), 
                type: 'text', 
                text: 'New Text', 
                font: "'VT323', monospace", 
                fontSize: newFontSize, 
                color: '#FFFFFF', 
                strokeColor: '#000000', 
                strokeWidth: 0, 
                x: movieCanvas.width / 2, 
                y: movieCanvas.height / 2, 
                rot: 0, 
                flipX: false, 
                opacity: 1, 
                brightness: 1, 
                saturation: 1, 
                width: 0, 
                height: 0, 
                shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 }, 
                border: { enabled: false, color: '#FFFFFF', width: 4 }, 
                createdAt: Date.now() 
            };
            newTextLayer.propX = newTextLayer.x / movieCanvas.width;
            newTextLayer.propY = newTextLayer.y / movieCanvas.height;
            newTextLayer.propSize = newTextLayer.fontSize / movieCanvas.height;
            
            // Add the new layer to the state
            canvasState.layers.unshift(newTextLayer);
            activeLayerId = newTextLayer.id;
            deactivateEraser();

            // The 'Yes' callback for the confirmation dialog
            const copyStyles = () => {
                const propsToCopy = ['font', 'fontSize', 'color', 'strokeColor', 'strokeWidth', 'shadow'];
                propsToCopy.forEach(prop => {
                    // Deep copy for objects like 'shadow'
                    newTextLayer[prop] = JSON.parse(JSON.stringify(previousTextLayer[prop]));
                });
                updateEditPanelsUI();
                drawFrame();
                toast('Styles copied!', 2000);
            };

            // If a previous text layer exists, show the confirmation dialog
            if (previousTextLayer) {
                openConfirmationModal(
                    "Copy style from previous text layer?",
                    () => {
                        copyStyles();
                        closeConfirmationModal();
                    }
                );
            }

            // Update UI immediately regardless of the dialog
            renderLayerPalette();
            renderTextLayerPalette();
            updateControlsState();
            updateEditPanelsUI();
            triggerAnimatedRender();
            if (!previousTextLayer) {
                toast('Text layer added!', 2000);
            }
            textContentInput.focus();
            textContentInput.select();
        }

        function deleteMovieLayer(layerId) {
            canvasState.layers = canvasState.layers.filter(l => l.id !== layerId);
            if (activeLayerId === layerId) { activeLayerId = null; deactivateEraser(); }
            renderLayerPalette();
            renderTextLayerPalette();
            updateControlsState();
            updateEditPanelsUI();
            drawFrame();
        }
        
        function getTextBlockMetrics(ctx, text, font, fontSize) {
            ctx.save();
            ctx.font = `${fontSize}px ${font}`;
            const lines = text.split('\n');
            let maxWidth = 0;

            // Use the metrics of a single line to determine line height more accurately.
            // Using a string with ascenders and descenders gives a better overall box.
            const metrics = ctx.measureText('Ag'); 
            const singleLineHeight = (metrics.actualBoundingBoxAscent || fontSize * 0.8) + (metrics.actualBoundingBoxDescent || fontSize * 0.2);

            lines.forEach(line => {
                const lineWidth = ctx.measureText(line).width;
                if (lineWidth > maxWidth) maxWidth = lineWidth;
            });
            
            // Calculate total height based on the more accurate single line height.
            const totalHeight = lines.length * singleLineHeight;

            ctx.restore();
            // Return the single line height as well for drawing calculations.
            return { lines, lineHeight: singleLineHeight, maxWidth, totalHeight };
        }
        
        function nudgeLayerZ(layerId, delta) {
            const i = canvasState.layers.findIndex(l => l.id === layerId);
            if (i === -1) return false;
            const j = i + delta;
            if (j < 0 || j >= canvasState.layers.length) return false;
            const [item] = canvasState.layers.splice(i, 1);
            canvasState.layers.splice(j, 0, item);
            return true;
        }

        function drawLayers(ctx, layers, isFinalRender = false) {
             for (let i = layers.length - 1; i >= 0; i--) {
                const l = layers[i];
                ctx.save();
                const age = Date.now() - l.createdAt;
                let animationProgress = 1;
                if (!isFinalRender && age < FADE_IN_DURATION) { animationProgress = age / FADE_IN_DURATION; }
                const filters = `brightness(${l.brightness}) saturate(${l.saturation})`;
                const shadow = l.shadow.enabled ? `drop-shadow(${l.shadow.offsetX}px ${l.shadow.offsetY}px ${l.shadow.blur}px ${l.shadow.color})` : '';
                let borderFilters = '';
                if (l.type === 'image' && l.border.enabled && l.border.width > 0) { const w = l.border.width, c = l.border.color; borderFilters = `drop-shadow(${w}px ${w}px 0 ${c}) drop-shadow(-${w}px -${w}px 0 ${c}) drop-shadow(-${w}px ${w}px 0 ${c}) drop-shadow(${w}px -${w}px 0 ${c})`; }
                ctx.filter = `${borderFilters} ${shadow} ${filters}`.trim();
                ctx.globalAlpha = l.opacity * animationProgress;
                ctx.translate(l.x, l.y);
                ctx.rotate(l.rot * Math.PI / 180);
                const scaleFactor = 0.95 + 0.05 * animationProgress;
                if (animationProgress < 1) { ctx.scale(scaleFactor, scaleFactor); }
                if (l.flipX) ctx.scale(-1, 1);
                if (l.type === 'image') {
                    const asset = l.proxyCanvas;
                    const assetWidth = asset.width;
                    const assetHeight = asset.height;
                    if (assetWidth > 0) { const dWidth = l.size; const dHeight = l.size * (assetHeight / assetWidth); ctx.drawImage(asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight); }
                } else if (l.type === 'text') {
                    ctx.font = `${l.fontSize}px ${l.font}`;
                    ctx.fillStyle = l.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; // Set baseline to the top for more predictable vertical positioning.

                    if (l.strokeWidth > 0) {
                        ctx.strokeStyle = l.strokeColor;
                        ctx.lineWidth = l.strokeWidth;
                    }
                    
                    const metrics = getTextBlockMetrics(ctx, l.text, l.font, l.fontSize);
                    if (!isFinalRender) { 
                        l.width = metrics.maxWidth;
                        l.height = metrics.totalHeight; 
                    }

                    // Calculate the starting Y position to center the entire text block.
                    const startY = -metrics.totalHeight / 2 + metrics.lineHeight/2;
                    
                    metrics.lines.forEach((line, index) => {
                        const yPos = startY + (index * metrics.lineHeight);
                        if (l.strokeWidth > 0) ctx.strokeText(line, 0, yPos);
                        ctx.fillText(line, 0, yPos);
                    });
                }
                ctx.restore();
            }
        }

        function animationRenderLoop() {
            if (!isAnimatingRender) return;
            const stillAnimating = canvasState.layers.some(l => (Date.now() - l.createdAt) < FADE_IN_DURATION);
            if (stillAnimating) { drawFrame(); requestAnimationFrame(animationRenderLoop); } 
            else { isAnimatingRender = false; if (!movieInteraction.active) { drawFrame(); } }
        }

        function triggerAnimatedRender() {
            if (isAnimatingRender || movieInteraction.active) return;
            isAnimatingRender = true;
            animationRenderLoop();
        }

        function drawFrame() {
            if (!canvasState.backgroundElement) { movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height); return; }
            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.save();
            movieCtx.filter = `brightness(${canvasState.bgBrightness}) saturate(${canvasState.bgSaturation})`;
            movieCtx.drawImage(canvasState.backgroundElement, 0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.restore();
            if (!isCanvasViewZoomedOut) {
                drawLayers(movieCtx, canvasState.layers);
            }
            drawControlsOverlay();
        }
        
        function startRenderLoop() { if (animationFrameId) return; function loop() { drawFrame(); animationFrameId = requestAnimationFrame(loop); } loop(); }
        function stopRenderLoop() { cancelAnimationFrame(animationFrameId); animationFrameId = null; drawFrame(); }

        function drawControlsOverlay() {
            const isPasteboard = isCanvasViewZoomedOut;
            const ctx = isPasteboard ? pasteboardCtx : controlsCtx;
            const canvas = isPasteboard ? pasteboardOverlayCanvas : controlsOverlayCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            if (isPasteboard) {
                ctx.save();
                ctx.translate(PASTEBOARD_MARGIN, PASTEBOARD_MARGIN);
                drawLayers(ctx, canvasState.layers);
                ctx.restore();
            }
        
            if (eraserMode !== 'none') {
                const canvasPoint = getMovieCanvasPoint({clientX: eraseBrushPos.x + movieCanvas.getBoundingClientRect().left, clientY: eraseBrushPos.y + movieCanvas.getBoundingClientRect().top});
                ctx.save();
                if (isPasteboard) ctx.translate(PASTEBOARD_MARGIN, PASTEBOARD_MARGIN);
                const brushColor = eraserMode === 'unerase' ? 'rgba(85, 204, 85, 0.9)' : 'white';
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, eraserSizeDropdown.value / 2, 0, 2 * Math.PI);
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, eraserSizeDropdown.value / 2, 0, 2 * Math.PI);
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            } else {
                const activeLayer = getActiveLayer();
                if (!activeLayer) return;

                ctx.save();
                if (isPasteboard) ctx.translate(PASTEBOARD_MARGIN, PASTEBOARD_MARGIN);
                
                const { dWidth, dHeight } = getLayerMetrics(activeLayer);
                if (!dWidth || !dHeight) {
                    ctx.restore();
                    return;
                }
                
                const scale = movieCanvas.getBoundingClientRect().width / movieCanvas.width;
                if (scale === 0 || !isFinite(scale)) { ctx.restore(); return; }

                const HANDLE_SCREEN_SIZE = 12; 
                const BORDER_SCREEN_WIDTH = 1.5;
                const ROTATION_HANDLE_SCREEN_OFFSET = 26;

                const handleSize = HANDLE_SCREEN_SIZE / scale;
                const lineWidth = BORDER_SCREEN_WIDTH / scale;
                const rotationHandleOffset = ROTATION_HANDLE_SCREEN_OFFSET / scale;
                const ho = handleSize / 2;

                ctx.save();
                ctx.translate(activeLayer.x, activeLayer.y);
                ctx.rotate(activeLayer.rot * Math.PI / 180);

                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.strokeStyle = '#00FF00';
                ctx.fillStyle = '#00FF00';
                ctx.lineWidth = lineWidth;

                const halfW = dWidth / 2;
                const halfH = dHeight / 2;
                ctx.strokeRect(-halfW, -halfH, dWidth, dHeight);

                ctx.beginPath(); ctx.arc(-halfW, -halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(halfW, -halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(-halfW, halfH, ho, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(halfW, halfH, ho, 0, 2 * Math.PI); ctx.fill();
                
                const rotHandleY = -halfH - rotationHandleOffset;
                ctx.beginPath();
                ctx.moveTo(0, -halfH);
                ctx.lineTo(0, rotHandleY);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(0, rotHandleY, ho, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                ctx.restore(); 
                ctx.restore();
            }
        }
        
        function toggleCanvasZoom() {
            isCanvasViewZoomedOut = !isCanvasViewZoomedOut;
            canvasPanel.classList.toggle('is-zoomed-out', isCanvasViewZoomedOut);
            toggleViewBtn.textContent = isCanvasViewZoomedOut ? '⛶' : '⬚';
            toggleViewBtn.title = isCanvasViewZoomedOut ? 'Reset Canvas View (Z)' : 'Zoom Out Canvas (Z)';
            
            movieCanvas.addEventListener('transitionend', drawFrame, { once: true });

            requestAnimationFrame(() => {
                resizeCanvas();
            });
        }

        function downloadImage() {
            if (!canvasState.backgroundElement) { toast("Add a background before downloading.", 3000); return; }
            toast("Preparing high-quality image...", null);
            requestAnimationFrame(() => {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = movieCanvas.width;
                    tempCanvas.height = movieCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.imageSmoothingQuality = 'high';
                    tempCtx.save();
                    tempCtx.filter = `brightness(${canvasState.bgBrightness}) saturate(${canvasState.bgSaturation})`;
                    tempCtx.drawImage(canvasState.backgroundElement, 0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.restore();
                    drawLayers(tempCtx, canvasState.layers, true);
                    const link = document.createElement('a');
                    link.download = 'image-maker-creation.png';
                    link.href = tempCanvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    toast("Image download started!", 4000);
                } catch (error) {
                    console.error("Download failed:", error);
                    toast("Error: Could not generate image. Check console.", 5000);
                }
            }); 
        }

        function showEraserZoom(show){ eraserZoomCanvas.classList.toggle('visible', show); }
        function showEraserHUD(show){ eraserHud.classList.toggle('visible', show); }
        
        function updateEraserHudState() {
            hudEraseBtn.classList.toggle('active', eraserMode === 'erase');
            hudUneraseBtn.classList.toggle('active', eraserMode === 'unerase');
            eraserSizeSlider.value = eraserSizeDropdown.value;
            eraserStrengthSlider.value = eraserStrengthDropdown.value;
        }

        function lerp(a,b,t){ return a+(b-a)*Math.min(1,Math.max(0,t)); }
        function computeZoomUiSize(brush){ const t=(brush-BRUSH_MIN)/(BRUSH_MAX-BRUSH_MIN); return Math.round(lerp(UI_MIN_PX,UI_MAX_PX,t)); }

        function drawEraserZoomAt(canvasPoint){
          if (!canvasState.backgroundElement) return;
          const brush = Math.max(5, Number(eraserSizeDropdown.value));
          const uiPx = computeZoomUiSize(brush);
          if (eraserZoomCanvas.width !== uiPx || eraserZoomCanvas.height !== uiPx){
            eraserZoomCanvas.width = uiPx; eraserZoomCanvas.height = uiPx;
            eraserZoomCanvas.style.width = uiPx + 'px'; eraserZoomCanvas.style.height = uiPx + 'px';
            eraserHud.style.bottom = (12 + uiPx + 12) + 'px';
          }
          let targetR = Math.min(TARGET_RADIUS_PX, uiPx/2 - MIN_MARGIN_PREVIEW);
          let sw = (brush * uiPx) / (2 * targetR);
          let sh = sw;
          const rect = movieCanvas.getBoundingClientRect();
          const mainScale = rect.width / movieCanvas.width;
          const factor = uiPx / sw;
          const minFactor = mainScale * MIN_ZOOM_FEEL;
          if (factor < minFactor){ sw = uiPx / minFactor; sh = sw; }
          sw = Math.min(sw, movieCanvas.width);
          sh = Math.min(sh, movieCanvas.height);
          let sx = canvasPoint.x - sw / 2;
          let sy = canvasPoint.y - sh / 2;
          sx = Math.max(0, Math.min(movieCanvas.width  - sw, sx));
          sy = Math.max(0, Math.min(movieCanvas.height - sh, sy));
          eraserZoomCtx.clearRect(0,0,uiPx,uiPx);
          eraserZoomCtx.imageSmoothingEnabled = true;
          eraserZoomCtx.imageSmoothingQuality = 'high';
          eraserZoomCtx.drawImage(movieCanvas, sx, sy, sw, sh, 0, 0, uiPx, uiPx);
          const scale = uiPx / sw;
          const rZoom = (brush / 2) * scale;
          const cx = (canvasPoint.x - sx) * scale;
          const cy = (canvasPoint.y - sy) * scale;
          eraserZoomCtx.save();
          eraserZoomCtx.beginPath();
          eraserZoomCtx.arc(cx, cy, rZoom, 0, Math.PI*2);
          eraserZoomCtx.strokeStyle = (eraserMode === 'unerase') ? 'rgba(85, 204, 85, 0.9)' : '#ffffff';
          eraserZoomCtx.lineWidth = 2;
          eraserZoomCtx.stroke();
          eraserZoomCtx.setLineDash([5,5]);
          eraserZoomCtx.strokeStyle = '#000000';
          eraserZoomCtx.lineWidth = 1;
          eraserZoomCtx.beginPath();
          eraserZoomCtx.arc(cx, cy, rZoom, 0, Math.PI*2);
          eraserZoomCtx.stroke();
          eraserZoomCtx.restore();
        }

        function getMovieCanvasPoint(e) {
            if (isCanvasViewZoomedOut) {
                const pbRect = pasteboardOverlayCanvas.getBoundingClientRect();
                const scale = pbRect.width / pasteboardOverlayCanvas.width;
                const xInPb = (e.clientX - pbRect.left) / scale;
                const yInPb = (e.clientY - pbRect.top) / scale;
                const x = xInPb - PASTEBOARD_MARGIN;
                const y = yInPb - PASTEBOARD_MARGIN;
                return { x, y }; // Return unclamped coordinates
            } else {
                const movieRect = movieCanvas.getBoundingClientRect();
                const scaleX = movieCanvas.width / movieRect.width;
                const scaleY = movieCanvas.height / movieRect.height;
                return {
                    x: (e.clientX - movieRect.left) * scaleX,
                    y: (e.clientY - movieRect.top) * scaleY
                };
            }
        }
        
        function applyBrushToLayer(layer, canvasPoint) {
            if (!layer || layer.type !== 'image' || !layer.proxyCtx) return;

            // --- 1. Coordinate Transformation ---
            const dx = canvasPoint.x - layer.x;
            const dy = canvasPoint.y - layer.y;
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            
            const assetWidth = layer.proxyCanvas.width;
            const assetHeight = layer.proxyCanvas.height;
            const layerRenderWidth = layer.size;
            const layerRenderHeight = layer.size * (assetHeight / assetWidth);

            const proxyX = (localX + layerRenderWidth / 2) * (assetWidth / layerRenderWidth);
            const proxyY = (localY + layerRenderHeight / 2) * (assetHeight / layerRenderHeight);
            const brushSize = eraserSizeDropdown.value * (assetWidth / layerRenderWidth);

            const ctx = layer.proxyCtx;
            const lastX = movieInteraction.lastProxyX;
            const lastY = movieInteraction.lastProxyY;

            if (eraserMode === 'erase') {
                // --- High-quality line-based erasing ---
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = brushSize;
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = `rgba(0, 0, 0, ${parseFloat(eraserStrengthDropdown.value)})`;
                
                ctx.beginPath();
                if (lastX !== null && lastY !== null) {
                    ctx.moveTo(lastX, lastY);
                } else {
                    ctx.moveTo(proxyX - 0.01, proxyY); // Tiny offset to ensure a dot is drawn
                }
                ctx.lineTo(proxyX, proxyY);
                ctx.stroke();

            } else { // 'unerase'
                // --- Improved dab-based unerasing ---
                const strength = parseFloat(eraserStrengthDropdown.value);
                const radius = brushSize / 2;
                if (radius <= 0 || strength <= 0) return;

                const processUneraseDab = (x, y) => {
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = strength * 0.5; // Unerase can feel too strong, tone it down
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(layer.asset, 0, 0); // Draw original image inside the circle
                    ctx.restore();
                };

                if (lastX !== null && lastY !== null) {
                    const dist = Math.hypot(proxyX - lastX, proxyY - lastY);
                    const angle = Math.atan2(proxyY - lastY, proxyX - lastX);
                    const step = Math.max(1, radius / 2); // Ensure step is at least 1px

                    for (let i = 0; i < dist; i += step) {
                        const x = lastX + Math.cos(angle) * i;
                        const y = lastY + Math.sin(angle) * i;
                        processUneraseDab(x, y);
                    }
                }
                processUneraseDab(proxyX, proxyY); // Process the final point
            }

            // --- Update last point & render ---
            movieInteraction.lastProxyX = proxyX;
            movieInteraction.lastProxyY = proxyY;

            drawFrame();
            lastEraseCanvasPoint = canvasPoint;
            if (movieInteraction.active) {
                drawEraserZoomAt(canvasPoint);
            }
        }

        function getMovieHandleAtPoint(point, layer) {
            const scale = movieCanvas.getBoundingClientRect().width / movieCanvas.width;
            if (scale === 0 || !isFinite(scale)) return null;

            const DESIRED_HIT_RADIUS_ON_SCREEN = 16;
            const radius = DESIRED_HIT_RADIUS_ON_SCREEN / scale;

            const { dWidth, dHeight } = getLayerMetrics(layer);
            if (!dWidth || !dHeight) return null;

            const angle = layer.rot * Math.PI / 180;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const ROTATION_HANDLE_SCREEN_OFFSET = 26;
            const rotationHandleOffset = ROTATION_HANDLE_SCREEN_OFFSET / scale;

            const rotHandleY = -dHeight / 2 - rotationHandleOffset;
            const rotatedRotHandleX = layer.x + (0 * cos - rotHandleY * sin);
            const rotatedRotHandleY = layer.y + (0 * sin + rotHandleY * cos);
            if (Math.hypot(point.x - rotatedRotHandleX, point.y - rotatedRotHandleY) < radius) return 'rotate';

            const handles = {
                tl: { x: -dWidth / 2, y: -dHeight / 2 },
                tr: { x: dWidth / 2, y: -dHeight / 2 },
                bl: { x: -dWidth / 2, y: dHeight / 2 },
                br: { x: dWidth / 2, y: dHeight / 2 }
            };
            for (const name in handles) {
                const h = handles[name];
                const handleWorldX = layer.x + h.x * cos - h.y * sin;
                const handleWorldY = layer.y + h.x * sin + h.y * cos;
                if (Math.hypot(point.x - handleWorldX, point.y - handleWorldY) < radius) return name;
            }
            return null;
        }
        
        function handleMovieInteractionStart(e) {
            e.preventDefault();
            const point = getMovieCanvasPoint(e);

            // If eraser is selected but not yet "armed", this is the first click intended to close the dropdown.
            // Do nothing on the canvas and let the global click handler "arm" the tool for the next click.
            if (eraserMode !== 'none' && !isEraserArmed) {
                return;
            }

            if (eraserMode !== 'none') {
                const activeLayer = getActiveLayer();
                // Only start erasing if the click is within the active layer.
                if (isPointInMovieLayer(point, activeLayer)) {
                     movieInteraction = { active: true, type: 'erase', layerId: activeLayer.id, lastProxyX: null, lastProxyY: null };
                     eraseToolDropdown.classList.remove('visible');
                     lastEraseCanvasPoint = point;
                     showEraserZoom(true);
                     showEraserHUD(false);
                     drawEraserZoomAt(point);
                     applyBrushToLayer(activeLayer, point);
                }
                // If the click is outside the layer, we do nothing, keeping the tool active.
                return; // Exit here to prevent other interactions like dragging.
            }

            let interactionFound = false;
            const activeLayer = getActiveLayer();
            const handle = activeLayer ? getMovieHandleAtPoint(point, activeLayer) : null;

            if (activeLayer && handle) {
                interactionFound = true;
                movieInteraction = { active: true, type: handle === 'rotate' ? 'rotate' : 'resize', layerId: activeLayer.id, handle: handle, startX: point.x, startY: point.y, initialState: JSON.parse(JSON.stringify(activeLayer)), };
            } else if (isPointInMovieLayer(point, activeLayer)) {
                interactionFound = true;
                movieInteraction = { active: true, type: 'drag', layerId: activeLayer.id, offsetX: point.x - activeLayer.x, offsetY: point.y - activeLayer.y, };
            }

            if (!interactionFound) {
                for (let i = 0; i < canvasState.layers.length; i++) {
                    const l = canvasState.layers[i];
                    if (isPointInMovieLayer(point, l)) {
                        activeLayerId = l.id;
                        renderLayerPalette(); renderTextLayerPalette(); updateEditPanelsUI();
                        movieInteraction = { active: true, type: 'drag', layerId: l.id, offsetX: point.x - l.x, offsetY: point.y - l.y };
                        interactionFound = true;
                        break;
                    }
                }
            }

            if (!interactionFound && activeLayerId) {
                activeLayerId = null;
                updateEditPanelsUI();
                renderLayerPalette();
                renderTextLayerPalette();
                drawFrame();
            }

            if(interactionFound) startRenderLoop();
        }

        function getLayerMetrics(layer) {
            if (!layer) return { dWidth: 0, dHeight: 0 };
            let dWidth, dHeight;
             if (layer.type === 'image') {
                const assetWidth  = layer.proxyCanvas?.width  || layer.asset?.naturalWidth  || 0;
                const assetHeight = layer.proxyCanvas?.height || layer.asset?.naturalHeight || 0;
                if (!assetWidth || !assetHeight) return { dWidth: 0, dHeight: 0 };
                dWidth = layer.size;
                dHeight = layer.size * (assetHeight / assetWidth);
            } else {
                const metrics = getTextBlockMetrics(controlsCtx, layer.text, layer.font, layer.fontSize);
                dWidth = metrics.maxWidth;
                dHeight = metrics.totalHeight;
             }
            return { dWidth, dHeight };
        }

        function isPointInMovieLayer(point, layer) {
            if (!layer) return false;
            const metrics = getLayerMetrics(layer);
            const dWidth = metrics.dWidth, dHeight = metrics.dHeight;
            const dx = point.x - layer.x;
            const dy = point.y - layer.y;
            const angle = -layer.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return (Math.abs(localX) < dWidth / 2 && Math.abs(localY) < dHeight / 2);
        }

        function handleMovieInteractionMove(e) {
            const point = getMovieCanvasPoint(e);
            eraseBrushPos = { x: e.clientX - movieCanvas.getBoundingClientRect().left, y: e.clientY - movieCanvas.getBoundingClientRect().top };
            if (!movieInteraction.active) {
                updateCursor(e);
                if (eraserMode !== 'none') {
                    drawControlsOverlay();
                    if (eraserToolDropdown.classList.contains('is-scrubbing')) {
                        drawEraserZoomAt(point);
                    }
                }
                return;
            }
            e.preventDefault();
            const l = getActiveLayer();
            if (!l) return;
            if (movieInteraction.type === 'erase') { applyBrushToLayer(l, point); drawEraserZoomAt(point); return; }
            if (movieInteraction.type === 'drag') {
                l.x = point.x - movieInteraction.offsetX;
                l.y = point.y - movieInteraction.offsetY;
                l.propX = l.x / movieCanvas.width;
                l.propY = l.y / movieCanvas.height;
            } 
            else if (movieInteraction.type === 'rotate') {
                const iState = movieInteraction.initialState;
                const initialAngle = Math.atan2(movieInteraction.startY - iState.y, movieInteraction.startX - iState.x) * 180 / Math.PI;
                const currentAngle = Math.atan2(point.y - iState.y, point.x - iState.x) * 180 / Math.PI;
                l.rot = iState.rot + (currentAngle - initialAngle);
            } else if (movieInteraction.type === 'resize') {
                const iState = movieInteraction.initialState;
                const initialDist = Math.hypot(movieInteraction.startX - iState.x, movieInteraction.startY - iState.y);
                const currentDist = Math.hypot(point.x - iState.x, point.y - iState.y);
                if (initialDist > 1) {
                    const scaleFactor = currentDist / initialDist;
                    if (l.type === 'text') {
                        l.fontSize = Math.max(10, iState.fontSize * scaleFactor);
                        l.propSize = l.fontSize / movieCanvas.height;
                        textSizeSlider.value = l.fontSize;
                    } 
                    else {
                        l.size = Math.max(20, iState.size * scaleFactor);
                        l.propSize = l.size / movieCanvas.width;
                    }
                }
            }
        }

        function handleMovieInteractionEnd(e) {
          if (movieInteraction.active) {
            const wasErasing = movieInteraction.type === 'erase';
            movieInteraction.active = false;
            showEraserZoom(false);
            if (wasErasing) { renderLayerPalette(); showEraserHUD(true); }
            stopRenderLoop();
          }
        }

        function updateCursor(e) {
            if (eraserMode !== 'none') {
                movieCanvas.style.cursor = 'none';
                pasteboardOverlayCanvas.style.cursor = 'none';
                return;
            }
            movieCanvas.style.cursor = '';
            pasteboardOverlayCanvas.style.cursor = '';

            const point = getMovieCanvasPoint(e);
            let newCursor = 'default';
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                const handle = getMovieHandleAtPoint(point, activeLayer);
                if (handle) {
                    newCursor = handle === 'rotate' ? 'grab' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize');
                } else if (isPointInMovieLayer(point, activeLayer)) {
                    newCursor = 'move';
                }
            } else {
                 for (let i = 0; i < canvasState.layers.length; i++) {
                    if (isPointInMovieLayer(point, canvasState.layers[i])) {
                        newCursor = 'pointer';
                        break;
                    }
                }
            }
            
            if (isCanvasViewZoomedOut) {
                pasteboardOverlayCanvas.style.cursor = newCursor;
            } else {
                movieCanvas.style.cursor = newCursor;
            }
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') { if (key === 'escape') document.activeElement.blur(); return; }
            if ((e.metaKey || e.ctrlKey) && key === 's') { e.preventDefault(); if (!saveProjectBtn.disabled) saveProjectToLibrary(); return; }
            if (key === 'z') { e.preventDefault(); toggleCanvasZoom(); return; }
            if (key === 'escape' && eraserMode !== 'none') { e.preventDefault(); deactivateEraser(); return; }
            const activeLayer = getActiveLayer();
            if (!activeLayer) return;
            if (key === 'q' || key === 'w') {
                e.preventDefault();
                const moved = nudgeLayerZ(activeLayer.id, key === 'q' ? -1 : +1);
                if (moved) { renderLayerPalette(); renderTextLayerPalette(); updateTextOrderButtonsState?.(); drawFrame(); }
                return;
            }
            if (key === 'd' || key === 'f') { // Enlarge / Shrink
                e.preventDefault();
                const scaleFactor = key === 'd' ? 1.05 : 0.95;
                if (activeLayer.type === 'image') {
                    activeLayer.size *= scaleFactor;
                    activeLayer.propSize = activeLayer.size / movieCanvas.width;
                } else if (activeLayer.type === 'text') {
                    activeLayer.fontSize *= scaleFactor;
                    activeLayer.propSize = activeLayer.fontSize / movieCanvas.height;
                    textSizeSlider.value = activeLayer.fontSize;
                }
            }
            else if (key === 's') { e.preventDefault(); activeLayer.flipX = !activeLayer.flipX; } 
            else if (key === 'delete' || key === 'backspace') { e.preventDefault(); deleteMovieLayer(activeLayer.id); toast('Layer deleted', 2000); }
            drawFrame();
        }

        function clearCanvas(isSoft = false) {
            canvasState = { currentProjectId: null, backgroundElement: null, backgroundType: 'none', backgroundHash: null, bgBrightness: 1, bgSaturation: 1, layers: [] };
            activeLayerId = null;
            deactivateEraser();
            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            controlsCtx.clearRect(0, 0, controlsOverlayCanvas.width, controlsOverlayCanvas.height);
            canvasPlaceholder.classList.remove('hidden');
            localStorage.removeItem('ims-autosave-project');
            updateControlsState();
            updateEditPanelsUI();
            drawFrame();
            if (!isSoft) toast("Canvas cleared. Saved projects are safe.", 2000);
        }

        function deactivateEraser(shouldCloseDropdown = false) {
            if (eraserMode === 'none') return;
            document.getElementById('eraser-controls-wrapper').classList.add('disabled');
            showEraserHUD(false);
            showEraserZoom(false);
            eraserMode = 'none';
            isEraserArmed = false;
            eraseBtn.classList.remove('active');
            uneraseBtn.classList.remove('active');
            eraseToolBtn.classList.remove('active');
            movieCanvas.style.cursor = '';
            pasteboardOverlayCanvas.style.cursor = '';
            hideToast();
            drawFrame();
            if (shouldCloseDropdown) { eraseToolDropdown.classList.remove('visible'); }
        }

        function toggleDropdownEraserMode(mode) {
            const activeLayer = getActiveLayer();
            if (!activeLayer) { toast('Select an image layer to use the eraser.', 3000); return; }
             if (activeLayer.type !== 'image') { toast('Eraser only works on image layers.', 3000); return; }
            if (eraserMode === mode) { deactivateEraser(false); } 
            else {
                eraserMode = mode;
                isEraserArmed = false;
                document.getElementById('eraser-controls-wrapper').classList.remove('disabled');
                eraseBtn.classList.toggle('active', mode === 'erase');
                uneraseBtn.classList.toggle('active', mode === 'unerase');
                eraseToolBtn.classList.add('active');
                 [visualsDropdown, textDropdown, shortcutsDropdown, aiToolsDropdown].forEach(d => d.classList.remove('visible'));
            }
        }
        
        function armEraserFromHUD(mode) {
             if (eraserMode !== mode) { eraserMode = mode; updateEraserHudState(); }
             isEraserArmed = true;
             toast(`${eraserMode === 'erase' ? 'Erase' : 'Unerase'} Mode Activated`, 1500);
        }

        let confirmCallback = null;
        function openConfirmationModal(text, onConfirm) { confirmationText.textContent = text; confirmCallback = onConfirm; confirmationOverlay.classList.add('visible'); }
        function closeConfirmationModal() { confirmationOverlay.classList.remove('visible'); confirmCallback = null; }

        function updateTextOrderButtonsState() {
            const textMoveBackBtn = document.getElementById('text-move-back');
            const textMoveForwardBtn = document.getElementById('text-move-forward');
            if (!textMoveBackBtn || !textMoveForwardBtn) return;
            const l = getActiveLayer();
            if (!l || l.type !== 'text') { textMoveBackBtn.disabled = true; textMoveForwardBtn.disabled = true; return; }
            const idx = canvasState.layers.findIndex(x => x.id === l.id);
            textMoveForwardBtn.disabled = (idx === 0);
            textMoveBackBtn.disabled = (idx === canvasState.layers.length - 1);
        }
        
        const BG_MODELS = {
            fast: './u2netp.onnx'
        };

        const bgSessionCache = new Map();

        async function getBgSession(mode) {
            if (bgSessionCache.has(mode)) return bgSessionCache.get(mode);

            const url = BG_MODELS[mode] || BG_MODELS.fast;
            const modelName = mode.charAt(0).toUpperCase() + mode.slice(1);
            toast(`Loading ${modelName} model`, null);

            try {
                const resp = await fetch(url, { mode: 'cors', cache: 'force-cache' });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const bytes = await resp.arrayBuffer();
                
                const session = await ort.InferenceSession.create(bytes, {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all',
                });

                bgSessionCache.set(mode, session);
                hideToast();
                return session;

            } catch (e) {
                hideToast();
                console.error(`Failed to load '${mode}' model from ${url}. Error: ${e.message}`);
                toast('Critical: Background removal model failed to load.', 5000);
                throw new Error("Could not load the background removal model.");
            }
        }

        function rgbaToCHWFloat32(imgData, size = 320) {
            const { data } = imgData;
            const chw = new Float32Array(3 * size * size);
            let p = 0, rOff = 0, gOff = size * size, bOff = 2 * size * size;
            for (let i = 0; i < data.length; i += 4) {
                chw[rOff + p] = data[i] / 255;
                chw[gOff + p] = data[i + 1] / 255;
                chw[bOff + p] = data[i + 2] / 255;
                p++;
            }
            return chw;
        }

        function letterboxToSquareBitmap(imgBitmap, size = 320) {
            const canvas = new OffscreenCanvas(size, size);
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            const scale = Math.min(size / imgBitmap.width, size / imgBitmap.height);
            const dw = Math.round(imgBitmap.width * scale);
            const dh = Math.round(imgBitmap.height * scale);
            const dx = Math.floor((size - dw) / 2);
            const dy = Math.floor((size - dh) / 2);
            ctx.clearRect(0, 0, size, size);
            ctx.drawImage(imgBitmap, 0, 0, imgBitmap.width, imgBitmap.height, dx, dy, dw, dh);
            return { canvas, dx, dy, dw, dh };
        }
        
        async function runU2NetOnImageLayer(layer, session) {
            const bmp = await createImageBitmap(layer.asset);
            const side = 320;
            const boxed = letterboxToSquareBitmap(bmp, side);
            const pctx = boxed.canvas.getContext('2d', { willReadFrequently: true });
            const imgData = pctx.getImageData(0, 0, side, side);
            const chw = rgbaToCHWFloat32(imgData, side);
            const input = new ort.Tensor('float32', chw, [1, 3, side, side]);
            
            const feeds = { [session.inputNames[0]]: input };
            const results = await session.run(feeds);
            const out = results[session.outputNames[0]].data;

            const maskCanvas = new OffscreenCanvas(side, side);
            const mctx = maskCanvas.getContext('2d');
            const mImg = mctx.createImageData(side, side);
            for (let i = 0; i < out.length; i++) {
                const a = Math.max(0, Math.min(1, out[i]));
                const j = i * 4;
                mImg.data[j] = mImg.data[j+1] = mImg.data[j+2] = 255;
                mImg.data[j+3] = Math.round(a * 255);
            }
            mctx.putImageData(mImg, 0, 0);
            featherMask(maskCanvas, 1.2);
            const maskBitmap = await createImageBitmap(maskCanvas);

            const proxy = layer.proxyCanvas;
            const ctx = layer.proxyCtx;
            ctx.clearRect(0,0,proxy.width,proxy.height);
            ctx.drawImage(layer.asset, 0, 0);

            const maskFull = upscaleMaskToLayer(maskBitmap, boxed, proxy.width, proxy.height);
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(maskFull, 0, 0);
            ctx.restore();
        }

        async function removeBgForActiveImageLayer() {
            if (aiToolsDropdown) aiToolsDropdown.classList.remove('visible');
            
            const active = getActiveLayer();
            if (!active || active.type !== 'image') {
                toast('Select an image layer first.', 2500);
                return;
            }

            const mode = 'fast';

            try {
                const session = await getBgSession(mode);
                if (!session) return; 

                toast(`Removing background`, null);
                await new Promise(resolve => setTimeout(resolve, 50));

                await runU2NetOnImageLayer(active, session);
                
                toast(`Background removed.`, 2500);
                renderLayerPalette?.();
                drawFrame?.();
            } catch (err) {
                console.error(err);
                hideToast();
                toast('BG removal failed. See console.', 4000);
            }
        }
        
        function upscaleMaskToLayer(maskBitmap, boxed, layerWidth, layerHeight) {
            const { dx, dy, dw, dh } = boxed;
            const tempMaskCanvas = new OffscreenCanvas(maskBitmap.width, maskBitmap.height);
            tempMaskCanvas.getContext('2d').drawImage(maskBitmap, 0, 0);
            const croppedMaskCanvas = new OffscreenCanvas(dw, dh);
            croppedMaskCanvas.getContext('2d').drawImage(tempMaskCanvas, dx, dy, dw, dh, 0, 0, dw, dh);
            const finalMaskCanvas = new OffscreenCanvas(layerWidth, layerHeight);
            const finalCtx = finalMaskCanvas.getContext('2d');
            finalCtx.imageSmoothingEnabled = true;
            finalCtx.imageSmoothingQuality = 'high';
            finalCtx.drawImage(croppedMaskCanvas, 0, 0, dw, dh, 0, 0, layerWidth, layerHeight);
            return finalMaskCanvas;
        }

        function featherMask(canvas, amount = 1.2) {
            const ctx = canvas.getContext('2d');
            if (amount > 0) {
                ctx.filter = `blur(${amount}px)`;
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }
        }
        
        async function getSavableState() {
            const savableState = {
                currentProjectId: canvasState.currentProjectId,
                bgBrightness: canvasState.bgBrightness,
                bgSaturation: canvasState.bgSaturation,
                backgroundHash: canvasState.backgroundHash,
                layers: []
            };

            for (const layer of canvasState.layers) {
                if (layer.type === 'image') {
                    const { asset, proxyCanvas, proxyCtx, ...serializableLayer } = layer;
                    serializableLayer.proxyCanvasDataURL = proxyCanvas.toDataURL();
                    savableState.layers.push(serializableLayer);
                } else if (layer.type === 'text') {
                    savableState.layers.push({ ...layer });
                }
            }
            return savableState;
        }

        async function saveCurrentWork() {
            if (!canvasState.backgroundElement) return;
            try {
                const state = await getSavableState();
                localStorage.setItem('ims-autosave-project', JSON.stringify(state));
            } catch (e) {
                console.warn("Failed to autosave project:", e);
            }
        }

        async function saveProjectToLibrary() {
            if (!canvasState.backgroundElement) {
                toast("A background is required to save a project.", 3000);
                return;
            }
            toast("Saving project to library...", null);

            const thumbCanvas = document.createElement('canvas');
            const THUMB_MAX_SIZE = 256;
            const aspect = movieCanvas.width / movieCanvas.height;
            thumbCanvas.width = aspect >= 1 ? THUMB_MAX_SIZE : THUMB_MAX_SIZE * aspect;
            thumbCanvas.height = aspect < 1 ? THUMB_MAX_SIZE : THUMB_MAX_SIZE / aspect;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.imageSmoothingQuality = 'high';
            thumbCtx.filter = `brightness(${canvasState.bgBrightness}) saturate(${canvasState.bgSaturation})`;
            thumbCtx.drawImage(canvasState.backgroundElement, 0, 0, thumbCanvas.width, thumbCanvas.height);
            thumbCtx.filter = 'none';
            thumbCtx.save();
            thumbCtx.scale(thumbCanvas.width / movieCanvas.width, thumbCanvas.height / movieCanvas.height);
            drawLayers(thumbCtx, canvasState.layers, true);
            thumbCtx.restore();
            const thumbnailBlob = await new Promise(resolve => thumbCanvas.toBlob(resolve, 'image/webp', 0.8));

            const projectState = await getSavableState();

            const record = { createdAt: Date.now(), thumbnail: thumbnailBlob, projectState };
            let toastMessage = "Project saved to library!";

            if (canvasState.currentProjectId) {
                record.id = canvasState.currentProjectId;
                toastMessage = "Project updated in library!";
            }

            const savedRecord = await idbPut(record, 'projects');
            canvasState.currentProjectId = savedRecord.id;
            await saveCurrentWork();

            toast(toastMessage, 2500);
        }

        async function createLayerFromSave(savedLayer) {
            if (savedLayer.type === 'text') {
                return { ...savedLayer, createdAt: Date.now() };
            }
            if (savedLayer.type === 'image') {
                try {
                    const assetRecord = (await idbFindByHash(savedLayer.hash))[0];
                    if (!assetRecord) { throw new Error(`Asset with hash ${savedLayer.hash} not in library.`); }
                    
                    const asset = new Image();
                    asset.src = URL.createObjectURL(assetRecord.full);
                    const proxyImage = new Image();
                    proxyImage.src = savedLayer.proxyCanvasDataURL;

                    await Promise.all([asset.decode(), proxyImage.decode()]);

                    const proxyCanvas = document.createElement('canvas');
                    proxyCanvas.width = proxyImage.naturalWidth;
                    proxyCanvas.height = proxyImage.naturalHeight;
                    const proxyCtx = proxyCanvas.getContext('2d');
                    proxyCtx.drawImage(proxyImage, 0, 0);

                    const restoredLayer = { ...savedLayer, asset, proxyCanvas, proxyCtx, createdAt: Date.now() };
                    delete restoredLayer.proxyCanvasDataURL;
                    return restoredLayer;
                } catch (error) {
                    console.error("Error restoring image layer:", error);
                    toast(`Skipping a layer: ${error.message}`, 3500);
                    return null;
                }
            }
            return null;
        }

        async function restoreProjectState(projectState) {
            const textLayers = projectState.layers.filter(l => l.type === 'text' && l.font);
            const uniqueFontValues = [...new Set(textLayers.map(l => l.font))];
            const fontNamesToLoad = uniqueFontValues
                .map(value => fontValueToNameMap.get(value))
                .filter(name => name && name !== 'VT323');
            
            await loadSpecificFonts(fontNamesToLoad);
            
            if (!projectState.backgroundHash) {
                throw new Error("Saved project is missing a background.");
            }
            const bgAssets = await idbFindByHash(projectState.backgroundHash);
            if (!bgAssets || bgAssets.length === 0) {
                 throw new Error("Background asset for saved project not found in library.");
            }
            const img = new Image();
            img.src = URL.createObjectURL(bgAssets[0].full);
            
            await img.decode();
            
            clearCanvas(true); // Soft clear without toast

            setBackground(img, projectState.backgroundHash, true);
            canvasState.bgBrightness = projectState.bgBrightness || 1;
            canvasState.bgSaturation = projectState.bgSaturation || 1;
            canvasState.currentProjectId = projectState.currentProjectId || null;

            const layerPromises = projectState.layers.map(createLayerFromSave);
            const loadedLayers = await Promise.all(layerPromises);
            
            canvasState.layers = loadedLayers.filter(l => l !== null);
            
            updateControlsState();
            updateEditPanelsUI();
            renderLayerPalette();
            renderTextLayerPalette();
            drawFrame();
            await saveCurrentWork();
        }
        
        async function restoreCurrentWork() {
            const savedData = localStorage.getItem('ims-autosave-project');
            if (!savedData) return;

            try {
                const projectState = JSON.parse(savedData);
                toast("Restoring previous work...", null);
                await restoreProjectState(projectState);
                toast("Work restored!", 2000);
            } catch (error) {
                console.error("Failed to restore project:", error);
                toast(`Could not restore work: ${error.message}`, 4000);
                localStorage.removeItem('ims-autosave-project');
            }
        }


        (function addBgUI() {
            const panel = document.getElementById('ai-tools-dropdown');
            if (!panel) return;
            
            panel.innerHTML = `<h5>Background Remover</h5>`;

            const btn = document.createElement('button');
            btn.className = 'mg-btn';
            btn.textContent = 'Remove Background';
            btn.style.marginTop = '0.5rem';
            btn.addEventListener('click', removeBgForActiveImageLayer);
            
            panel.appendChild(btn);
        })();

        const setupEventListeners = () => {
            const versionLink = document.getElementById('version-link');
            const versionPopupOverlay = document.getElementById('version-popup-overlay');
            const closeButton = document.getElementById('close-popup');
            versionLink.addEventListener('click', (e) => { e.preventDefault(); versionPopupOverlay.style.display = 'flex'; });
            closeButton.addEventListener('click', () => { versionPopupOverlay.style.display = 'none'; });
            versionPopupOverlay.addEventListener('click', (e) => { if (e.target === versionPopupOverlay) versionPopupOverlay.style.display = 'none'; });
            themeSelectLink.addEventListener('click', (e) => { e.preventDefault(); themeChosen = false; themePopupOverlay.style.display = 'flex'; });
            themePopupContent.addEventListener('mouseleave', () => { if (!themeChosen) applyTheme(originalTheme, true); });
            themePopupOverlay.addEventListener('click', (e) => { if (e.target === themePopupOverlay) { if (!themeChosen) applyTheme(originalTheme); themePopupOverlay.style.display = 'none'; } });
            
            canvasPlaceholder.addEventListener('click', () => initialBackgroundInput.click());
            
            initialBackgroundInput.addEventListener('change', e => { handleBackgroundUpload(e.target.files[0]); e.target.value = null; });
            downloadImageBtn.addEventListener('click', downloadImage);
            saveProjectBtn.addEventListener('click', saveProjectToLibrary);
            clearCanvasBtn.addEventListener('click', () => openConfirmationModal("This will clear the canvas and start a new project. Are you sure?", () => { clearCanvas(); closeConfirmationModal(); }));
            
            // --- UPDATED: Add Layer Popup Listeners ---
            const addLayerCloseBtn = document.getElementById('mg-asset-library-close');
            const dropZone = document.getElementById('mg-asset-drop-zone');
            addLayerCloseBtn.addEventListener('click', closeAddLayerPopup);
            addLayerOverlay.addEventListener('click', e => { if (e.target === addLayerOverlay) closeAddLayerPopup() });
            dropZone.addEventListener('click', () => addLayerFileInput.click());
            addLayerFileInput.addEventListener('change', e => { processUploadedFile(e.target.files?.[0]); e.target.value = null; });
            dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag-over'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
            dropZone.addEventListener('drop', e => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file) { processUploadedFile(file); }
            });
            
            textBtn.addEventListener('click', e => { loadSecondaryFonts(); e.stopPropagation(); deactivateEraser(true); textDropdown.classList.toggle('visible'); visualsDropdown.classList.remove('visible'); shortcutsDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); aiToolsDropdown.classList.remove('visible'); closeFontDropdown(); });
            aiToolsBtn.addEventListener('click', e => { e.stopPropagation(); deactivateEraser(true); aiToolsDropdown.classList.toggle('visible'); visualsDropdown.classList.remove('visible'); shortcutsDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); textDropdown.classList.remove('visible'); closeFontDropdown(); });
            addNewTextLayerBtn.addEventListener('click', addTextLayer);
            confirmYesBtn.addEventListener('click', async (e) => { e.stopPropagation(); const fn = confirmCallback; confirmCallback = null; try { if (typeof fn === 'function') await fn(); } catch (err) { console.error('Confirmation action failed:', err); toast('Error: Could not complete the action.', 4000); } finally { closeConfirmationModal(); } });
            confirmNoBtn.addEventListener('click', (e) => { e.stopPropagation(); closeConfirmationModal(); });
            confirmationOverlay.addEventListener('click', (e) => { if (e.target === confirmationOverlay) closeConfirmationModal(); });
            canvasPanel.addEventListener('mousedown', handleMovieInteractionStart);
            window.addEventListener('mousemove', handleMovieInteractionMove);
            window.addEventListener('mouseup', handleMovieInteractionEnd);
            canvasPanel.addEventListener('mouseleave', () => { if (!movieInteraction.active) { movieCanvas.style.cursor = 'default'; pasteboardOverlayCanvas.style.cursor = 'default'; } eraseBrushPos = {x: -1000, y: -1000}; if(eraserMode !== 'none') { drawControlsOverlay(); } });
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('beforeunload', saveCurrentWork);
            canvasPanel.addEventListener('dragover', e => { e.preventDefault(); canvasPanel.classList.add('drag-over') });
            canvasPanel.addEventListener('dragleave', () => canvasPanel.classList.remove('drag-over'));
            canvasPanel.addEventListener('drop', e => { e.preventDefault(); canvasPanel.classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) { if (!canvasState.backgroundElement) handleBackgroundUpload(file); else processUploadedFile(file); } });
            
            // Modified paste handler
            window.addEventListener('paste', e => {
                const items = e.clipboardData?.items;
                if (!items) return;

                let imageFile = null;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        imageFile = items[i].getAsFile();
                        break;
                    }
                }
                
                if (imageFile) {
                    e.preventDefault();
                    if (addLayerOverlay.classList.contains('visible')) {
                        processUploadedFile(imageFile);
                    } else if (!canvasState.backgroundElement) {
                        handleBackgroundUpload(imageFile);
                    } else {
                        processUploadedFile(imageFile);
                    }
                }
            });

            shortcutsBtn.addEventListener('click', e => { e.stopPropagation(); deactivateEraser(true); shortcutsDropdown.classList.toggle('visible'); visualsDropdown.classList.remove('visible'); textDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); aiToolsDropdown.classList.remove('visible'); closeFontDropdown();});
            visualsBtn.addEventListener('click', e => { e.stopPropagation(); deactivateEraser(true); visualsDropdown.classList.toggle('visible'); if (visualsDropdown.classList.contains('visible')) { if (getActiveLayer() && getActiveLayer().type === 'image') { switchVisualsTab('asset'); } else { switchVisualsTab('background'); } } shortcutsDropdown.classList.remove('visible'); textDropdown.classList.remove('visible'); eraseToolDropdown.classList.remove('visible'); aiToolsDropdown.classList.remove('visible'); closeFontDropdown(); });
            visualsTabAssetBtn.addEventListener('click', () => { switchVisualsTab('asset'); if (!getActiveLayer() || getActiveLayer().type !== 'image') { toast('Select an image layer to enable asset editing.', 3000); } });
            visualsTabBackgroundBtn.addEventListener('click', () => switchVisualsTab('background'));
            
            eraseToolBtn.addEventListener('click', e => {
                e.stopPropagation();
                if (eraseToolDropdown.classList.contains('visible')) {
                    if (eraserMode !== 'none' && !isEraserArmed) {
                        isEraserArmed = true;
                        showEraserHUD(true); 
                        updateEraserHudState(); 
                        movieCanvas.classList.add('erase-cursor');
                        const toastMsg = `${eraserMode==='erase'?'Erase':'Unerase'} Mode Activated. Press [ESC] to deactivate.`;
                        toast(toastMsg, null);
                    }
                    eraseToolDropdown.classList.remove('visible');
                } else {
                    deactivateEraser();
                    eraseToolDropdown.classList.add('visible');
                    shortcutsDropdown.classList.remove('visible');
                    visualsDropdown.classList.remove('visible');
                    textDropdown.classList.remove('visible');
                    aiToolsDropdown.classList.remove('visible');
                    closeFontDropdown();
                }
            });

            fontSelectTrigger.addEventListener('click', (e) => { e.stopPropagation(); if (customFontSelect.classList.contains('open')) { closeFontDropdown(); } else { openFontDropdown(); } });
            fontSelectDropdown.addEventListener('mouseleave', handleFontHoverEnd);
            eraseBtn.addEventListener('click', () => toggleDropdownEraserMode('erase'));
            uneraseBtn.addEventListener('click', () => toggleDropdownEraserMode('unerase'));
            hudEraseBtn.addEventListener('click', () => armEraserFromHUD('erase'));
            hudUneraseBtn.addEventListener('click', () => armEraserFromHUD('unerase'));
            eraserHud.addEventListener('mousedown', e => e.stopPropagation());
            
            document.querySelectorAll('#visuals-dropdown input, #visuals-dropdown select, #text-dropdown input, #text-dropdown textarea').forEach(input => {
                const eventType = ['range', 'color'].includes(input.type) || input.tagName === 'TEXTAREA' ? 'input' : 'change';
                input.addEventListener(eventType, () => {
                    const l = getActiveLayer();
                    if (!l && !input.id.startsWith('bg-')) return;
                    switch(input.id) {
                        case 'asset-opacity': l.opacity = parseFloat(input.value); break;
                        case 'asset-brightness': l.brightness = parseFloat(input.value); break;
                        case 'asset-saturation': l.saturation = parseFloat(input.value); break;
                        case 'bg-brightness': canvasState.bgBrightness = parseFloat(input.value); break;
                        case 'bg-saturation': canvasState.bgSaturation = parseFloat(input.value); break;
                        case 'text-content': if(l.type==='text') l.text = input.value; renderTextLayerPalette(); break;
                        case 'text-size': if(l.type==='text') { l.fontSize = parseFloat(input.value); l.propSize = l.fontSize / movieCanvas.height; } break;
                        case 'text-color': if(l.type==='text') l.color = input.value; break;
                        case 'text-edge-color': if(l.type==='text') l.strokeColor = input.value; break;
                        case 'text-edge-width': if(l.type==='text') l.strokeWidth = parseFloat(input.value); break;
                        case 'shadow-enable': if(l) { l.shadow.enabled = input.checked; document.getElementById('shadow-controls').classList.toggle('disabled', !input.checked); } break;
                        case 'shadow-color': if(l) l.shadow.color = input.value; break;
                        case 'shadow-blur': if(l) l.shadow.blur = input.value; break;
                        case 'shadow-offset-x': if(l) l.shadow.offsetX = input.value; break;
                        case 'shadow-offset-y': if(l) l.shadow.offsetY = input.value; break;
                        case 'text-shadow-enable': if(l?.type==='text') { l.shadow.enabled = input.checked; document.getElementById('text-shadow-controls').classList.toggle('disabled', !input.checked); } break;
                        case 'text-shadow-color': if(l?.type==='text') l.shadow.color = input.value; break;
                        case 'text-shadow-blur': if(l?.type==='text') l.shadow.blur = input.value; break;
                        case 'text-shadow-offset-x': if(l?.type==='text') l.shadow.offsetX = input.value; break;
                        case 'text-shadow-offset-y': if(l?.type==='text') l.shadow.offsetY = input.value; break;
                        case 'asset-edge-enable': if(l) { l.border.enabled = input.checked; document.getElementById('asset-edge-controls').classList.toggle('disabled', !input.checked); } break;
                        case 'asset-edge-color': if(l) l.border.color = input.value; break;
                        case 'asset-edge-width': if(l) l.border.width = input.value; break;
                    }
                    if (!movieInteraction.active) drawFrame();
                });
            });
            const textMoveForwardBtn = document.getElementById('text-move-forward');
            const textMoveBackBtn = document.getElementById('text-move-back');
            if (textMoveForwardBtn) textMoveForwardBtn.addEventListener('click', () => { const l = getActiveLayer(); if (l?.type === 'text' && nudgeLayerZ(l.id, -1)) { renderLayerPalette(); renderTextLayerPalette(); updateTextOrderButtonsState(); drawFrame(); } });
            if (textMoveBackBtn) textMoveBackBtn.addEventListener('click', () => { const l = getActiveLayer(); if (l?.type === 'text' && nudgeLayerZ(l.id, +1)) { renderLayerPalette(); renderTextLayerPalette(); updateTextOrderButtonsState(); drawFrame(); } });
            
            const allSliders = document.querySelectorAll('#visuals-dropdown input[type=range], #text-dropdown input[type=range], #erase-tool-dropdown input[type=range], #mg-eraser-hud input[type=range]');
            
            const startScrubbing = (e) => {
                const slider = e.currentTarget;
                const container = slider.closest('.slider-container') || slider.closest('.row');
                const parentScrubTarget = slider.closest('[id$="-dropdown"]') || slider.closest('#mg-eraser-hud');
                if (parentScrubTarget && container) {
                    parentScrubTarget.classList.add('is-scrubbing');
                    container.classList.add('is-active-slider');
                }
            };
            const endScrubbing = () => { 
                const scrubbedEl = document.querySelector('.is-scrubbing'); 
                if (scrubbedEl) { 
                    const activeContainer = scrubbedEl.querySelector('.is-active-slider'); 
                    if (activeContainer) activeContainer.classList.remove('is-active-slider'); 
                    scrubbedEl.classList.remove('is-scrubbing'); 
                } 
            };
            
            allSliders.forEach(slider => {
                slider.addEventListener('mousedown', startScrubbing);
                slider.addEventListener('touchstart', startScrubbing, { passive: true });
            });
            window.addEventListener('mouseup', endScrubbing);
            window.addEventListener('touchend', endScrubbing);

            window.addEventListener('click', (e) => {
                const popups = [ { dropdown: shortcutsDropdown, button: shortcutsBtn }, { dropdown: visualsDropdown, button: visualsBtn }, { dropdown: textDropdown, button: textBtn }, { dropdown: eraseToolDropdown, button: eraseToolBtn }, { dropdown: aiToolsDropdown, button: aiToolsBtn } ];
                const clickedInsidePopup = popups.some(p => p.dropdown.contains(e.target));
                if (e.target.type !== 'color' && !clickedInsidePopup) {
                    popups.forEach(p => {
                        if (!p.button.contains(e.target)) {
                             if (p.dropdown.id === 'erase-tool-dropdown' && p.dropdown.classList.contains('visible') && eraserMode !== 'none' && !isEraserArmed) {
                                isEraserArmed = true; 
                                showEraserHUD(true); 
                                updateEraserHudState(); 
                                movieCanvas.classList.add('erase-cursor');
                                const toastMsg = `${eraserMode==='erase'?'Erase':'Unerase'} Mode Activated. Press [ESC] to deactivate.`;
                                toast(toastMsg, null);
                            }
                            p.dropdown.classList.remove('visible');
                        }
                    });
                }
                if (!customFontSelect.contains(e.target)) { closeFontDropdown(); }
            });
            
            // --- PROJECT LIBRARY EVENT LISTENERS (RESTORED & NEW) ---
                       // --- THIS IS THE NEW, UPDATED CODE ---
            viewAllLocalAssetsBtn.addEventListener('click', () => {
                populateProjectLibraryPopup();
                const lastTab = localStorage.getItem('ims-last-library-tab') || 'assets'; // Get saved tab or default to 'assets'
                setLocalFolderTab(lastTab);
                projectLibraryPopupOverlay.classList.add('visible');
            });
            projectLibraryPopupCloseBtn.addEventListener('click', () => projectLibraryPopupOverlay.classList.remove('visible'));
            projectLibraryPopupOverlay.addEventListener('click', (e) => {
                if (e.target === projectLibraryPopupOverlay) projectLibraryPopupOverlay.classList.remove('visible');
            });
                        // --- THIS IS THE NEW, UPDATED CODE ---
            libraryTabProjectsBtn.addEventListener('click', () => switchAndSaveLibraryTab('projects'));
            libraryTabAssetsBtn.addEventListener('click', () => switchAndSaveLibraryTab('assets'));
            libraryTabBackgroundsBtn.addEventListener('click', () => switchAndSaveLibraryTab('backgrounds'));
            libraryTabFavoritesBtn.addEventListener('click', () => switchAndSaveLibraryTab('favorites'));
            
            // --- SLIDER SYNCHRONIZATION ---
            eraserSizeDropdown.addEventListener('input', () => { eraserSizeSlider.value = eraserSizeDropdown.value; });
            eraserStrengthDropdown.addEventListener('input', () => { eraserStrengthSlider.value = eraserStrengthDropdown.value; });
            
            eraserSizeSlider.addEventListener('input', () => {
                eraserSizeDropdown.value = eraserSizeSlider.value;
                if (eraserZoomCanvas.classList.contains('visible') && lastEraseCanvasPoint) drawEraserZoomAt(lastEraseCanvasPoint);
            });
             eraserStrengthSlider.addEventListener('input', () => { eraserStrengthDropdown.value = eraserStrengthSlider.value; });


            toggleViewBtn.addEventListener('click', toggleCanvasZoom);
            const canvasResizeObserver = new ResizeObserver(() => { resizeCanvas(); drawFrame(); });
            canvasResizeObserver.observe(canvasPanel);
        };
        
        async function initialize() {
            const minDisplayTime = new Promise(resolve => setTimeout(resolve, 2400)); 
            
            const setupPromise = (async () => {
                injectNonCriticalStyles();
                populateThemeList();
                populateCustomFontSelector();
                await dedupeExistingAssetsByHashKeepNewest();
                await restoreCurrentWork();
                updateControlsState();
                updateEditPanelsUI();
                setupEventListeners();
                drawFrame();
            })();

            await Promise.all([minDisplayTime, setupPromise]);
            hideLoadingScreen();
        }

        initialize();
    })();
</script>
</body>
</html>